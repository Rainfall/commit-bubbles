{
  "when": "2012-01-03T01:44:07-05:00", 
  "message": "Some improvements and control over how threads are handled by the FIX transport", 
  "who": "hiranya", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-21,6 +21,7", 
          "lines": [
            " \n", 
            " import org.apache.axis2.AxisFault;\n", 
            " import org.apache.axis2.Constants;\n", 
            "+import org.apache.axis2.util.JavaUtils;\n", 
            " import org.apache.axis2.wsdl.WSDLConstants;\n", 
            " import org.apache.axis2.context.ConfigurationContext;\n", 
            " import org.apache.axis2.context.MessageContext;\n"
          ]
        }, 
        {
          "locn": "-70,9 +71,10", 
          "lines": [
            "     private boolean dropExtraResponses = false;\n", 
            "     private Semaphore semaphore;\n", 
            "     private SessionEventHandler eventHandler;\n", 
            "+    private boolean singleThreaded;\n", 
            " \n", 
            "     public FIXIncomingMessageHandler(ConfigurationContext cfgCtx, WorkerPool workerPool,\n", 
            "-                             AxisService service, boolean acceptor) {\n", 
            "+                                     AxisService service, boolean acceptor) {\n", 
            "         this.cfgCtx = cfgCtx;\n", 
            "         this.workerPool = workerPool;\n", 
            "         this.service = service;\n"
          ]
        }, 
        {
          "locn": "-104,6 +106,8", 
          "lines": [
            "                         eventHandlerParam.getValue(), e);\n", 
            "             }\n", 
            "         }\n", 
            "+\n", 
            "+        singleThreaded = isSingleThreaded();\n", 
            "     }\n", 
            " \n", 
            "     private void getResponseHandlingApproach() {\n"
          ]
        }, 
        {
          "locn": "-118,6 +122,35", 
          "lines": [
            "         }\n", 
            "     }\n", 
            " \n", 
            "+    private boolean isSingleThreaded() {\n", 
            "+        Parameter singleThreadParam = service.getParameter(\n", 
            "+                FIXConstants.FIX_ACCEPTOR_SINGLE_THREADED);\n", 
            "+        if (acceptor && singleThreadParam != null &&\n", 
            "+                JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {\n", 
            "+            log.info(\"FIX acceptor for service: \" + service.getName() + \" is single threaded\");\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+\n", 
            "+        singleThreadParam = service.getParameter(\n", 
            "+                FIXConstants.FIX_INITIATOR_SINGLE_THREADED);\n", 
            "+        if (!acceptor && singleThreadParam != null &&\n", 
            "+                JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {\n", 
            "+            log.info(\"FIX initiator for service: \" + service.getName() + \" is single threaded\");\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+\n", 
            "+        singleThreadParam = service.getParameter(\n", 
            "+                FIXConstants.FIX_PROCESS_SINGLE_THREADED);\n", 
            "+        if (singleThreadParam != null &&\n", 
            "+                JavaUtils.isTrueExplicitly(singleThreadParam.getValue())) {\n", 
            "+            log.info(\"FIX processor for service: \" + service.getName() + \" is single threaded\");\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+\n", 
            "+        return false;\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "     public void setOutgoingMessageContext(MessageContext msgCtx) {\n", 
            "         if (!allNewApproach) {\n", 
            "             outgoingMessages.offer(msgCtx);\n"
          ]
        }, 
        {
          "locn": "-260,7 +293,7", 
          "lines": [
            "      * @throws DoNotSend This exception aborts message transmission\n", 
            "      */\n", 
            "     public void toApp(Message message, SessionID sessionID) throws DoNotSend {\n", 
            "-          if (log.isDebugEnabled()) {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "             StringBuffer sb = new StringBuffer();\n", 
            "             try {\n", 
            "                 sb.append(\"Sending application level FIX message to \").append(message.getHeader().getField(new TargetCompID()).getValue());\n"
          ]
        }, 
        {
          "locn": "-314,124 +347,129", 
          "lines": [
            "         if (rolled && log.isDebugEnabled()) {\n", 
            "             log.debug(\"Incoming request counter rolled over for the session: \" + sessionID);\n", 
            "         }\n", 
            "-        workerPool.execute(new FIXWorkerThread(message, sessionID, counter));\n", 
            "+        if (singleThreaded) {\n", 
            "+            processMessage(message, sessionID, counter);\n", 
            "+        } else {\n", 
            "+            workerPool.execute(new FIXWorkerThread(message, sessionID, counter));\n", 
            "+        }\n", 
            "     }\n", 
            " \n", 
            "-    /**\n", 
            "-     * This Runnable class can be used when it is required to process each incoming message\n", 
            "-     * using separate threads.\n", 
            "-     */\n", 
            "-    class FIXWorkerThread implements Runnable {\n", 
            "+    public void processMessage(Message message, SessionID sessionID, int counter) {\n", 
            "+        if (allNewApproach) {\n", 
            "+            //treat all messages (including responses) as new messages\n", 
            "+            handleIncomingRequest(message, sessionID, counter);\n", 
            "+        } else {\n", 
            "+            if (acceptor) {\n", 
            "+                //treat messages coming from an acceptor as new request messages\n", 
            "+                handleIncomingRequest(message, sessionID, counter);\n", 
            "+            } else {\n", 
            "+                MessageContext outMsgCtx = outgoingMessages.poll();\n", 
            "+                if (outMsgCtx != null) {\n", 
            "+                    //handle as a response to an outgoing message\n", 
            "+                    handleIncomingResponse(outMsgCtx, message, sessionID, counter);\n", 
            "+                } else if (!dropExtraResponses) {\n", 
            "+                    //handle as a new request message\n", 
            "+                    handleIncomingRequest(message, sessionID, counter);\n", 
            "+                } else {\n", 
            "+                    log.debug(\"Dropping additional FIX response\");\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            " \n", 
            "-        private Message message;\n", 
            "-        private SessionID sessionID;\n", 
            "-        private int counter;\n", 
            "-\n", 
            "-        public FIXWorkerThread(Message message, SessionID sessionID, int counter) {\n", 
            "-            this.message = message;\n", 
            "-            this.sessionID = sessionID;\n", 
            "-            this.counter = counter;\n", 
            "+    private void handleIncomingRequest(Message message, SessionID sessionID, int counter) {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Source session: \" + sessionID + \" - Received message with sequence \" +\n", 
            "+                    \"number \" + counter);\n", 
            "         }\n", 
            " \n", 
            "-        private void handleIncomingRequest() {\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"Source session: \" + sessionID + \" - Received message with sequence \" +\n", 
            "-                        \"number \" + counter);\n", 
            "-            }\n", 
            "+        //Create message context for the incoming message\n", 
            "+        AbstractTransportListener trpListener = (AbstractTransportListener) cfgCtx.getAxisConfiguration().\n", 
            "+                getTransportIn(FIXConstants.TRANSPORT_NAME).getReceiver();\n", 
            " \n", 
            "-            //Create message context for the incoming message\n", 
            "-            AbstractTransportListener trpListener = (AbstractTransportListener) cfgCtx.getAxisConfiguration().\n", 
            "-                    getTransportIn(FIXConstants.TRANSPORT_NAME).getReceiver();\n", 
            "+        MessageContext msgCtx = trpListener.createMessageContext();\n", 
            "+        msgCtx.setProperty(Constants.OUT_TRANSPORT_INFO, new FIXOutTransportInfo(sessionID));\n", 
            " \n", 
            "-            MessageContext msgCtx = trpListener.createMessageContext();\n", 
            "-            msgCtx.setProperty(Constants.OUT_TRANSPORT_INFO, new FIXOutTransportInfo(sessionID));\n", 
            "-\n", 
            "-            if (service != null) {\n", 
            "-                // Set the service for which the message is intended to\n", 
            "-                msgCtx.setAxisService(service);\n", 
            "-                // find the operation for the message, or default to one\n", 
            "-                Parameter operationParam = service.getParameter(BaseConstants.OPERATION_PARAM);\n", 
            "-                QName operationQName = (\n", 
            "+        if (service != null) {\n", 
            "+            // Set the service for which the message is intended to\n", 
            "+            msgCtx.setAxisService(service);\n", 
            "+            // find the operation for the message, or default to one\n", 
            "+            Parameter operationParam = service.getParameter(BaseConstants.OPERATION_PARAM);\n", 
            "+            QName operationQName = (\n", 
            "                     operationParam != null ?\n", 
            "-                        BaseUtils.getQNameFromString(operationParam.getValue()) :\n", 
            "-                        BaseConstants.DEFAULT_OPERATION);\n", 
            "+                            BaseUtils.getQNameFromString(operationParam.getValue()) :\n", 
            "+                            BaseConstants.DEFAULT_OPERATION);\n", 
            " \n", 
            "-                AxisOperation operation = service.getOperation(operationQName);\n", 
            "-                if (operation != null) {\n", 
            "-                    msgCtx.setAxisOperation(operation);\n", 
            "-                    msgCtx.setAxisMessage(operation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n", 
            "-                    msgCtx.setSoapAction(\"urn:\" + operation.getName().getLocalPart());\n", 
            "-                }\n", 
            "+            AxisOperation operation = service.getOperation(operationQName);\n", 
            "+            if (operation != null) {\n", 
            "+                msgCtx.setAxisOperation(operation);\n", 
            "+                msgCtx.setAxisMessage(operation.getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n", 
            "+                msgCtx.setSoapAction(\"urn:\" + operation.getName().getLocalPart());\n", 
            "             }\n", 
            "+        }\n", 
            " \n", 
            "-            String fixApplication = FIXConstants.FIX_INITIATOR;\n", 
            "-            if (acceptor) {\n", 
            "-                fixApplication = FIXConstants.FIX_ACCEPTOR;\n", 
            "-            } else {\n", 
            "-                msgCtx.setProperty(\"synapse.isresponse\", true);\n", 
            "-            }\n", 
            "+        String fixApplication = FIXConstants.FIX_INITIATOR;\n", 
            "+        if (acceptor) {\n", 
            "+            fixApplication = FIXConstants.FIX_ACCEPTOR;\n", 
            "+        } else {\n", 
            "+            msgCtx.setProperty(\"synapse.isresponse\", true);\n", 
            "+        }\n", 
            " \n", 
            "-            try {\n", 
            "-                //Put the FIX message in a SOAPEnvelope\n", 
            "-                FIXUtils.getInstance().setSOAPEnvelope(message, counter, sessionID.toString(), msgCtx);\n", 
            "-                trpListener.handleIncomingMessage(\n", 
            "-                        msgCtx,\n", 
            "-                        FIXUtils.getTransportHeaders(service.getName(), fixApplication),\n", 
            "-                        null,\n", 
            "-                        FIXConstants.FIX_DEFAULT_CONTENT_TYPE\n", 
            "-                );\n", 
            "-            } catch (AxisFault e) {\n", 
            "-                handleException(\"Error while processing FIX message\", e);\n", 
            "-            }\n", 
            "+        try {\n", 
            "+            //Put the FIX message in a SOAPEnvelope\n", 
            "+            FIXUtils.getInstance().setSOAPEnvelope(message, counter, sessionID.toString(), msgCtx);\n", 
            "+            trpListener.handleIncomingMessage(\n", 
            "+                    msgCtx,\n", 
            "+                    FIXUtils.getTransportHeaders(service.getName(), fixApplication),\n", 
            "+                    null,\n", 
            "+                    FIXConstants.FIX_DEFAULT_CONTENT_TYPE\n", 
            "+            );\n", 
            "+        } catch (AxisFault e) {\n", 
            "+            handleException(\"Error while processing FIX message\", e);\n", 
            "         }\n", 
            "+    }\n", 
            " \n", 
            "-        private void handleIncomingResponse(MessageContext outMsgCtx) {\n", 
            "-            AbstractTransportSender trpSender = (AbstractTransportSender) cfgCtx.getAxisConfiguration().\n", 
            "-                        getTransportOut(FIXConstants.TRANSPORT_NAME).getSender();\n", 
            "+    private void handleIncomingResponse(MessageContext outMsgCtx, Message message,\n", 
            "+                                        SessionID sessionID, int counter) {\n", 
            "+        AbstractTransportSender trpSender = (AbstractTransportSender) cfgCtx.getAxisConfiguration().\n", 
            "+                getTransportOut(FIXConstants.TRANSPORT_NAME).getSender();\n", 
            " \n", 
            "-            MessageContext msgCtx = trpSender.createResponseMessageContext(outMsgCtx);\n", 
            "+        MessageContext msgCtx = trpSender.createResponseMessageContext(outMsgCtx);\n", 
            " \n", 
            "-            try {\n", 
            "-                //Put the FIX message in a SOAPEnvelope\n", 
            "-                FIXUtils.getInstance().setSOAPEnvelope(message, counter, sessionID.toString(), msgCtx);\n", 
            "-                msgCtx.setServerSide(true);\n", 
            "-                trpSender.handleIncomingMessage(\n", 
            "-                        msgCtx,\n", 
            "-                        FIXUtils.getTransportHeaders(service.getName(), FIXConstants.FIX_INITIATOR),\n", 
            "-                        null,\n", 
            "-                        FIXConstants.FIX_DEFAULT_CONTENT_TYPE\n", 
            "-                );\n", 
            "-            } catch (AxisFault e) {\n", 
            "-                handleException(\"Error while processing response FIX message\", e);\n", 
            "-            }\n", 
            "+        try {\n", 
            "+            //Put the FIX message in a SOAPEnvelope\n", 
            "+            FIXUtils.getInstance().setSOAPEnvelope(message, counter, sessionID.toString(), msgCtx);\n", 
            "+            msgCtx.setServerSide(true);\n", 
            "+            trpSender.handleIncomingMessage(\n", 
            "+                    msgCtx,\n", 
            "+                    FIXUtils.getTransportHeaders(service.getName(), FIXConstants.FIX_INITIATOR),\n", 
            "+                    null,\n", 
            "+                    FIXConstants.FIX_DEFAULT_CONTENT_TYPE\n", 
            "+            );\n", 
            "+        } catch (AxisFault e) {\n", 
            "+            handleException(\"Error while processing response FIX message\", e);\n", 
            "         }\n", 
            "+    }\n", 
            " \n", 
            "-        public void run() {\n", 
            "+    /**\n", 
            "+     * This Runnable class can be used when it is required to process each incoming message\n", 
            "+     * using separate threads.\n", 
            "+     */\n", 
            "+    class FIXWorkerThread implements Runnable {\n", 
            " \n", 
            "-            if (allNewApproach) {\n", 
            "-                //treat all messages (including responses) as new messages\n", 
            "-                handleIncomingRequest();\n", 
            "-            }\n", 
            "-            else {\n", 
            "-                if (acceptor) {\n", 
            "-                    //treat messages coming from an acceptor as new request messages\n", 
            "-                    handleIncomingRequest();\n", 
            "-                }\n", 
            "-                else {\n", 
            "-                    MessageContext outMsgCtx = outgoingMessages.poll();\n", 
            "-                    if (outMsgCtx != null) {\n", 
            "-                        //handle as a response to an outgoing message\n", 
            "-                        handleIncomingResponse(outMsgCtx);\n", 
            "-                    } else if (!dropExtraResponses) {\n", 
            "-                        //handle as a new request message\n", 
            "-                        handleIncomingRequest();\n", 
            "-                    } else {\n", 
            "-                        log.debug(\"Dropping additional FIX response\");\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            }\n", 
            "+        private Message message;\n", 
            "+        private SessionID sessionID;\n", 
            "+        private int counter;\n", 
            "+\n", 
            "+        public FIXWorkerThread(Message message, SessionID sessionID, int counter) {\n", 
            "+            this.message = message;\n", 
            "+            this.sessionID = sessionID;\n", 
            "+            this.counter = counter;\n", 
            "         }\n", 
            " \n", 
            "+        public void run() {\n", 
            "+            processMessage(message, sessionID, counter);\n", 
            "+        }\n", 
            "     }\n", 
            " \n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/fix/src/main/java/org/apache/synapse/transport/fix/FIXIncomingMessageHandler.java", 
      "from": "java/modules/transports/optional/fix/src/main/java/org/apache/synapse/transport/fix/FIXIncomingMessageHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-24,6 +24,7", 
          "lines": [
            " import org.apache.axis2.description.Parameter;\n", 
            " import org.apache.axis2.transport.base.BaseUtils;\n", 
            " import org.apache.axis2.transport.base.threads.WorkerPool;\n", 
            "+import org.apache.axis2.util.JavaUtils;\n", 
            " import org.apache.commons.logging.Log;\n", 
            " import org.apache.commons.logging.LogFactory;\n", 
            " import org.quickfixj.jmx.JmxExporter;\n"
          ]
        }, 
        {
          "locn": "-120,13 +121,24", 
          "lines": [
            "                 //Get a new FIX Application\n", 
            "                 Application messageHandler = applicationFactory.getFIXApplication(service,\n", 
            "                         listenerThreadPool, true);\n", 
            "+                boolean threadedConnector = useThreadedConnector(service, true);\n", 
            "                 //Create a new FIX Acceptor\n", 
            "-                Acceptor acceptor = new SocketAcceptor(\n", 
            "-                        messageHandler,\n", 
            "-                        storeFactory,\n", 
            "-                        settings,\n", 
            "-                        logFactory,\n", 
            "-                        messageFactory);\n", 
            "+                Acceptor acceptor;\n", 
            "+                if (threadedConnector) {\n", 
            "+                    acceptor = new ThreadedSocketAcceptor(\n", 
            "+                            messageHandler,\n", 
            "+                            storeFactory,\n", 
            "+                            settings,\n", 
            "+                            logFactory,\n", 
            "+                            messageFactory);\n", 
            "+                } else {\n", 
            "+                    acceptor = new SocketAcceptor(\n", 
            "+                            messageHandler,\n", 
            "+                            storeFactory,\n", 
            "+                            settings,\n", 
            "+                            logFactory,\n", 
            "+                            messageFactory);\n", 
            "+                }\n", 
            " \n", 
            "                 acceptor.start();\n", 
            "                 initJMX(acceptor, service.getName());\n"
          ]
        }, 
        {
          "locn": "-197,15 +209,26", 
          "lines": [
            "         //Get a new FIX application\n", 
            "         Application messageHandler = applicationFactory.getFIXApplication(service,\n", 
            "                 senderThreadPool, false);\n", 
            "+        boolean threadedConnector = useThreadedConnector(service, false);\n", 
            " \n", 
            "         try {\n", 
            "            //Create a new FIX initiator\n", 
            "-            Initiator initiator = new SocketInitiator(\n", 
            "-                    messageHandler,\n", 
            "-                    storeFactory,\n", 
            "-                    settings,\n", 
            "-                    logFactory,\n", 
            "-                    messageFactory);\n", 
            "+            Initiator initiator;\n", 
            "+            if (threadedConnector) {\n", 
            "+                initiator = new ThreadedSocketInitiator(\n", 
            "+                        messageHandler,\n", 
            "+                        storeFactory,\n", 
            "+                        settings,\n", 
            "+                        logFactory,\n", 
            "+                        messageFactory);\n", 
            "+            } else {\n", 
            "+                initiator = new SocketInitiator(\n", 
            "+                        messageHandler,\n", 
            "+                        storeFactory,\n", 
            "+                        settings,\n", 
            "+                        logFactory,\n", 
            "+                        messageFactory);\n", 
            "+            }\n", 
            " \n", 
            "             initiator.start();\n", 
            "             initJMX(initiator, service.getName());\n"
          ]
        }, 
        {
          "locn": "-242,12 +265,23", 
          "lines": [
            "                 Application messageHandler = applicationFactory.getFIXApplication(service,\n", 
            "                         senderThreadPool, false);\n", 
            " \n", 
            "-                Initiator initiator = new SocketInitiator(\n", 
            "-                    messageHandler,\n", 
            "-                    storeFactory,\n", 
            "-                    settings,\n", 
            "-                    logFactory,\n", 
            "-                    messageFactory);\n", 
            "+                boolean threadedConnector = useThreadedConnector(service, false);\n", 
            "+                Initiator initiator;\n", 
            "+                if (threadedConnector) {\n", 
            "+                    initiator = new ThreadedSocketInitiator(\n", 
            "+                            messageHandler,\n", 
            "+                            storeFactory,\n", 
            "+                            settings,\n", 
            "+                            logFactory,\n", 
            "+                            messageFactory);\n", 
            "+                } else {\n", 
            "+                    initiator = new SocketInitiator(\n", 
            "+                            messageHandler,\n", 
            "+                            storeFactory,\n", 
            "+                            settings,\n", 
            "+                            logFactory,\n", 
            "+                            messageFactory);\n", 
            "+                }\n", 
            " \n", 
            "                 initiator.start();\n", 
            "                 initJMX(initiator, service.getName());\n"
          ]
        }, 
        {
          "locn": "-511,6 +545,25", 
          "lines": [
            "             log.error(\"Error while initializing JMX support for the service: \" + service, e);\n", 
            "         }\n", 
            "     }\n", 
            "+\n", 
            "+    private boolean useThreadedConnector(AxisService service, boolean acceptor) {\n", 
            "+\t    Parameter param = service.getParameter(FIXConstants.FIX_USE_THREADED_ACCEPTOR);\n", 
            "+        if (acceptor && param != null && JavaUtils.isTrueExplicitly(param.getValue())) {\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+\n", 
            "+        param = service.getParameter(FIXConstants.FIX_USE_THREADED_INITIATOR);\n", 
            "+        if (!acceptor && param != null && JavaUtils.isTrueExplicitly(param.getValue())) {\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+\n", 
            "+        param = service.getParameter(FIXConstants.FIX_USE_THREADED_CONNECTORS);\n", 
            "+        if (param != null && JavaUtils.isTrueExplicitly(param.getValue())) {\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+\n", 
            "+        return false;\n", 
            "+    }\n", 
            " }\n", 
            " \n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/fix/src/main/java/org/apache/synapse/transport/fix/FIXSessionFactory.java", 
      "from": "java/modules/transports/optional/fix/src/main/java/org/apache/synapse/transport/fix/FIXSessionFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-107,6 +107,14", 
          "lines": [
            "     public static final String FIX_ACCEPTOR_EVENT_HANDLER = \"transport.fix.AcceptorSessionEventHandler\";\n", 
            "     public static final String FIX_INITIATOR_EVENT_HANDLER = \"transport.fix.InitiatorSessionEventHandler\";\n", 
            " \n", 
            "+    public static final String FIX_PROCESS_SINGLE_THREADED = \"transport.fix.ProcessSingleThreaded\";\n", 
            "+    public static final String FIX_ACCEPTOR_SINGLE_THREADED = \"transport.fix.AcceptorSingleThreaded\";\n", 
            "+    public static final String FIX_INITIATOR_SINGLE_THREADED = \"transport.fix.InitiatorSingleThreaded\";\n", 
            "+\n", 
            "+    public static final String FIX_USE_THREADED_CONNECTORS = \"transport.fix.UseThreadedConnectors\";\n", 
            "+    public static final String FIX_USE_THREADED_ACCEPTOR = \"transport.fix.UseThreadedAcceptor\";\n", 
            "+    public static final String FIX_USE_THREADED_INITIATOR = \"transport.fix.UseThreadedInitiator\";\n", 
            "+\n", 
            "     //--------------------------- Message level properties -----------------------------------\n", 
            " \n", 
            "     public static final String FIX_IGNORE_ORDER = \"transport.fix.IgnoreOrder\";\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/fix/src/main/java/org/apache/synapse/transport/fix/FIXConstants.java", 
      "from": "java/modules/transports/optional/fix/src/main/java/org/apache/synapse/transport/fix/FIXConstants.java"
    }
  ], 
  "id": "1226672"
}