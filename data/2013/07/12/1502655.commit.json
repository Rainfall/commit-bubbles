{
  "when": "2013-07-12T14:57:16-04:00", 
  "message": "Temporarily reverting SYNAPSE-913 fix. This will be superceded by the SYNAPSE-920.\n", 
  "who": "hiranya", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-1,338 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.axiom.om.OMElement;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.description.Parameter;\n", 
            "-import org.apache.axis2.description.TransportOutDescription;\n", 
            "-import org.apache.axis2.transport.base.ParamUtils;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.impl.nio.reactor.SSLSetupHandler;\n", 
            "-import org.apache.http.nio.NHttpClientHandler;\n", 
            "-import org.apache.http.nio.reactor.IOEventDispatch;\n", 
            "-import org.apache.http.nio.reactor.IOSession;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-\n", 
            "-import javax.net.ssl.*;\n", 
            "-import javax.xml.namespace.QName;\n", 
            "-import java.io.FileInputStream;\n", 
            "-import java.io.IOException;\n", 
            "-import java.net.InetSocketAddress;\n", 
            "-import java.net.SocketAddress;\n", 
            "-import java.security.GeneralSecurityException;\n", 
            "-import java.security.KeyStore;\n", 
            "-import java.security.cert.CertificateException;\n", 
            "-import java.security.cert.X509Certificate;\n", 
            "-import java.util.HashMap;\n", 
            "-import java.util.Iterator;\n", 
            "-import java.util.Map;\n", 
            "-\n", 
            "-\n", 
            "-public class PassThroughHttpSSLSender extends PassThroughHttpSender {\n", 
            "-    private Log log = LogFactory.getLog(PassThroughHttpSSLSender.class);\n", 
            "-\n", 
            "-    protected IOEventDispatch getEventDispatch(NHttpClientHandler handler,\n", 
            "-                                               SSLContext sslContext,\n", 
            "-                                               SSLSetupHandler sslIOSessionHandler,\n", 
            "-                                               HttpParams params,\n", 
            "-                                               TransportOutDescription transportOut)\n", 
            "-            throws AxisFault {\n", 
            "-\n", 
            "-        SSLTargetIOEventDispatch dispatch = new SSLTargetIOEventDispatch(handler, sslContext,\n", 
            "-                sslIOSessionHandler, params);\n", 
            "-        dispatch.setContextMap(getCustomSSLContexts(transportOut));\n", 
            "-        return dispatch;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Create the SSLContext to be used by this sender\n", 
            "-     *\n", 
            "-     * @param transportOut the Axis2 transport configuration\n", 
            "-     * @return the SSLContext to be used\n", 
            "-     * @throws org.apache.axis2.AxisFault if an error occurs\n", 
            "-     */\n", 
            "-    protected SSLContext getSSLContext(TransportOutDescription transportOut) throws AxisFault {\n", 
            "-\n", 
            "-        Parameter keyParam    = transportOut.getParameter(\"keystore\");\n", 
            "-        Parameter trustParam  = transportOut.getParameter(\"truststore\");\n", 
            "-\n", 
            "-        OMElement ksEle = null;\n", 
            "-        OMElement tsEle = null;\n", 
            "-\n", 
            "-        if (keyParam != null) {\n", 
            "-            ksEle = keyParam.getParameterElement().getFirstElement();\n", 
            "-        }\n", 
            "-\n", 
            "-        boolean noValidateCert = ParamUtils.getOptionalParamBoolean(transportOut,\n", 
            "-                \"novalidatecert\", false);\n", 
            "-\n", 
            "-        if (trustParam != null) {\n", 
            "-            if (noValidateCert) {\n", 
            "-                log.warn(\"Ignoring novalidatecert parameter since a truststore has been specified\");\n", 
            "-            }\n", 
            "-            tsEle = trustParam.getParameterElement().getFirstElement();\n", 
            "-        }\n", 
            "-\n", 
            "-        return createSSLContext(ksEle, tsEle, noValidateCert);\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Create the SSLIOSessionHandler to initialize the host name verification at the following\n", 
            "-     * levels, through an Axis2 transport configuration parameter as follows:\n", 
            "-     * HostnameVerifier - Default, DefaultAndLocalhost, Strict, AllowAll\n", 
            "-     *\n", 
            "-     * @param transportOut the Axis2 transport configuration\n", 
            "-     * @return the SSLIOSessionHandler to be used\n", 
            "-     * @throws AxisFault if a configuration error occurs\n", 
            "-     */\n", 
            "-    protected SSLSetupHandler getSSLSetupHandler(TransportOutDescription transportOut)\n", 
            "-            throws AxisFault {\n", 
            "-\n", 
            "-        final Parameter hostnameVerifier = transportOut.getParameter(\"HostnameVerifier\");\n", 
            "-        if (hostnameVerifier != null) {\n", 
            "-            return createSSLIOSessionHandler(hostnameVerifier.getValue().toString());\n", 
            "-        } else {\n", 
            "-            return createSSLIOSessionHandler(null);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Looks for a transport parameter named customSSLProfiles and initializes zero or more\n", 
            "-     * custom SSLContext instances. The syntax for defining custom SSL profiles is as follows.\n", 
            "-     *\n", 
            "-     * <parameter name=\"customSSLProfiles>\n", 
            "-     *      <profile>\n", 
            "-     *          <servers>www.test.org:80, www.test2.com:9763</servers>\n", 
            "-     *          <KeyStore>\n", 
            "-     *              <Location>/path/to/identity/store</Location>\n", 
            "-     *              <Type>JKS</Type>\n", 
            "-     *              <Password>password</Password>\n", 
            "-     *              <KeyPassword>password</KeyPassword>\n", 
            "-     *          </KeyStore>\n", 
            "-     *          <TrustStore>\n", 
            "-     *              <Location>path/tp/trust/store</Location>\n", 
            "-     *              <Type>JKS</Type>\n", 
            "-     *              <Password>password</Password>\n", 
            "-     *          </TrustStore>\n", 
            "-     *      </profile>\n", 
            "-     * </parameter>\n", 
            "-     *\n", 
            "-     * Any number of profiles can be defined under the customSSLProfiles parameter.\n", 
            "-     *\n", 
            "-     * @param transportOut transport out description\n", 
            "-     * @return a map of server addresses and SSL contexts\n", 
            "-     * @throws AxisFault if at least on SSL profile is not properly configured\n", 
            "-     */\n", 
            "-    private Map<String, SSLContext> getCustomSSLContexts(TransportOutDescription transportOut)\n", 
            "-            throws AxisFault {\n", 
            "-\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            log.info(\"Loading custom SSL profiles for the HTTPS sender\");\n", 
            "-        }\n", 
            "-\n", 
            "-        Parameter customProfilesParam = transportOut.getParameter(\"customSSLProfiles\");\n", 
            "-        if (customProfilesParam == null) {\n", 
            "-            return null;\n", 
            "-        }\n", 
            "-\n", 
            "-        OMElement customProfilesElt = customProfilesParam.getParameterElement();\n", 
            "-        Iterator profiles = customProfilesElt.getChildrenWithName(new QName(\"profile\"));\n", 
            "-        Map<String, SSLContext> contextMap = new HashMap<String, SSLContext>();\n", 
            "-        while (profiles.hasNext()) {\n", 
            "-            OMElement profile = (OMElement) profiles.next();\n", 
            "-            OMElement serversElt = profile.getFirstChildWithName(new QName(\"servers\"));\n", 
            "-            if (serversElt == null || serversElt.getText() == null) {\n", 
            "-                String msg = \"Each custom SSL profile must define at least one host:port \" +\n", 
            "-                        \"pair under the servers element\";\n", 
            "-                log.error(msg);\n", 
            "-                throw new AxisFault(msg);\n", 
            "-            }\n", 
            "-\n", 
            "-            String[] servers = serversElt.getText().split(\",\");\n", 
            "-            OMElement ksElt = profile.getFirstChildWithName(new QName(\"KeyStore\"));\n", 
            "-            OMElement trElt = profile.getFirstChildWithName(new QName(\"TrustStore\"));\n", 
            "-            String noValCert = profile.getAttributeValue(new QName(\"novalidatecert\"));\n", 
            "-            boolean novalidatecert = \"true\".equals(noValCert);\n", 
            "-            SSLContext sslContext = createSSLContext(ksElt, trElt, novalidatecert);\n", 
            "-\n", 
            "-            for (String server : servers) {\n", 
            "-                server = server.trim();\n", 
            "-                if (!contextMap.containsKey(server)) {\n", 
            "-                    contextMap.put(server, sslContext);\n", 
            "-                } else {\n", 
            "-                    log.warn(\"Multiple SSL profiles were found for the server : \" + server + \". \" +\n", 
            "-                            \"Ignoring the excessive profiles.\");\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        if (contextMap.size() > 0) {\n", 
            "-            log.info(\"Custom SSL profiles initialized for \" + contextMap.size() + \" servers\");\n", 
            "-            return contextMap;\n", 
            "-        }\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    private SSLContext createSSLContext(OMElement keyStoreElt, OMElement trustStoreElt,\n", 
            "-                                        boolean novalidatecert) throws AxisFault {\n", 
            "-\n", 
            "-        KeyManager[] keymanagers  = null;\n", 
            "-        TrustManager[] trustManagers = null;\n", 
            "-\n", 
            "-\n", 
            "-        if (keyStoreElt != null) {\n", 
            "-            String location      = keyStoreElt.getFirstChildWithName(new QName(\"Location\")).getText();\n", 
            "-            String type          = keyStoreElt.getFirstChildWithName(new QName(\"Type\")).getText();\n", 
            "-            String storePassword = keyStoreElt.getFirstChildWithName(new QName(\"Password\")).getText();\n", 
            "-            String keyPassword   = keyStoreElt.getFirstChildWithName(new QName(\"KeyPassword\")).getText();\n", 
            "-\n", 
            "-            FileInputStream fis = null;\n", 
            "-            try {\n", 
            "-                KeyStore keyStore = KeyStore.getInstance(type);\n", 
            "-                fis = new FileInputStream(location);\n", 
            "-                log.info(\"Loading Identity Keystore from : \" + location);\n", 
            "-\n", 
            "-                keyStore.load(fis, storePassword.toCharArray());\n", 
            "-                KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(\n", 
            "-                    KeyManagerFactory.getDefaultAlgorithm());\n", 
            "-                kmfactory.init(keyStore, keyPassword.toCharArray());\n", 
            "-                keymanagers = kmfactory.getKeyManagers();\n", 
            "-\n", 
            "-            } catch (GeneralSecurityException gse) {\n", 
            "-                log.error(\"Error loading Keystore : \" + location, gse);\n", 
            "-                throw new AxisFault(\"Error loading Keystore : \" + location, gse);\n", 
            "-            } catch (IOException ioe) {\n", 
            "-                log.error(\"Error opening Keystore : \" + location, ioe);\n", 
            "-                throw new AxisFault(\"Error opening Keystore : \" + location, ioe);\n", 
            "-            } finally {\n", 
            "-                if (fis != null) {\n", 
            "-                    try {\n", 
            "-                        fis.close();\n", 
            "-                    } catch (IOException ignore) {}\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        if (trustStoreElt != null) {\n", 
            "-            if (novalidatecert) {\n", 
            "-                log.warn(\"Ignoring novalidatecert parameter since a truststore has been specified\");\n", 
            "-            }\n", 
            "-\n", 
            "-            String location      = trustStoreElt.getFirstChildWithName(new QName(\"Location\")).getText();\n", 
            "-            String type          = trustStoreElt.getFirstChildWithName(new QName(\"Type\")).getText();\n", 
            "-            String storePassword = trustStoreElt.getFirstChildWithName(new QName(\"Password\")).getText();\n", 
            "-\n", 
            "-            FileInputStream fis = null;\n", 
            "-            try {\n", 
            "-                KeyStore trustStore = KeyStore.getInstance(type);\n", 
            "-                fis = new FileInputStream(location);\n", 
            "-                log.info(\"Loading Trust Keystore from : \" + location);\n", 
            "-\n", 
            "-                trustStore.load(fis, storePassword.toCharArray());\n", 
            "-                TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance(\n", 
            "-                    TrustManagerFactory.getDefaultAlgorithm());\n", 
            "-                trustManagerfactory.init(trustStore);\n", 
            "-                trustManagers = trustManagerfactory.getTrustManagers();\n", 
            "-\n", 
            "-            } catch (GeneralSecurityException gse) {\n", 
            "-                log.error(\"Error loading Key store : \" + location, gse);\n", 
            "-                throw new AxisFault(\"Error loading Key store : \" + location, gse);\n", 
            "-            } catch (IOException ioe) {\n", 
            "-                log.error(\"Error opening Key store : \" + location, ioe);\n", 
            "-                throw new AxisFault(\"Error opening Key store : \" + location, ioe);\n", 
            "-            } finally {\n", 
            "-                if (fis != null) {\n", 
            "-                    try {\n", 
            "-                        fis.close();\n", 
            "-                    } catch (IOException ignore) {}\n", 
            "-                }\n", 
            "-            }\n", 
            "-        } else if (novalidatecert) {\n", 
            "-            log.warn(\"Server certificate validation (trust) has been disabled. \" +\n", 
            "-                    \"DO NOT USE IN PRODUCTION!\");\n", 
            "-            trustManagers = new TrustManager[] { new NoValidateCertTrustManager() };\n", 
            "-        }\n", 
            "-\n", 
            "-        try {\n", 
            "-            SSLContext sslcontext = SSLContext.getInstance(\"TLS\");\n", 
            "-            sslcontext.init(keymanagers, trustManagers, null);\n", 
            "-            return sslcontext;\n", 
            "-\n", 
            "-        } catch (GeneralSecurityException gse) {\n", 
            "-            log.error(\"Unable to create SSL context with the given configuration\", gse);\n", 
            "-            throw new AxisFault(\"Unable to create SSL context with the given configuration\", gse);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private SSLSetupHandler createSSLIOSessionHandler(final String hostnameVerifier)\n", 
            "-            throws AxisFault {\n", 
            "-\n", 
            "-        return new SSLSetupHandler() {\n", 
            "-\n", 
            "-            public void initalize(SSLEngine sslengine, HttpParams params) {\n", 
            "-            }\n", 
            "-\n", 
            "-            public void verify(IOSession ioSession, SSLSession session) throws SSLException {\n", 
            "-                SocketAddress remoteAddress = ioSession.getRemoteAddress();\n", 
            "-                String address;\n", 
            "-                if (remoteAddress instanceof InetSocketAddress) {\n", 
            "-                    address = ((InetSocketAddress) remoteAddress).getHostName();\n", 
            "-                } else {\n", 
            "-                    address = remoteAddress.toString();\n", 
            "-                }\n", 
            "-\n", 
            "-                boolean valid = false;\n", 
            "-                if (hostnameVerifier != null) {\n", 
            "-                    if (\"Strict\".equals(hostnameVerifier)) {\n", 
            "-                        valid = HostnameVerifier.STRICT.verify(address, session);\n", 
            "-                    } else if (\"AllowAll\".equals(hostnameVerifier)) {\n", 
            "-                        valid = HostnameVerifier.ALLOW_ALL.verify(address, session);\n", 
            "-                    } else if (\"DefaultAndLocalhost\".equals(hostnameVerifier)) {\n", 
            "-                        valid = HostnameVerifier.DEFAULT_AND_LOCALHOST.verify(address, session);\n", 
            "-                    }\n", 
            "-                } else {\n", 
            "-                    valid = HostnameVerifier.DEFAULT.verify(address, session);\n", 
            "-                }\n", 
            "-\n", 
            "-                if (!valid) {\n", 
            "-                    throw new SSLException(\"Host name verification failed for host : \" + address);\n", 
            "-                }\n", 
            "-            }\n", 
            "-        };\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Trust manager accepting any certificate.\n", 
            "-     */\n", 
            "-    public static class NoValidateCertTrustManager implements X509TrustManager {\n", 
            "-        public void checkClientTrusted(X509Certificate[] chain, String authType)\n", 
            "-                throws CertificateException {\n", 
            "-            // Do nothing: we accept any certificate\n", 
            "-        }\n", 
            "-\n", 
            "-        public void checkServerTrusted(X509Certificate[] chain, String authType)\n", 
            "-                throws CertificateException {\n", 
            "-            // Do nothing: we accept any certificate\n", 
            "-        }\n", 
            "-\n", 
            "-        public X509Certificate[] getAcceptedIssuers() {\n", 
            "-            return new X509Certificate[0];\n", 
            "-        }\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,188 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.http.nio.NHttpConnection;\n", 
            "-import org.apache.synapse.transport.passthru.config.TargetConfiguration;\n", 
            "-\n", 
            "-import java.nio.ByteBuffer;\n", 
            "-\n", 
            "-/**\n", 
            "- * When a connection is created, an object of this class is stored in the Connection Context.\n", 
            "- * It is used as a holder for information required during the life-cycle of this connection.\n", 
            "- */\n", 
            "-public class TargetContext {\n", 
            "-    private TargetConfiguration targetConfiguration = null;\n", 
            "-\n", 
            "-    public static final String CONNECTION_INFORMATION = \"CONNECTION_INFORMATION\";\n", 
            "-    /** The request for this connection */\n", 
            "-    private TargetRequest request;\n", 
            "-    /** The response for this connection */\n", 
            "-    private TargetResponse response;\n", 
            "-    /** State of the connection */\n", 
            "-    private ProtocolState state;\n", 
            "-    /** The request message context */\n", 
            "-    private MessageContext requestMsgCtx;\n", 
            "-    /** The current reader */\n", 
            "-    private Pipe reader;\n", 
            "-    /** The current writer */\n", 
            "-    private Pipe writer;\n", 
            "-\n", 
            "-    public TargetContext(TargetConfiguration targetConfiguration) {\n", 
            "-        this.targetConfiguration = targetConfiguration;\n", 
            "-    }\n", 
            "-\n", 
            "-    public ProtocolState getState() {\n", 
            "-        return state;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setState(ProtocolState state) {\n", 
            "-        this.state = state;\n", 
            "-    }\n", 
            "-\n", 
            "-    public TargetRequest getRequest() {\n", 
            "-        return request;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setRequest(TargetRequest request) {\n", 
            "-        this.request = request;\n", 
            "-    }\n", 
            "-\n", 
            "-    public TargetResponse getResponse() {\n", 
            "-        return response;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setResponse(TargetResponse response) {\n", 
            "-        this.response = response;\n", 
            "-    }\n", 
            "-\n", 
            "-    public MessageContext getRequestMsgCtx() {\n", 
            "-        return requestMsgCtx;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setRequestMsgCtx(MessageContext requestMsgCtx) {\n", 
            "-        this.requestMsgCtx = requestMsgCtx;\n", 
            "-    }\n", 
            "-\n", 
            "-    public Pipe getReader() {\n", 
            "-        return reader;\n", 
            "-    }\n", 
            "-\n", 
            "-    public Pipe getWriter() {\n", 
            "-        return writer;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setReader(Pipe reader) {\n", 
            "-        this.reader = reader;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setWriter(Pipe writer) {\n", 
            "-        this.writer = writer;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void reset() {\n", 
            "-        request = null;\n", 
            "-        response = null;\n", 
            "-        state = ProtocolState.REQUEST_READY;\n", 
            "-\n", 
            "-        if (writer != null) {\n", 
            "-            ByteBuffer buffer = writer.getBuffer();\n", 
            "-            buffer.clear();\n", 
            "-            targetConfiguration.getBufferFactory().release(buffer);\n", 
            "-        }\n", 
            "-\n", 
            "-        reader = null;\n", 
            "-        writer = null;       \n", 
            "-    }\n", 
            "-\n", 
            "-    public static void create(NHttpConnection conn, ProtocolState state, \n", 
            "-                              TargetConfiguration configuration) {\n", 
            "-        TargetContext info = new TargetContext(configuration);\n", 
            "-\n", 
            "-        conn.getContext().setAttribute(CONNECTION_INFORMATION, info);\n", 
            "-\n", 
            "-        info.setState(state);\n", 
            "-    }\n", 
            "-\n", 
            "-    public static void updateState(NHttpConnection conn, ProtocolState state) {\n", 
            "-        TargetContext info = (TargetContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        if (info != null) {\n", 
            "-            info.setState(state);\n", 
            "-        }  else {\n", 
            "-            throw new IllegalStateException(\"Connection information should be present\");\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public static boolean assertState(NHttpConnection conn, ProtocolState state) {\n", 
            "-        TargetContext info = (TargetContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        return info != null && info.getState() == state;\n", 
            "-\n", 
            "-    }\n", 
            "-\n", 
            "-    public static ProtocolState getState(NHttpConnection conn) {\n", 
            "-        TargetContext info = (TargetContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        return info != null ? info.getState() : null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static void setRequest(NHttpConnection conn, TargetRequest request) {\n", 
            "-        TargetContext info = (TargetContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        if (info != null) {\n", 
            "-            info.setRequest(request);\n", 
            "-        } else {\n", 
            "-            throw new IllegalStateException(\"Connection information should be present\");\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public static void setResponse(NHttpConnection conn, TargetResponse response) {\n", 
            "-        TargetContext info = (TargetContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        if (info != null) {\n", 
            "-            info.setResponse(response);\n", 
            "-        } else {\n", 
            "-            throw new IllegalStateException(\"Connection information should be present\");\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public static TargetRequest getRequest(NHttpConnection conn) {\n", 
            "-        TargetContext info = (TargetContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        return info != null ? info.getRequest() : null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static TargetResponse getResponse(NHttpConnection conn) {\n", 
            "-        TargetContext info = (TargetContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        return info != null ? info.getResponse() : null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static TargetContext get(NHttpConnection conn) {\n", 
            "-        return (TargetContext) conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-    }\n", 
            "-\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetContext.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetContext.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,50 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.http.impl.nio.reactor.SSLSetupHandler;\n", 
            "-import org.apache.http.impl.nio.ssl.SSLServerIOEventDispatch;\n", 
            "-import org.apache.http.nio.NHttpServerIOTarget;\n", 
            "-import org.apache.http.nio.NHttpServiceHandler;\n", 
            "-import org.apache.http.nio.reactor.IOSession;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-import org.apache.synapse.transport.passthru.logging.LoggingUtils;\n", 
            "-\n", 
            "-import javax.net.ssl.SSLContext;\n", 
            "-\n", 
            "-public class SSLSourceIOEventDispatch extends SSLServerIOEventDispatch {\n", 
            "-\n", 
            "-    private HttpParams params = null;\n", 
            "-\n", 
            "-    public SSLSourceIOEventDispatch(NHttpServiceHandler handler,\n", 
            "-                                    SSLContext sslcontext,\n", 
            "-                                    SSLSetupHandler sslHandler,\n", 
            "-                                    HttpParams params) {\n", 
            "-        super(handler, sslcontext, sslHandler, params);\n", 
            "-        this.params = params;\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    protected NHttpServerIOTarget createConnection(IOSession session) {\n", 
            "-        session = LoggingUtils.decorate(session, \"sslserver\");\n", 
            "-        return LoggingUtils.createServerConnection(\n", 
            "-                session,\n", 
            "-                createHttpRequestFactory(),\n", 
            "-                createByteBufferAllocator(),\n", 
            "-                this.params);\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLSourceIOEventDispatch.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLSourceIOEventDispatch.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,427 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.http.nio.IOControl;\n", 
            "-import org.apache.http.nio.ContentDecoder;\n", 
            "-import org.apache.http.nio.ContentEncoder;\n", 
            "-import org.apache.synapse.transport.passthru.config.BaseConfiguration;\n", 
            "-\n", 
            "-import java.io.*;\n", 
            "-import java.nio.ByteBuffer;\n", 
            "-import java.util.concurrent.atomic.AtomicBoolean;\n", 
            "-import java.util.concurrent.locks.Condition;\n", 
            "-import java.util.concurrent.locks.Lock;\n", 
            "-import java.util.concurrent.locks.ReentrantLock;\n", 
            "-\n", 
            "-/**\n", 
            "- * This is a buffer shared by both producers and consumers.\n", 
            "- */\n", 
            "-public class Pipe {\n", 
            "-\n", 
            "-    /** IOControl of the reader */\n", 
            "-    private IOControl producerIoControl;\n", 
            "-\n", 
            "-    /** IOControl of the consumer */\n", 
            "-    private IOControl consumerIoControl;\n", 
            "-\n", 
            "-    /** Fixed size buffer to read and write data */\n", 
            "-    private ByteBuffer buffer;\n", 
            "-\n", 
            "-    private ByteBuffer outputBuffer;\n", 
            "-\n", 
            "-    private boolean producerCompleted = false;\n", 
            "-\n", 
            "-    /** Lock to synchronize the producers and consumers */\n", 
            "-    private Lock lock = new ReentrantLock();\n", 
            "-\n", 
            "-    private Condition readCondition = lock.newCondition();\n", 
            "-    private Condition writeCondition = lock.newCondition();\n", 
            "-\n", 
            "-    /** Name to identify the buffer */\n", 
            "-    private String name = \"Buffer\";\n", 
            "-\n", 
            "-    private boolean consumerError = false;\n", 
            "-\n", 
            "-    private boolean producerError = false;\n", 
            "-\n", 
            "-    private BaseConfiguration baseConfig;\n", 
            "-\n", 
            "-    private boolean serializationComplete = false;\n", 
            "-\n", 
            "-    private boolean hasHttpProducer = true;\n", 
            "-\n", 
            "-    private AtomicBoolean inBufferInputMode = new AtomicBoolean(true);\n", 
            "-    private AtomicBoolean outBufferInputMode;\n", 
            "-\n", 
            "-    private ByteBufferInputStream inputStream;\n", 
            "-    private ByteBufferOutputStream outputStream;\n", 
            "-\n", 
            "-    public Pipe(IOControl producerIoControl, ByteBuffer buffer,\n", 
            "-                String name, BaseConfiguration baseConfig) {\n", 
            "-        this.producerIoControl = producerIoControl;\n", 
            "-        this.buffer = buffer;\n", 
            "-        this.name += \"_\" + name;\n", 
            "-        this.baseConfig = baseConfig;\n", 
            "-    }\n", 
            "-\n", 
            "-    public Pipe(ByteBuffer buffer, String name, BaseConfiguration baseConfig) {\n", 
            "-        this.buffer = buffer;\n", 
            "-        this.name += \"_\" + name;\n", 
            "-        this.baseConfig = baseConfig;\n", 
            "-        this.hasHttpProducer = false;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Set the consumers IOControl\n", 
            "-     * @param consumerIoControl IOControl of the consumer\n", 
            "-     */\n", 
            "-    public void attachConsumer(IOControl consumerIoControl) {\n", 
            "-        this.consumerIoControl = consumerIoControl;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Consume the data from the buffer. Before calling this method attachConsumer\n", 
            "-     * method must be called with a valid IOControl.\n", 
            "-     *\n", 
            "-     * @param encoder encoder used to write the data means there will not be any data\n", 
            "-     * written in to this buffer\n", 
            "-     * @return number of bytes written (consumed)\n", 
            "-     * @throws IOException if an error occurred while consuming data\n", 
            "-     */\n", 
            "-    public int consume(final ContentEncoder encoder) throws IOException {\n", 
            "-        if (consumerIoControl == null) {\n", 
            "-            throw new IllegalStateException(\"Consumer cannot be null when calling consume\");\n", 
            "-        }\n", 
            "-\n", 
            "-        if (hasHttpProducer && producerIoControl == null) {\n", 
            "-            throw new IllegalStateException(\"Producer cannot be null when calling consume\");\n", 
            "-        }\n", 
            "-\n", 
            "-        lock.lock();\n", 
            "-        ByteBuffer consumerBuffer;\n", 
            "-        AtomicBoolean inputMode;\n", 
            "-        if (outputBuffer != null) {\n", 
            "-            consumerBuffer = outputBuffer;\n", 
            "-            inputMode = outBufferInputMode;\n", 
            "-        } else {\n", 
            "-            consumerBuffer = buffer;\n", 
            "-            inputMode = inBufferInputMode;\n", 
            "-        }\n", 
            "-        try {\n", 
            "-            // if producer at error we have to stop the encoding and return immediately\n", 
            "-            if (producerError) {\n", 
            "-                encoder.complete();\n", 
            "-                return -1;\n", 
            "-            }\n", 
            "-\n", 
            "-            setOutputMode(consumerBuffer, inputMode);\n", 
            "-            int bytesWritten = encoder.write(consumerBuffer);\n", 
            "-            setInputMode(consumerBuffer, inputMode);\n", 
            "-\n", 
            "-            if (consumerBuffer.position() == 0) {\n", 
            "-                if (outputBuffer == null) {\n", 
            "-                    if (producerCompleted) {\n", 
            "-                        encoder.complete();\n", 
            "-                    } else {\n", 
            "-                        // buffer is empty. Wait until the producer fills up\n", 
            "-                        // the buffer\n", 
            "-                        consumerIoControl.suspendOutput();\n", 
            "-                    }\n", 
            "-                } else if (serializationComplete) {\n", 
            "-                    encoder.complete();\n", 
            "-                }\n", 
            "-            }\n", 
            "-\n", 
            "-            if (bytesWritten > 0) {\n", 
            "-                if (!encoder.isCompleted() && !producerCompleted && hasHttpProducer) {\n", 
            "-                    producerIoControl.requestInput();\n", 
            "-                }\n", 
            "-                writeCondition.signalAll();\n", 
            "-            }\n", 
            "-\n", 
            "-            return bytesWritten;\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Produce data in to the buffer.\n", 
            "-     *\n", 
            "-     * @param decoder decoder to read bytes from the underlying stream\n", 
            "-     * @return bytes read (consumed)\n", 
            "-     * @throws IOException if an error occurs while reading data\n", 
            "-     */\n", 
            "-    public int produce(final ContentDecoder decoder) throws IOException {\n", 
            "-        if (producerIoControl == null) {\n", 
            "-            throw new IllegalStateException(\"Producer cannot be null when calling produce\");\n", 
            "-        }\n", 
            "-\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            setInputMode(buffer, inBufferInputMode);\n", 
            "-            int bytesRead = decoder.read(buffer);\n", 
            "-\n", 
            "-            // if consumer is at error we have to let the producer complete\n", 
            "-            if (consumerError) {\n", 
            "-                buffer.clear();\n", 
            "-            }\n", 
            "-\n", 
            "-            if (!buffer.hasRemaining()) {\n", 
            "-                // Input buffer is full. Suspend client input\n", 
            "-                // until the origin handler frees up some space in the buffer\n", 
            "-                producerIoControl.suspendInput();\n", 
            "-            }\n", 
            "-\n", 
            "-            // If there is some content in the input buffer make sure consumer output is active\n", 
            "-            if (buffer.position() > 0 || decoder.isCompleted()) {\n", 
            "-                if (consumerIoControl != null) {\n", 
            "-                    consumerIoControl.requestOutput();\n", 
            "-                }\n", 
            "-                readCondition.signalAll();\n", 
            "-            }\n", 
            "-\n", 
            "-            if (decoder.isCompleted()) {\n", 
            "-                producerCompleted = true;\n", 
            "-            }\n", 
            "-            return bytesRead;\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public String toString() {\n", 
            "-        return name;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void consumerError() {\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            this.consumerError = true;\n", 
            "-            writeCondition.signalAll();\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void producerError() {\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            this.producerError = true;\n", 
            "-            readCondition.signalAll();\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Creates an InputStream object on the underlying ByteBuffer. The returned\n", 
            "-     * InputStream can be used to read bytes from the underlying buffer which\n", 
            "-     * is being filled by the producer.\n", 
            "-     *\n", 
            "-     * @return An InputStream object\n", 
            "-     */\n", 
            "-    public synchronized InputStream getInputStream() {\n", 
            "-        if (inputStream == null) {\n", 
            "-            inputStream = new ByteBufferInputStream();\n", 
            "-        }\n", 
            "-        return inputStream;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Creates a separate ByteBuffer for the output data and returns an OutputStream\n", 
            "-     * on top of it.\n", 
            "-     *\n", 
            "-     * @return An OutputStream object\n", 
            "-     */\n", 
            "-    public synchronized OutputStream getOutputStream() {\n", 
            "-        if (outputStream == null) {\n", 
            "-            outputBuffer = baseConfig.getBufferFactory().getBuffer();\n", 
            "-            outBufferInputMode = new AtomicBoolean(true);\n", 
            "-            outputStream = new ByteBufferOutputStream();\n", 
            "-        }\n", 
            "-        return outputStream;\n", 
            "-    }\n", 
            "-\n", 
            "-    public synchronized void setSerializationComplete(boolean serializationComplete) {\n", 
            "-        if (!this.serializationComplete) {\n", 
            "-            this.serializationComplete = serializationComplete;\n", 
            "-            if (hasData(outputBuffer, outBufferInputMode)) {\n", 
            "-                consumerIoControl.requestOutput();\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public ByteBuffer getBuffer() {\n", 
            "-        return buffer;\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean hasHttpProducer() {\n", 
            "-        return hasHttpProducer;\n", 
            "-    }\n", 
            "-\n", 
            "-    private void setInputMode(ByteBuffer buffer, AtomicBoolean inputMode) {\n", 
            "-        if (inputMode.compareAndSet(false, true)) {\n", 
            "-            if (buffer.hasRemaining()) {\n", 
            "-                buffer.compact();\n", 
            "-            } else {\n", 
            "-                buffer.clear();\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private void setOutputMode(ByteBuffer buffer, AtomicBoolean inputMode) {\n", 
            "-        if (inputMode.compareAndSet(true, false)) {\n", 
            "-            buffer.flip();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private boolean hasData(ByteBuffer buffer, AtomicBoolean inputMode) {\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            setOutputMode(buffer, inputMode);\n", 
            "-            return buffer.hasRemaining();\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private class ByteBufferInputStream extends InputStream {\n", 
            "-\n", 
            "-        @Override\n", 
            "-        public int read() throws IOException {\n", 
            "-            lock.lock();\n", 
            "-            try {\n", 
            "-                if (!hasData(buffer, inBufferInputMode)) {\n", 
            "-                    waitForData();\n", 
            "-                }\n", 
            "-                if (isEndOfStream()) {\n", 
            "-                    return -1;\n", 
            "-                }\n", 
            "-                return buffer.get() & 0xff;\n", 
            "-            } finally {\n", 
            "-                lock.unlock();\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        public int read(byte[] b, int off, int len) throws IOException {\n", 
            "-            if (b == null) {\n", 
            "-                return 0;\n", 
            "-            }\n", 
            "-\n", 
            "-            lock.lock();\n", 
            "-            try {\n", 
            "-                if (!hasData(buffer, inBufferInputMode)) {\n", 
            "-                    waitForData();\n", 
            "-                }\n", 
            "-                if (isEndOfStream()) {\n", 
            "-                    return -1;\n", 
            "-                }\n", 
            "-                setOutputMode(buffer, inBufferInputMode);\n", 
            "-                int chunk = len;\n", 
            "-                if (chunk > buffer.remaining()) {\n", 
            "-                    chunk = buffer.remaining();\n", 
            "-                }\n", 
            "-                buffer.get(b, off, chunk);\n", 
            "-                return chunk;\n", 
            "-            } finally {\n", 
            "-                lock.unlock();\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        private void waitForData() throws IOException {\n", 
            "-            lock.lock();\n", 
            "-            try {\n", 
            "-                try {\n", 
            "-                    while (!hasData(buffer, inBufferInputMode) && !producerCompleted) {\n", 
            "-                        producerIoControl.requestInput();\n", 
            "-                        readCondition.await();\n", 
            "-                    }\n", 
            "-                } catch (InterruptedException e) {\n", 
            "-                    throw new IOException(\"Interrupted while waiting for data\");\n", 
            "-                }\n", 
            "-            } finally {\n", 
            "-                lock.unlock();\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        private boolean isEndOfStream() {\n", 
            "-            return !hasData(buffer, inBufferInputMode) && producerCompleted;\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private class ByteBufferOutputStream extends OutputStream {\n", 
            "-\n", 
            "-        @Override\n", 
            "-        public void write(int b) throws IOException {\n", 
            "-            lock.lock();\n", 
            "-            try {\n", 
            "-                setInputMode(outputBuffer, outBufferInputMode);\n", 
            "-                if (!outputBuffer.hasRemaining()) {\n", 
            "-                    flushContent();\n", 
            "-                    setInputMode(outputBuffer, outBufferInputMode);\n", 
            "-                }\n", 
            "-                outputBuffer.put((byte) b);\n", 
            "-            } finally {\n", 
            "-                lock.unlock();\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        public void write(final byte[] b, int off, int len) throws IOException {\n", 
            "-            if (b == null) {\n", 
            "-                return;\n", 
            "-            }\n", 
            "-            lock.lock();\n", 
            "-            try {\n", 
            "-                setInputMode(outputBuffer, outBufferInputMode);\n", 
            "-                int remaining = len;\n", 
            "-                while (remaining > 0) {\n", 
            "-                    if (!outputBuffer.hasRemaining()) {\n", 
            "-                        flushContent();\n", 
            "-                        setInputMode(outputBuffer, outBufferInputMode);\n", 
            "-                    }\n", 
            "-                    int chunk = Math.min(remaining, outputBuffer.remaining());\n", 
            "-                    outputBuffer.put(b, off, chunk);\n", 
            "-                    remaining -= chunk;\n", 
            "-                    off += chunk;\n", 
            "-                }\n", 
            "-            } finally {\n", 
            "-                lock.unlock();\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        private void flushContent() throws IOException {\n", 
            "-            lock.lock();\n", 
            "-            try {\n", 
            "-                try {\n", 
            "-                    while (hasData(outputBuffer, outBufferInputMode)) {\n", 
            "-                        consumerIoControl.requestOutput();\n", 
            "-                        writeCondition.await();\n", 
            "-                    }\n", 
            "-                } catch (InterruptedException ex) {\n", 
            "-                    throw new IOException(\"Interrupted while flushing the content buffer\");\n", 
            "-                }\n", 
            "-            } finally {\n", 
            "-                lock.unlock();\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-}\n", 
            "-\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/Pipe.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/Pipe.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,81 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.util;\n", 
            "-\n", 
            "-import org.apache.http.nio.util.ByteBufferAllocator;\n", 
            "-import org.apache.http.nio.util.HeapByteBufferAllocator;\n", 
            "-\n", 
            "-import java.nio.ByteBuffer;\n", 
            "-import java.util.concurrent.locks.Lock;\n", 
            "-import java.util.concurrent.locks.ReentrantLock;\n", 
            "-\n", 
            "-public class BufferFactory {\n", 
            "-\n", 
            "-    private volatile ByteBuffer [] buffers;\n", 
            "-\n", 
            "-    private volatile int marker = -1;\n", 
            "-\n", 
            "-    private ByteBufferAllocator allocator = null;\n", 
            "-\n", 
            "-    private Lock lock = new ReentrantLock();\n", 
            "-\n", 
            "-    private int bufferSize = 1024 * 8;\n", 
            "-\n", 
            "-    public BufferFactory(int bufferSize, ByteBufferAllocator allocator, int size) {\n", 
            "-        this.bufferSize = bufferSize;\n", 
            "-        if (allocator != null) {\n", 
            "-            this.allocator = allocator;\n", 
            "-        } else {\n", 
            "-            this.allocator = new HeapByteBufferAllocator();\n", 
            "-        }\n", 
            "-\n", 
            "-        buffers = new ByteBuffer[size];\n", 
            "-    }\n", 
            "-\n", 
            "-    public ByteBuffer getBuffer() {\n", 
            "-        if (marker == -1) {\n", 
            "-            //System.out.println(\"allocating marker -1\");\n", 
            "-            return allocator.allocate(bufferSize);\n", 
            "-        } else {\n", 
            "-            lock.lock();\n", 
            "-            try {\n", 
            "-                if (marker >= 0) {\n", 
            "-                    // System.out.println(\"Returning buffer\");\n", 
            "-                    ByteBuffer b = buffers[marker];\n", 
            "-                    buffers[marker] = null;\n", 
            "-                    marker--;\n", 
            "-                    return b;\n", 
            "-                }\n", 
            "-            } finally {\n", 
            "-                lock.unlock();\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        return allocator.allocate(bufferSize);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void release(ByteBuffer buffer) {\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            if (marker < buffers.length - 1) {\n", 
            "-                buffers[++marker] = buffer;\n", 
            "-            }\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BufferFactory.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BufferFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,314 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.util;\n", 
            "-\n", 
            "-import org.apache.axiom.om.OMOutputFormat;\n", 
            "-import org.apache.axis2.addressing.EndpointReference;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.context.ConfigurationContext;\n", 
            "-import org.apache.axis2.Constants;\n", 
            "-import org.apache.axis2.transport.TransportUtils;\n", 
            "-import org.apache.axis2.util.JavaUtils;\n", 
            "-import org.apache.axis2.description.AxisService;\n", 
            "-import org.apache.axis2.description.Parameter;\n", 
            "-import org.apache.axis2.description.AxisOperation;\n", 
            "-import org.apache.http.protocol.HTTP;\n", 
            "-import org.apache.http.HttpStatus;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            "-import org.apache.synapse.transport.passthru.PassThroughConstants;\n", 
            "-\n", 
            "-import java.net.InetAddress;\n", 
            "-import java.net.SocketException;\n", 
            "-import java.net.NetworkInterface;\n", 
            "-import java.util.Map;\n", 
            "-import java.util.Iterator;\n", 
            "-import java.util.Enumeration;\n", 
            "-import java.util.Hashtable;\n", 
            "-\n", 
            "-/**\n", 
            "- * Utility methods used by the transport.\n", 
            "- */\n", 
            "-public class PassThroughTransportUtils {\n", 
            "-    private static Log log = LogFactory.getLog(PassThroughTransportUtils.class);\n", 
            "-\n", 
            "-    /**\n", 
            "-     * This method tries to determine the hostname of the given InetAddress without\n", 
            "-     * triggering a reverse DNS lookup.  {@link java.net.InetAddress#getHostName()}\n", 
            "-     * triggers a reverse DNS lookup which can be very costly in cases where reverse\n", 
            "-     * DNS fails. Tries to parse a symbolic hostname from {@link java.net.InetAddress#toString()},\n", 
            "-     * which is documented to return a String of the form \"hostname / literal IP address\"\n", 
            "-     * with 'hostname' blank if not already computed & stored in <code>address</code>.\n", 
            "-     * <p/>\n", 
            "-     * If the hostname cannot be determined from InetAddress.toString(),\n", 
            "-     * the value of {@link java.net.InetAddress#getHostAddress()} is returned.\n", 
            "-     *\n", 
            "-     * @param address The InetAddress whose hostname has to be determined\n", 
            "-     * @return hostsname, if it can be determined. hostaddress, if not.          \n", 
            "-     */\n", 
            "-    public static String getHostName(InetAddress address) {\n", 
            "-        String result;\n", 
            "-        String hostAddress = address.getHostAddress();\n", 
            "-        String inetAddr = address.toString();\n", 
            "-        int index1 = inetAddr.lastIndexOf('/');\n", 
            "-        int index2 = inetAddr.indexOf(hostAddress);\n", 
            "-        if (index2 == index1 + 1) {\n", 
            "-            if (index1 == 0) {\n", 
            "-                result = hostAddress;\n", 
            "-            } else {\n", 
            "-                result = inetAddr.substring(0, index1);\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            result = hostAddress;\n", 
            "-        }\n", 
            "-        return result;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Get the EPR for the message passed in\n", 
            "-     * @param msgContext the message context\n", 
            "-     * @return the destination EPR\n", 
            "-     */\n", 
            "-    public static EndpointReference getDestinationEPR(MessageContext msgContext) {\n", 
            "-\n", 
            "-        // Trasnport URL can be different from the WSA-To\n", 
            "-        String transportURL = (String) msgContext.getProperty(\n", 
            "-            Constants.Configuration.TRANSPORT_URL);\n", 
            "-\n", 
            "-        if (transportURL != null) {\n", 
            "-            return new EndpointReference(transportURL);\n", 
            "-        } else if (\n", 
            "-            (msgContext.getTo() != null) && !msgContext.getTo().hasAnonymousAddress()) {\n", 
            "-            return msgContext.getTo();\n", 
            "-        }\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Remove unwanted headers from the http response of outgoing request. These are headers which\n", 
            "-     * should be dictated by the transport and not the user. We remove these as these may get\n", 
            "-     * copied from the request messages\n", 
            "-     * \n", 
            "-     * @param msgContext the Axis2 Message context from which these headers should be removed\n", 
            "-     * @param preserveServerHeader if true preserve the original server header\n", 
            "-     * @param preserveUserAgentHeader if true preserve the original user-agent header\n", 
            "-     */\n", 
            "-    public static void removeUnwantedHeaders(MessageContext msgContext,\n", 
            "-                                             boolean preserveServerHeader,\n", 
            "-                                             boolean preserveUserAgentHeader) {\n", 
            "-        Map headers = (Map) msgContext.getProperty(MessageContext.TRANSPORT_HEADERS);\n", 
            "-\n", 
            "-        if (headers == null || headers.isEmpty()) {\n", 
            "-            return;\n", 
            "-        }\n", 
            "-\n", 
            "-        Iterator iter = headers.keySet().iterator();\n", 
            "-        while (iter.hasNext()) {\n", 
            "-            String headerName = (String) iter.next();\n", 
            "-            if (HTTP.CONN_DIRECTIVE.equalsIgnoreCase(headerName) ||\n", 
            "-                HTTP.TRANSFER_ENCODING.equalsIgnoreCase(headerName) ||\n", 
            "-                HTTP.DATE_HEADER.equalsIgnoreCase(headerName) ||\n", 
            "-                HTTP.CONTENT_LEN.equalsIgnoreCase(headerName) ||\n", 
            "-                HTTP.CONN_KEEP_ALIVE.equalsIgnoreCase(headerName)) {\n", 
            "-                iter.remove();\n", 
            "-            }\n", 
            "-\n", 
            "-            if (!preserveServerHeader && HTTP.SERVER_HEADER.equalsIgnoreCase(headerName)) {\n", 
            "-                iter.remove();\n", 
            "-            }\n", 
            "-\n", 
            "-            if (!preserveUserAgentHeader && HTTP.USER_AGENT.equalsIgnoreCase(headerName)) {\n", 
            "-                iter.remove();\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Determine the Http Status Code depending on the message type processed <br>\n", 
            "-     * (normal response versus fault response) as well as Axis2 message context properties set\n", 
            "-     * via Synapse configuration or MessageBuilders.\n", 
            "-     *\n", 
            "-     * @see PassThroughConstants#FAULTS_AS_HTTP_200\n", 
            "-     * @see PassThroughConstants#HTTP_SC\n", 
            "-     *\n", 
            "-     * @param msgContext the Axis2 message context\n", 
            "-     *\n", 
            "-     * @return the HTTP status code to set in the HTTP response object\n", 
            "-     */\n", 
            "-    public static int determineHttpStatusCode(MessageContext msgContext) {\n", 
            "-\n", 
            "-        int httpStatus = HttpStatus.SC_OK;\n", 
            "-\n", 
            "-        // if this is a dummy message to handle http 202 case with non-blocking IO\n", 
            "-        // set the status code to 202\n", 
            "-        if (msgContext.isPropertyTrue(PassThroughConstants.SC_ACCEPTED)) {\n", 
            "-            httpStatus = HttpStatus.SC_ACCEPTED;\n", 
            "-        } else {\n", 
            "-            // is this a fault message\n", 
            "-            boolean handleFault =\n", 
            "-                msgContext.getEnvelope().getBody().hasFault() || msgContext.isProcessingFault();\n", 
            "-\n", 
            "-            // shall faults be transmitted with HTTP 200\n", 
            "-            boolean faultsAsHttp200 =\n", 
            "-                PassThroughConstants.TRUE.equals(\n", 
            "-                    msgContext.getProperty(PassThroughConstants.FAULTS_AS_HTTP_200));\n", 
            "-\n", 
            "-            // Set HTTP status code to 500 if this is a fault case and we shall not use HTTP 200\n", 
            "-            if (handleFault && !faultsAsHttp200) {\n", 
            "-                httpStatus = HttpStatus.SC_INTERNAL_SERVER_ERROR;\n", 
            "-            }\n", 
            "-\n", 
            "-            // Any status code previously set shall be overwritten with the value of the following\n", 
            "-            // message context property if it is set.\n", 
            "-            Object statusCode = msgContext.getProperty(PassThroughConstants.HTTP_SC);\n", 
            "-            if (statusCode != null) {\n", 
            "-                try {\n", 
            "-                    httpStatus = Integer.parseInt(\n", 
            "-                            msgContext.getProperty(PassThroughConstants.HTTP_SC).toString());\n", 
            "-                } catch (NumberFormatException e) {\n", 
            "-                    log.warn(\"Unable to set the HTTP status code from the property \"\n", 
            "-                            + PassThroughConstants.HTTP_SC + \" with value: \" + statusCode);\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        return httpStatus;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Whatever this method returns as the IP is ignored by the actual http/s listener when\n", 
            "-     * its getServiceEPR is invoked. This was originally copied from axis2\n", 
            "-     *\n", 
            "-     * @return Returns String.\n", 
            "-     * @throws java.net.SocketException if the socket can not be accessed\n", 
            "-     */\n", 
            "-    public static String getIpAddress() throws SocketException {\n", 
            "-        Enumeration e = NetworkInterface.getNetworkInterfaces();\n", 
            "-        String address = \"127.0.0.1\";\n", 
            "-\n", 
            "-        while (e.hasMoreElements()) {\n", 
            "-            NetworkInterface netface = (NetworkInterface) e.nextElement();\n", 
            "-            Enumeration addresses = netface.getInetAddresses();\n", 
            "-\n", 
            "-            while (addresses.hasMoreElements()) {\n", 
            "-                InetAddress ip = (InetAddress) addresses.nextElement();\n", 
            "-                if (!ip.isLoopbackAddress() && isIP(ip.getHostAddress())) {\n", 
            "-                    return ip.getHostAddress();\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return address;\n", 
            "-    }\n", 
            "-\n", 
            "-    private static boolean isIP(String hostAddress) {\n", 
            "-        return hostAddress.split(\"[.]\").length == 4;\n", 
            "-    }\n", 
            "-\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Returns the HTML text for the list of services deployed.\n", 
            "-     * This can be delegated to another Class as well\n", 
            "-     * where it will handle more options of GET messages.\n", 
            "-     *\n", 
            "-     * @param prefix to be used for the Service names\n", 
            "-     * @param cfgCtx axis2 configuration context\n", 
            "-     * @return the HTML to be displayed as a String\n", 
            "-     */\n", 
            "-    public String getServicesHTML(String prefix, ConfigurationContext cfgCtx) {\n", 
            "-\n", 
            "-        Map services = cfgCtx.getAxisConfiguration().getServices();\n", 
            "-        Hashtable erroneousServices = cfgCtx.getAxisConfiguration().getFaultyServices();\n", 
            "-        boolean servicesFound = false;\n", 
            "-\n", 
            "-        StringBuffer resultBuf = new StringBuffer();\n", 
            "-        resultBuf.append(\"<html><head><title>Axis2: Services</title></head>\" + \"<body>\");\n", 
            "-\n", 
            "-        if ((services != null) && !services.isEmpty()) {\n", 
            "-\n", 
            "-            servicesFound = true;\n", 
            "-            resultBuf.append(\"<h2>\" + \"Deployed services\" + \"</h2>\");\n", 
            "-\n", 
            "-            for (Object service : services.values()) {\n", 
            "-\n", 
            "-                AxisService axisService = (AxisService) service;\n", 
            "-                Parameter parameter = axisService.getParameter(\n", 
            "-                        PassThroughConstants.HIDDEN_SERVICE_PARAM_NAME);\n", 
            "-                if (axisService.getName().startsWith(\"__\") ||\n", 
            "-                        (parameter != null && JavaUtils.isTrueExplicitly(parameter.getValue()))) {\n", 
            "-                    continue;    // skip private services\n", 
            "-                }\n", 
            "-\n", 
            "-                Iterator iterator = axisService.getOperations();\n", 
            "-                resultBuf.append(\"<h3><a href=\\\"\").append(prefix).append(axisService.getName()).append(\n", 
            "-                        \"?wsdl\\\">\").append(axisService.getName()).append(\"</a></h3>\");\n", 
            "-\n", 
            "-                if (iterator.hasNext()) {\n", 
            "-                    resultBuf.append(\"Available operations <ul>\");\n", 
            "-\n", 
            "-                    for (; iterator.hasNext();) {\n", 
            "-                        AxisOperation axisOperation = (AxisOperation) iterator.next();\n", 
            "-                        resultBuf.append(\"<li>\").append(\n", 
            "-                                axisOperation.getName().getLocalPart()).append(\"</li>\");\n", 
            "-                    }\n", 
            "-                    resultBuf.append(\"</ul>\");\n", 
            "-                } else {\n", 
            "-                    resultBuf.append(\"No operations specified for this service\");\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        if ((erroneousServices != null) && !erroneousServices.isEmpty()) {\n", 
            "-            servicesFound = true;\n", 
            "-            resultBuf.append(\"<hr><h2><font color=\\\"blue\\\">Faulty Services</font></h2>\");\n", 
            "-            Enumeration faultyservices = erroneousServices.keys();\n", 
            "-\n", 
            "-            while (faultyservices.hasMoreElements()) {\n", 
            "-                String faultyserviceName = (String) faultyservices.nextElement();\n", 
            "-                resultBuf.append(\"<h3><font color=\\\"blue\\\">\").append(\n", 
            "-                        faultyserviceName).append(\"</font></h3>\");\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        if (!servicesFound) {\n", 
            "-            resultBuf.append(\"<h2>There are no services deployed</h2>\");\n", 
            "-        }\n", 
            "-\n", 
            "-        resultBuf.append(\"</body></html>\");\n", 
            "-        return resultBuf.toString();\n", 
            "-    }\n", 
            "-\n", 
            "-    public static OMOutputFormat getOMOutputFormat(MessageContext msgContext) {\n", 
            "-\n", 
            "-        OMOutputFormat format = new OMOutputFormat();\n", 
            "-        msgContext.setDoingMTOM(TransportUtils.doWriteMTOM(msgContext));\n", 
            "-        msgContext.setDoingSwA(TransportUtils.doWriteSwA(msgContext));\n", 
            "-        msgContext.setDoingREST(TransportUtils.isDoingREST(msgContext));\n", 
            "-        format.setSOAP11(msgContext.isSOAP11());\n", 
            "-        format.setDoOptimize(msgContext.isDoingMTOM());\n", 
            "-        format.setDoingSWA(msgContext.isDoingSwA());\n", 
            "-\n", 
            "-        format.setCharSetEncoding(TransportUtils.getCharSetEncoding(msgContext));\n", 
            "-        Object mimeBoundaryProperty = msgContext.getProperty(Constants.Configuration.MIME_BOUNDARY);\n", 
            "-        if (mimeBoundaryProperty != null) {\n", 
            "-            format.setMimeBoundary((String) mimeBoundaryProperty);\n", 
            "-        }\n", 
            "-\n", 
            "-        return format;\n", 
            "-    }\n", 
            "-\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/PassThroughTransportUtils.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/PassThroughTransportUtils.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,54 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.util;\n", 
            "-\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.synapse.transport.passthru.SourceRequest;\n", 
            "-import org.apache.synapse.transport.passthru.SourceResponse;\n", 
            "-import org.apache.synapse.transport.passthru.config.SourceConfiguration;\n", 
            "-\n", 
            "-import java.util.Map;\n", 
            "-import java.util.Set;\n", 
            "-\n", 
            "-public class SourceResponseFactory {\n", 
            "-\n", 
            "-    public static SourceResponse create(MessageContext msgContext,\n", 
            "-                                        SourceRequest sourceRequest,\n", 
            "-                                        SourceConfiguration sourceConfiguration) {\n", 
            "-        // determine the status code to be sent\n", 
            "-        int statusCode = PassThroughTransportUtils.determineHttpStatusCode(msgContext);\n", 
            "-\n", 
            "-        SourceResponse sourceResponse =\n", 
            "-                new SourceResponse(sourceConfiguration, statusCode, sourceRequest);\n", 
            "-\n", 
            "-        // set any transport headers\n", 
            "-        Map transportHeaders = (Map) msgContext.getProperty(MessageContext.TRANSPORT_HEADERS);\n", 
            "-\n", 
            "-        if (transportHeaders != null) {\n", 
            "-            for (Object entryObj : transportHeaders.entrySet()) {\n", 
            "-                Map.Entry entry = (Map.Entry) entryObj;\n", 
            "-                if (entry.getValue() != null && entry.getKey() instanceof String &&\n", 
            "-                        entry.getValue() instanceof String) {\n", 
            "-                    sourceResponse.addHeader((String) entry.getKey(), (String) entry.getValue());\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        return sourceResponse;\n", 
            "-    }\n", 
            "-    \n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/SourceResponseFactory.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/SourceResponseFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,150 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.util;\n", 
            "-\n", 
            "-import org.apache.axiom.om.OMOutputFormat;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.Constants;\n", 
            "-import org.apache.axis2.util.MessageProcessorSelector;\n", 
            "-import org.apache.axis2.addressing.EndpointReference;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.transport.MessageFormatter;\n", 
            "-import org.apache.axis2.transport.TransportUtils;\n", 
            "-import org.apache.axis2.transport.http.HTTPConstants;\n", 
            "-import org.apache.axis2.transport.http.SOAPMessageFormatter;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.HttpVersion;\n", 
            "-import org.apache.http.protocol.HTTP;\n", 
            "-import org.apache.synapse.transport.passthru.PassThroughConstants;\n", 
            "-import org.apache.synapse.transport.passthru.TargetRequest;\n", 
            "-import org.apache.synapse.transport.passthru.config.TargetConfiguration;\n", 
            "-\n", 
            "-import java.net.MalformedURLException;\n", 
            "-import java.net.URL;\n", 
            "-import java.util.Map;\n", 
            "-\n", 
            "-public class TargetRequestFactory {\n", 
            "-    private static Log log = LogFactory.getLog(TargetRequestFactory.class);\n", 
            "-\n", 
            "-    public static TargetRequest create(MessageContext msgContext,\n", 
            "-                                       TargetConfiguration configuration) throws AxisFault {\n", 
            "-        try {\n", 
            "-            String httpMethod = (String) msgContext.getProperty(\n", 
            "-                    Constants.Configuration.HTTP_METHOD);\n", 
            "-            if (httpMethod == null) {\n", 
            "-                httpMethod = \"POST\";\n", 
            "-            }\n", 
            "-\n", 
            "-            // basic request\n", 
            "-            Boolean noEntityBody = (Boolean) msgContext.getProperty(PassThroughConstants.NO_ENTITY_BODY);\n", 
            "-\n", 
            "-            EndpointReference epr = PassThroughTransportUtils.getDestinationEPR(msgContext);\n", 
            "-            URL url = new URL(epr.getAddress());\n", 
            "-            TargetRequest request = new TargetRequest(configuration, url, httpMethod,\n", 
            "-                    noEntityBody == null || !noEntityBody);\n", 
            "-\n", 
            "-            // headers\n", 
            "-            PassThroughTransportUtils.removeUnwantedHeaders(msgContext,\n", 
            "-                    configuration.isPreserveServerHeader(),\n", 
            "-                    configuration.isPreserveUserAgentHeader());\n", 
            "-\n", 
            "-\n", 
            "-            Object o = msgContext.getProperty(MessageContext.TRANSPORT_HEADERS);\n", 
            "-            if (o != null && o instanceof Map) {\n", 
            "-                Map headers = (Map) o;\n", 
            "-\n", 
            "-                for (Object entryObj : headers.entrySet()) {\n", 
            "-                    Map.Entry entry = (Map.Entry) entryObj;\n", 
            "-                    if (entry.getValue() != null && entry.getKey() instanceof String &&\n", 
            "-                            entry.getValue() instanceof String) {\n", 
            "-                        if (!HTTPConstants.HEADER_HOST.equalsIgnoreCase((String) entry.getKey())) {\n", 
            "-                            request.addHeader((String) entry.getKey(), (String) entry.getValue());\n", 
            "-                        }\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            }\n", 
            "-\n", 
            "-            String cType = getContentType(msgContext);\n", 
            "-            if (cType != null) {\n", 
            "-                request.addHeader(HTTP.CONTENT_TYPE, cType);\n", 
            "-            }\n", 
            "-\n", 
            "-            // version\n", 
            "-            String forceHttp10 = (String) msgContext.getProperty(PassThroughConstants.FORCE_HTTP_1_0);\n", 
            "-            if (\"true\".equals(forceHttp10)) {\n", 
            "-                request.setVersion(HttpVersion.HTTP_1_0);\n", 
            "-            }\n", 
            "-\n", 
            "-            // keep alive\n", 
            "-            String noKeepAlie = (String) msgContext.getProperty(PassThroughConstants.NO_KEEPALIVE);\n", 
            "-            if (\"true\".equals(noKeepAlie)) {\n", 
            "-                request.setKeepAlive(false);\n", 
            "-            }\n", 
            "-\n", 
            "-            // port\n", 
            "-            int port = url.getPort();\n", 
            "-            request.setPort(port != -1 ? port : 80);\n", 
            "-\n", 
            "-            // chunk\n", 
            "-            String disableChunking = (String) msgContext.getProperty(\n", 
            "-                    PassThroughConstants.DISABLE_CHUNKING);\n", 
            "-            if (\"true\".equals(disableChunking)) {\n", 
            "-                request.setChunk(false);\n", 
            "-            }\n", 
            "-\n", 
            "-            // full url\n", 
            "-            String fullUrl = (String) msgContext.getProperty(PassThroughConstants.FULL_URI);\n", 
            "-            if (\"true\".equals(fullUrl)) {\n", 
            "-                request.setFullUrl(true);                \n", 
            "-            }\n", 
            "-\n", 
            "-            return request;\n", 
            "-        } catch (MalformedURLException e) {\n", 
            "-            handleException(\"Invalid to address\" + msgContext.getTo().getAddress(), e);\n", 
            "-        }\n", 
            "-\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    private static String getContentType(MessageContext msgCtx) throws AxisFault {\n", 
            "-        MessageFormatter formatter = MessageProcessorSelector.getMessageFormatter(msgCtx);\n", 
            "-        OMOutputFormat format = PassThroughTransportUtils.getOMOutputFormat(msgCtx);\n", 
            "-        if (formatter != null) {\n", 
            "-            return formatter.getContentType(msgCtx, format, msgCtx.getSoapAction());\n", 
            "-        } else {\n", 
            "-            String contentType = (String) msgCtx.getProperty(Constants.Configuration.CONTENT_TYPE);\n", 
            "-            if (contentType != null) {\n", 
            "-                return contentType;\n", 
            "-            } else {\n", 
            "-                return new SOAPMessageFormatter().getContentType(\n", 
            "-                        msgCtx, format,  msgCtx.getSoapAction());\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Throws an AxisFault if an error occurs at this level\n", 
            "-     * @param s a message describing the error\n", 
            "-     * @param e original exception leads to the error condition\n", 
            "-     * @throws org.apache.axis2.AxisFault wrapping the original exception\n", 
            "-     */\n", 
            "-    private static void handleException(String s, Exception e) throws AxisFault {\n", 
            "-        log.error(s, e);\n", 
            "-        throw new AxisFault(s, e);\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/TargetRequestFactory.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/TargetRequestFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,355 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.http.nio.*;\n", 
            "-import org.apache.http.*;\n", 
            "-import org.apache.http.protocol.*;\n", 
            "-import org.apache.http.params.DefaultedHttpParams;\n", 
            "-import org.apache.http.message.BasicHttpResponse;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.synapse.transport.passthru.config.SourceConfiguration;\n", 
            "-import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-\n", 
            "-/**\n", 
            "- * This is the class where transport interacts with the client. This class\n", 
            "- * receives events for a particular connection. These events give information\n", 
            "- * about the message and its various states.\n", 
            "- */\n", 
            "-public class SourceHandler implements NHttpServiceHandler {\n", 
            "-    private static Log log = LogFactory.getLog(SourceHandler.class);\n", 
            "-\n", 
            "-    private final SourceConfiguration sourceConfiguration;\n", 
            "-\n", 
            "-    private PassThroughTransportMetricsCollector metrics = null;\n", 
            "-\n", 
            "-    public SourceHandler(SourceConfiguration sourceConfiguration) {\n", 
            "-        this.sourceConfiguration = sourceConfiguration;\n", 
            "-        this.metrics = sourceConfiguration.getMetrics();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void connected(NHttpServerConnection conn) {\n", 
            "-        // we have to have these two operations in order\n", 
            "-        sourceConfiguration.getSourceConnections().addConnection(conn);\n", 
            "-        SourceContext.create(conn, ProtocolState.REQUEST_READY, sourceConfiguration);\n", 
            "-\n", 
            "-        metrics.connected();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void requestReceived(NHttpServerConnection conn) {\n", 
            "-        try {\n", 
            "-            if (!SourceContext.assertState(conn, ProtocolState.REQUEST_READY)) {\n", 
            "-                handleInvalidState(conn, \"Request received\");\n", 
            "-                return;\n", 
            "-            }\n", 
            "-            // we have received a message over this connection. So we must inform the pool\n", 
            "-            sourceConfiguration.getSourceConnections().useConnection(conn);\n", 
            "-\n", 
            "-            // at this point we have read the HTTP Headers\n", 
            "-            SourceContext.updateState(conn, ProtocolState.REQUEST_HEAD);\n", 
            "-\n", 
            "-            SourceRequest request = new SourceRequest(\n", 
            "-                    sourceConfiguration, conn.getHttpRequest(), conn);\n", 
            "-\n", 
            "-            SourceContext.setRequest(conn, request);\n", 
            "-\n", 
            "-            request.start(conn);\n", 
            "-\n", 
            "-            metrics.incrementMessagesReceived();\n", 
            "-\n", 
            "-            sourceConfiguration.getWorkerPool().execute(\n", 
            "-                    new ServerWorker(request, sourceConfiguration));\n", 
            "-        } catch (HttpException e) {\n", 
            "-            log.error(e.getMessage(), e);\n", 
            "-\n", 
            "-            informReaderError(conn);\n", 
            "-\n", 
            "-            SourceContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-        } catch (IOException e) {\n", 
            "-            logIOException(e);\n", 
            "-\n", 
            "-            informReaderError(conn);\n", 
            "-\n", 
            "-            SourceContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void inputReady(NHttpServerConnection conn,\n", 
            "-                           ContentDecoder decoder) {\n", 
            "-        try {\n", 
            "-            ProtocolState protocolState = SourceContext.getState(conn);\n", 
            "-\n", 
            "-            if (protocolState != ProtocolState.REQUEST_HEAD\n", 
            "-                    && protocolState != ProtocolState.REQUEST_BODY) {\n", 
            "-                handleInvalidState(conn, \"Request message body data received\");\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            SourceContext.updateState(conn, ProtocolState.REQUEST_BODY);\n", 
            "-\n", 
            "-            SourceRequest request = SourceContext.getRequest(conn);\n", 
            "-\n", 
            "-            int readBytes = request.read(conn, decoder);\n", 
            "-            if (readBytes > 0) {\n", 
            "-                metrics.incrementBytesReceived(readBytes);\n", 
            "-            }\n", 
            "-        } catch (IOException e) {\n", 
            "-            logIOException(e);\n", 
            "-\n", 
            "-            informReaderError(conn);\n", 
            "-\n", 
            "-            SourceContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void responseReady(NHttpServerConnection conn) {\n", 
            "-        try {\n", 
            "-            ProtocolState protocolState = SourceContext.getState(conn);\n", 
            "-            if (protocolState.compareTo(ProtocolState.REQUEST_DONE) < 0) {                \n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            if (protocolState.compareTo(ProtocolState.CLOSING) >= 0) {\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            if (protocolState != ProtocolState.REQUEST_DONE) {\n", 
            "-                handleInvalidState(conn, \"Writing a response\");\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            // because the duplex nature of http core we can reach hear without a actual response\n", 
            "-            SourceResponse response = SourceContext.getResponse(conn);\n", 
            "-            if (response != null) {\n", 
            "-                response.start(conn);\n", 
            "-\n", 
            "-                metrics.incrementMessagesSent();\n", 
            "-            }\n", 
            "-        } catch (IOException e) {\n", 
            "-            logIOException(e);\n", 
            "-\n", 
            "-            informWriterError(conn);\n", 
            "-\n", 
            "-            SourceContext.updateState(conn, ProtocolState.CLOSING);\n", 
            "-            sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-        } catch (HttpException e) {\n", 
            "-            log.error(e.getMessage(), e);\n", 
            "-\n", 
            "-            informWriterError(conn);\n", 
            "-\n", 
            "-            SourceContext.updateState(conn, ProtocolState.CLOSING);\n", 
            "-            sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void outputReady(NHttpServerConnection conn,\n", 
            "-                            ContentEncoder encoder) {\n", 
            "-        try {\n", 
            "-            ProtocolState protocolState = SourceContext.getState(conn);\n", 
            "-            if (protocolState != ProtocolState.RESPONSE_HEAD\n", 
            "-                    && protocolState != ProtocolState.RESPONSE_BODY) {\n", 
            "-                log.warn(\"Illegal incoming connection state: \"\n", 
            "-                        + protocolState + \" . Possibly two send backs \" +\n", 
            "-                        \"are happening for the same request\");\n", 
            "-\n", 
            "-                handleInvalidState(conn, \"Trying to write response body\");\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            SourceContext.updateState(conn, ProtocolState.RESPONSE_BODY);\n", 
            "-\n", 
            "-            SourceResponse response = SourceContext.getResponse(conn);\n", 
            "-\n", 
            "-            int bytesSent = response.write(conn, encoder);\n", 
            "-            metrics.incrementBytesSent(bytesSent);\n", 
            "-        } catch (IOException e) {\n", 
            "-            logIOException(e);\n", 
            "-\n", 
            "-            informWriterError(conn);\n", 
            "-\n", 
            "-            SourceContext.updateState(conn, ProtocolState.CLOSING);\n", 
            "-            sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-        } \n", 
            "-    }\n", 
            "-\n", 
            "-    public void exception(NHttpServerConnection conn, IOException e) {        \n", 
            "-        logIOException(e);\n", 
            "-\n", 
            "-        metrics.incrementFaultsReceiving();\n", 
            "-\n", 
            "-        ProtocolState state = SourceContext.getState(conn);\n", 
            "-        if (state == ProtocolState.REQUEST_BODY ||\n", 
            "-                state == ProtocolState.REQUEST_HEAD) {\n", 
            "-            informReaderError(conn);\n", 
            "-        } else if (state == ProtocolState.RESPONSE_BODY ||\n", 
            "-                state == ProtocolState.RESPONSE_HEAD) {\n", 
            "-            informWriterError(conn);\n", 
            "-        } else if (state == ProtocolState.REQUEST_DONE) {\n", 
            "-            informWriterError(conn);\n", 
            "-        } else if (state == ProtocolState.RESPONSE_DONE) {\n", 
            "-            informWriterError(conn);\n", 
            "-        }\n", 
            "-        \n", 
            "-        SourceContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-        sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    private void logIOException(IOException e) {\n", 
            "-        // this check feels like crazy! But weird things happened, when load testing.\n", 
            "-        if (e == null) {\n", 
            "-            return;\n", 
            "-        }\n", 
            "-        if (e instanceof ConnectionClosedException || (e.getMessage() != null &&\n", 
            "-                e.getMessage().toLowerCase().contains(\"connection reset by peer\") ||\n", 
            "-                e.getMessage().toLowerCase().contains(\"forcibly closed\"))) {\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"I/O error (Probably the keepalive connection \" +\n", 
            "-                        \"was closed):\" + e.getMessage());\n", 
            "-            }\n", 
            "-        } else if (e.getMessage() != null) {\n", 
            "-            String msg = e.getMessage().toLowerCase();\n", 
            "-            if (msg.indexOf(\"broken\") != -1) {\n", 
            "-                log.warn(\"I/O error (Probably the connection \" +\n", 
            "-                        \"was closed by the remote party):\" + e.getMessage());\n", 
            "-            } else {\n", 
            "-                log.error(\"I/O error: \" + e.getMessage(), e);\n", 
            "-            }\n", 
            "-\n", 
            "-            metrics.incrementFaultsReceiving();\n", 
            "-        } else {\n", 
            "-            log.error(\"Unexpected I/O error: \" + e.getClass().getName(), e);\n", 
            "-\n", 
            "-            metrics.incrementFaultsReceiving();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void exception(NHttpServerConnection conn, HttpException e) {        \n", 
            "-        try {\n", 
            "-            if (conn.isResponseSubmitted()) {\n", 
            "-                sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-                return;\n", 
            "-            }\n", 
            "-            HttpContext httpContext = conn.getContext();\n", 
            "-\n", 
            "-            HttpResponse response = new BasicHttpResponse(\n", 
            "-                    HttpVersion.HTTP_1_1, HttpStatus.SC_BAD_REQUEST, \"Bad request\");\n", 
            "-            response.setParams(\n", 
            "-                    new DefaultedHttpParams(sourceConfiguration.getHttpParameters(),\n", 
            "-                            response.getParams()));\n", 
            "-            response.addHeader(HTTP.CONN_DIRECTIVE, HTTP.CONN_CLOSE);\n", 
            "-\n", 
            "-            // Pre-process HTTP request\n", 
            "-            httpContext.setAttribute(ExecutionContext.HTTP_CONNECTION, conn);\n", 
            "-            httpContext.setAttribute(ExecutionContext.HTTP_REQUEST, null);\n", 
            "-            httpContext.setAttribute(ExecutionContext.HTTP_RESPONSE, response);\n", 
            "-\n", 
            "-            sourceConfiguration.getHttpProcessor().process(response, httpContext);\n", 
            "-\n", 
            "-            conn.submitResponse(response);            \n", 
            "-            SourceContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            conn.close();\n", 
            "-        } catch (Exception e1) {\n", 
            "-            log.error(e.getMessage(), e);\n", 
            "-            SourceContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void timeout(NHttpServerConnection conn) {\n", 
            "-        ProtocolState state = SourceContext.getState(conn);\n", 
            "-\n", 
            "-        if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"Keep-Alive connection was time out: \" + conn);\n", 
            "-            }\n", 
            "-        } else if (state == ProtocolState.REQUEST_BODY ||\n", 
            "-                state == ProtocolState.REQUEST_HEAD) {\n", 
            "-\n", 
            "-            metrics.incrementTimeoutsReceiving();\n", 
            "-\n", 
            "-            informReaderError(conn);\n", 
            "-            log.warn(\"Connection time out while reading the request: \" + conn);\n", 
            "-        } else if (state == ProtocolState.RESPONSE_BODY ||\n", 
            "-                state == ProtocolState.RESPONSE_HEAD) {\n", 
            "-            informWriterError(conn);\n", 
            "-            log.warn(\"Connection time out while writing the response: \" + conn);\n", 
            "-        } else if (state == ProtocolState.REQUEST_DONE){\n", 
            "-            log.warn(\"Connection time out after request is read: \" + conn);\n", 
            "-        }\n", 
            "-\n", 
            "-        SourceContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-        sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void closed(NHttpServerConnection conn) {\n", 
            "-        ProtocolState state = SourceContext.getState(conn);\n", 
            "-\n", 
            "-        if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"Keep-Alive connection was closed: \" + conn);\n", 
            "-            }\n", 
            "-        } else if (state == ProtocolState.REQUEST_BODY ||\n", 
            "-                state == ProtocolState.REQUEST_HEAD) {\n", 
            "-            informReaderError(conn);\n", 
            "-            log.warn(\"Connection closed while reading the request: \" + conn);\n", 
            "-        } else if (state == ProtocolState.RESPONSE_BODY ||\n", 
            "-                state == ProtocolState.RESPONSE_HEAD) {\n", 
            "-            informWriterError(conn);\n", 
            "-            log.warn(\"Connection closed while writing the response: \" + conn);\n", 
            "-        } else if (state == ProtocolState.REQUEST_DONE) {\n", 
            "-            log.warn(\"Connection closed by the client after request is read: \" + conn);\n", 
            "-        }\n", 
            "-\n", 
            "-        metrics.disconnected();\n", 
            "-\n", 
            "-        SourceContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-        sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    private void handleInvalidState(NHttpServerConnection conn, String action) {\n", 
            "-        log.warn(action + \" while the handler is in an inconsistent state \" +\n", 
            "-                SourceContext.getState(conn));\n", 
            "-        SourceContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-        sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    private void informReaderError(NHttpServerConnection conn) {\n", 
            "-        Pipe reader = SourceContext.get(conn).getReader();\n", 
            "-\n", 
            "-        metrics.incrementFaultsReceiving();\n", 
            "-\n", 
            "-        if (reader != null) {\n", 
            "-            reader.producerError();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private void informWriterError(NHttpServerConnection conn) {\n", 
            "-        Pipe writer = SourceContext.get(conn).getWriter();\n", 
            "-\n", 
            "-        metrics.incrementFaultsSending();\n", 
            "-\n", 
            "-        if (writer != null) {\n", 
            "-            writer.consumerError();\n", 
            "-        }\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceHandler.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,141 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.axiom.soap.SOAPEnvelope;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.engine.MessageReceiver;\n", 
            "-import org.apache.axis2.util.MessageContextBuilder;\n", 
            "-import org.apache.axis2.wsdl.WSDLConstants;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.synapse.transport.passthru.config.TargetConfiguration;\n", 
            "-\n", 
            "-public class TargetErrorHandler {\n", 
            "-    private Log log = LogFactory.getLog(TargetErrorHandler.class);\n", 
            "-\n", 
            "-    private TargetConfiguration targetConfiguration = null;\n", 
            "-\n", 
            "-    public TargetErrorHandler(TargetConfiguration targetConfiguration) {\n", 
            "-        this.targetConfiguration = targetConfiguration;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Mark request to send failed with error\n", 
            "-     *\n", 
            "-     * @param mc the failed message context\n", 
            "-     * @param errorCode the error code to raise\n", 
            "-     * @param errorMessage the text for an error message to be returned to the MR on failure\n", 
            "-     * @param exceptionToRaise an Exception to be returned to the MR on failure\n", 
            "-     * @param state state of the connection\n", 
            "-     */\n", 
            "-    protected void handleError(final MessageContext mc,\n", 
            "-                               final int errorCode,\n", 
            "-                               final String errorMessage,\n", 
            "-                               final Exception exceptionToRaise,\n", 
            "-                               final ProtocolState state) {\n", 
            "-\n", 
            "-        if (errorCode == -1 && errorMessage == null && exceptionToRaise == null) {\n", 
            "-            return;\n", 
            "-        }\n", 
            "-\n", 
            "-        if (mc.getAxisOperation() == null ||\n", 
            "-                mc.getAxisOperation().getMessageReceiver() == null) {\n", 
            "-            return;\n", 
            "-        }\n", 
            "-\n", 
            "-        targetConfiguration.getWorkerPool().execute(new Runnable() {\n", 
            "-            public void run() {\n", 
            "-                MessageReceiver mr = mc.getAxisOperation().getMessageReceiver();\n", 
            "-                try {\n", 
            "-                    AxisFault axisFault = (exceptionToRaise != null ?\n", 
            "-                            new AxisFault(errorMessage, exceptionToRaise) :\n", 
            "-                            new AxisFault(errorMessage));\n", 
            "-\n", 
            "-                    MessageContext faultMessageContext =\n", 
            "-                            MessageContextBuilder.createFaultMessageContext(mc, axisFault);\n", 
            "-\n", 
            "-                    SOAPEnvelope envelope = faultMessageContext.getEnvelope();\n", 
            "-\n", 
            "-                    if (log.isDebugEnabled()) {\n", 
            "-                        log.debug(\"Sending Fault for Request with Message ID : \"\n", 
            "-                                + mc.getMessageID());\n", 
            "-                    }\n", 
            "-\n", 
            "-                    faultMessageContext.setTo(null);\n", 
            "-                    faultMessageContext.removeProperty(PassThroughConstants.PASS_THROUGH_PIPE);\n", 
            "-\n", 
            "-                    // copy the important properties from the original message context\n", 
            "-                    faultMessageContext.setProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION,\n", 
            "-                            mc.getProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION));\n", 
            "-                    faultMessageContext.setProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION,\n", 
            "-                            mc.getProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION));\n", 
            "-\n", 
            "-                    faultMessageContext.setServerSide(true);\n", 
            "-                    faultMessageContext.setDoingREST(mc.isDoingREST());\n", 
            "-                    faultMessageContext.setProperty(MessageContext.TRANSPORT_IN, mc\n", 
            "-                            .getProperty(MessageContext.TRANSPORT_IN));\n", 
            "-                    faultMessageContext.setTransportIn(mc.getTransportIn());\n", 
            "-                    faultMessageContext.setTransportOut(mc.getTransportOut());\n", 
            "-\n", 
            "-\n", 
            "-                    faultMessageContext.setAxisMessage(\n", 
            "-                            mc.getOperationContext().getAxisOperation().getMessage(\n", 
            "-                                    WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n", 
            "-                    \n", 
            "-                    faultMessageContext.setOperationContext(mc.getOperationContext());\n", 
            "-                    faultMessageContext.setConfigurationContext(mc.getConfigurationContext());\n", 
            "-                    faultMessageContext.setTo(null);\n", 
            "-\n", 
            "-                    faultMessageContext.setProperty(\n", 
            "-                            PassThroughConstants.SENDING_FAULT, Boolean.TRUE);\n", 
            "-                    faultMessageContext.setProperty(\n", 
            "-                            PassThroughConstants.ERROR_MESSAGE, errorMessage);\n", 
            "-                    if (errorCode != -1) {\n", 
            "-                        faultMessageContext.setProperty(\n", 
            "-                                PassThroughConstants.ERROR_CODE, getErrorCode(errorCode, state));\n", 
            "-                    }\n", 
            "-                    if (exceptionToRaise != null) {\n", 
            "-                        faultMessageContext.setProperty(\n", 
            "-                                PassThroughConstants.ERROR_DETAIL, exceptionToRaise.toString());\n", 
            "-                        faultMessageContext.setProperty(\n", 
            "-                                PassThroughConstants.ERROR_EXCEPTION, exceptionToRaise);\n", 
            "-                        envelope.getBody().getFault().getDetail().setText(\n", 
            "-                                exceptionToRaise.toString());\n", 
            "-                    } else {\n", 
            "-                        faultMessageContext.setProperty(\n", 
            "-                                PassThroughConstants.ERROR_DETAIL, errorMessage);\n", 
            "-                        envelope.getBody().getFault().getDetail().setText(errorMessage);\n", 
            "-                    }\n", 
            "-\n", 
            "-                    faultMessageContext.setProperty(PassThroughConstants.NO_ENTITY_BODY, true);\n", 
            "-\n", 
            "-                    mr.receive(faultMessageContext);\n", 
            "-\n", 
            "-                } catch (AxisFault af) {\n", 
            "-                    log.error(\"Unable to report back failure to the message receiver\", af);\n", 
            "-                }\n", 
            "-            }\n", 
            "-        });\n", 
            "-    }\n", 
            "-\n", 
            "-    private int getErrorCode(int errorCode, ProtocolState state) {\n", 
            "-        return errorCode + state.ordinal();\n", 
            "-    }\n", 
            "-\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetErrorHandler.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetErrorHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,237 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.transport.MessageFormatter;\n", 
            "-import org.apache.axis2.transport.http.HTTPConstants;\n", 
            "-import org.apache.http.*;\n", 
            "-import org.apache.http.entity.BasicHttpEntity;\n", 
            "-import org.apache.http.message.BasicHttpEntityEnclosingRequest;\n", 
            "-import org.apache.http.message.BasicHttpRequest;\n", 
            "-import org.apache.http.nio.ContentEncoder;\n", 
            "-import org.apache.http.nio.NHttpClientConnection;\n", 
            "-import org.apache.http.params.DefaultedHttpParams;\n", 
            "-import org.apache.http.protocol.ExecutionContext;\n", 
            "-import org.apache.http.protocol.HTTP;\n", 
            "-import org.apache.synapse.transport.nhttp.util.MessageFormatterDecoratorFactory;\n", 
            "-import org.apache.synapse.transport.passthru.config.TargetConfiguration;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-import java.net.URL;\n", 
            "-import java.util.HashMap;\n", 
            "-import java.util.Map;\n", 
            "-import java.util.Set;\n", 
            "-\n", 
            "-/**\n", 
            "- * This is a class for representing a request to be sent to a target.\n", 
            "- */\n", 
            "-public class TargetRequest {\n", 
            "-    /** Configuration of the sender */\n", 
            "-    private TargetConfiguration targetConfiguration;\n", 
            "-\n", 
            "-    private Pipe pipe = null;\n", 
            "-    /** Headers map */\n", 
            "-    private Map<String, String> headers = new HashMap<String, String>();\n", 
            "-    /** URL */\n", 
            "-    private URL url;\n", 
            "-    /** HTTP Method */\n", 
            "-    private String method;\n", 
            "-    /** HTTP request created for sending the message */\n", 
            "-    private HttpRequest request = null;\n", 
            "-    /** Weather chunk encoding should be used */\n", 
            "-    private boolean chunk = true;\n", 
            "-    /** HTTP version that should be used */\n", 
            "-    private ProtocolVersion version = null;\n", 
            "-    /** Weather full url is used for the request */\n", 
            "-    private boolean fullUrl = false;\n", 
            "-    /** Port to be used for the request */\n", 
            "-    private int port = 80;\n", 
            "-    /** Weather this request has a body */\n", 
            "-    private boolean hasEntityBody = true;\n", 
            "-    /** Keep alive request */\n", 
            "-    private boolean keepAlive = true;\n", 
            "-    \n", 
            "-    /**\n", 
            "-     * Create a target request.\n", 
            "-     *\n", 
            "-     * @param targetConfiguration the configuration of the sender\n", 
            "-     * @param url the url to be used\n", 
            "-     * @param method the HTTP method\n", 
            "-     * @param hasEntityBody weather request has an entity body\n", 
            "-     */\n", 
            "-    public TargetRequest(TargetConfiguration targetConfiguration, URL url,\n", 
            "-                         String method, boolean hasEntityBody) {\n", 
            "-        this(targetConfiguration, method, url, hasEntityBody);\n", 
            "-    }\n", 
            "-\n", 
            "-    public TargetRequest(TargetConfiguration targetConfiguration, String method,\n", 
            "-                         URL url, boolean hasEntityBody) {\n", 
            "-        this.method = method;\n", 
            "-        this.url = url;\n", 
            "-        this.targetConfiguration = targetConfiguration;\n", 
            "-        this.hasEntityBody = hasEntityBody;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void connect(Pipe pipe) {\n", 
            "-        this.pipe = pipe;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void start(NHttpClientConnection conn) throws IOException, HttpException {\n", 
            "-        if (pipe != null) {\n", 
            "-            TargetContext.get(conn).setWriter(pipe);\n", 
            "-        }\n", 
            "-\n", 
            "-        String path = fullUrl ?\n", 
            "-                    url.toString() : url.getPath() +\n", 
            "-                    (url.getQuery() != null ? \"?\" + url.getQuery() : \"\");\n", 
            "-\n", 
            "-        int contentLength = -1;\n", 
            "-        String contentLengthHeader = headers.get(HTTP.CONTENT_LEN);\n", 
            "-        if (contentLengthHeader != null) {\n", 
            "-            contentLength = Integer.parseInt(contentLengthHeader);\n", 
            "-            headers.remove(HTTP.CONTENT_LEN);\n", 
            "-        }\n", 
            "-\n", 
            "-        MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();\n", 
            "-\n", 
            "-        if (hasEntityBody) {\n", 
            "-            request = new BasicHttpEntityEnclosingRequest(method, path,\n", 
            "-                    version != null ? version : HttpVersion.HTTP_1_1);\n", 
            "-\n", 
            "-            BasicHttpEntity entity = new BasicHttpEntity();\n", 
            "-\n", 
            "-            if (contentLength != -1) {\n", 
            "-                entity.setChunked(false);\n", 
            "-                entity.setContentLength(contentLength);\n", 
            "-            } else {\n", 
            "-                entity.setChunked(chunk);\n", 
            "-            }\n", 
            "-            ((BasicHttpEntityEnclosingRequest) request).setEntity(entity);\n", 
            "-        } else {\n", 
            "-            request = new BasicHttpRequest(method, path,\n", 
            "-                    version != null ? version : HttpVersion.HTTP_1_1);\n", 
            "-        }\n", 
            "-\n", 
            "-        Set<Map.Entry<String, String>> entries = headers.entrySet();\n", 
            "-        for (Map.Entry<String, String> entry : entries) {\n", 
            "-            request.setHeader(entry.getKey(), entry.getValue());\n", 
            "-        }\n", 
            "-\n", 
            "-        //setup wsa action..\n", 
            "-        String soapAction = requestMsgCtx.getSoapAction();\n", 
            "-        if (soapAction == null) {\n", 
            "-            soapAction = requestMsgCtx.getWSAAction();\n", 
            "-        }\n", 
            "-        if (soapAction == null) {\n", 
            "-            requestMsgCtx.getAxisOperation().getInputAction();\n", 
            "-        }\n", 
            "-\n", 
            "-        if (requestMsgCtx.isSOAP11() && soapAction != null &&\n", 
            "-                soapAction.length() > 0) {\n", 
            "-            Header existingHeader =\n", 
            "-                    request.getFirstHeader(HTTPConstants.HEADER_SOAP_ACTION);\n", 
            "-            if (existingHeader != null) {\n", 
            "-                request.removeHeader(existingHeader);\n", 
            "-            }\n", 
            "-            MessageFormatter messageFormatter =\n", 
            "-                    MessageFormatterDecoratorFactory.createMessageFormatterDecorator(requestMsgCtx);\n", 
            "-            request.setHeader(HTTPConstants.HEADER_SOAP_ACTION,\n", 
            "-                    messageFormatter.formatSOAPAction(requestMsgCtx, null, soapAction));\n", 
            "-        }\n", 
            "-\n", 
            "-        request.setParams(new DefaultedHttpParams(request.getParams(),\n", 
            "-                targetConfiguration.getHttpParameters()));\n", 
            "-\n", 
            "-        if (!keepAlive) {\n", 
            "-            request.setHeader(HTTP.CONN_DIRECTIVE, HTTP.CONN_CLOSE);\n", 
            "-        }\n", 
            "-\n", 
            "-        // Pre-process HTTP request\n", 
            "-        conn.getContext().setAttribute(ExecutionContext.HTTP_CONNECTION, conn);\n", 
            "-        conn.getContext().setAttribute(ExecutionContext.HTTP_TARGET_HOST,\n", 
            "-                new HttpHost(url.getHost(), port));\n", 
            "-        conn.getContext().setAttribute(ExecutionContext.HTTP_REQUEST, request);\n", 
            "-\n", 
            "-        // start the request\n", 
            "-        targetConfiguration.getHttpProcessor().process(request, conn.getContext());\n", 
            "-        conn.submitRequest(request);\n", 
            "-\n", 
            "-        if (hasEntityBody) {\n", 
            "-            TargetContext.updateState(conn, ProtocolState.REQUEST_HEAD);\n", 
            "-        } else {\n", 
            "-            TargetContext.updateState(conn, ProtocolState.REQUEST_DONE);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Consume the data from the pipe and write it to the wire.\n", 
            "-     *\n", 
            "-     * @param conn the connection to the target\n", 
            "-     * @param encoder encoder for writing the message through\n", 
            "-     * @throws java.io.IOException if an error occurs\n", 
            "-     * @return number of bytes written\n", 
            "-     */\n", 
            "-    public int write(NHttpClientConnection conn, ContentEncoder encoder) throws IOException {\n", 
            "-        int bytes = 0;\n", 
            "-        if (pipe != null) {\n", 
            "-            bytes = pipe.consume(encoder);\n", 
            "-        }\n", 
            "-\n", 
            "-        if (encoder.isCompleted()) {\n", 
            "-            targetConfiguration.getMetrics().\n", 
            "-                    notifySentMessageSize(conn.getMetrics().getSentBytesCount());\n", 
            "-\n", 
            "-            TargetContext.updateState(conn, ProtocolState.REQUEST_DONE);\n", 
            "-        }\n", 
            "-        \n", 
            "-        return bytes;\n", 
            "-\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean hasEntityBody() {\n", 
            "-        return hasEntityBody;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void addHeader(String name, String value) {\n", 
            "-        headers.put(name, value);\n", 
            "-    }\n", 
            "-\n", 
            "-    public String getMethod() {\n", 
            "-        return method;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setChunk(boolean chunk) {\n", 
            "-        this.chunk = chunk;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setPort(int port) {\n", 
            "-        this.port = port;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setFullUrl(boolean fullUrl) {\n", 
            "-        this.fullUrl = fullUrl;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setVersion(ProtocolVersion version) {\n", 
            "-        this.version = version;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setKeepAlive(boolean keepAlive) {\n", 
            "-        this.keepAlive = keepAlive;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,155 +0,0", 
          "lines": [
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.axiom.om.OMElement;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.description.Parameter;\n", 
            "-import org.apache.axis2.description.TransportInDescription;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.impl.nio.SSLServerIOEventDispatch;\n", 
            "-import org.apache.http.impl.nio.reactor.SSLIOSessionHandler;\n", 
            "-import org.apache.http.nio.NHttpServiceHandler;\n", 
            "-import org.apache.http.nio.reactor.IOEventDispatch;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-\n", 
            "-import javax.net.ssl.*;\n", 
            "-import javax.xml.namespace.QName;\n", 
            "-import java.io.FileInputStream;\n", 
            "-import java.io.IOException;\n", 
            "-import java.net.SocketAddress;\n", 
            "-import java.security.GeneralSecurityException;\n", 
            "-import java.security.KeyStore;\n", 
            "-\n", 
            "-public class PassThroughHttpSSLListener extends PassThroughHttpListener {\n", 
            "-    \n", 
            "-    private Log log = LogFactory.getLog(PassThroughHttpSSLListener.class);\n", 
            "-\n", 
            "-    protected IOEventDispatch getEventDispatch(\n", 
            "-        NHttpServiceHandler handler, SSLContext sslContext,\n", 
            "-        SSLIOSessionHandler sslIOSessionHandler, HttpParams params) {\n", 
            "-        return new SSLServerIOEventDispatch(handler, sslContext, sslIOSessionHandler, params);\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Create the SSLContext to be used by this listener\n", 
            "-     * @param transportIn the Axis2 transport description\n", 
            "-     * @return the SSLContext to be used\n", 
            "-     * @throws org.apache.axis2.AxisFault if an error occurs\n", 
            "-     */\n", 
            "-    protected SSLContext getSSLContext(TransportInDescription transportIn) throws AxisFault {\n", 
            "-\n", 
            "-        KeyManager[] keymanagers  = null;\n", 
            "-        TrustManager[] trustManagers = null;\n", 
            "-\n", 
            "-        Parameter keyParam    = transportIn.getParameter(\"keystore\");\n", 
            "-        Parameter trustParam  = transportIn.getParameter(\"truststore\");\n", 
            "-\n", 
            "-        if (keyParam != null) {\n", 
            "-            OMElement ksEle      = keyParam.getParameterElement().getFirstElement();\n", 
            "-            String location      = ksEle.getFirstChildWithName(new QName(\"Location\")).getText();\n", 
            "-            String type          = ksEle.getFirstChildWithName(new QName(\"Type\")).getText();\n", 
            "-            String storePassword = ksEle.getFirstChildWithName(new QName(\"Password\")).getText();\n", 
            "-            String keyPassword   = ksEle.getFirstChildWithName(new QName(\"KeyPassword\")).getText();\n", 
            "-\n", 
            "-            FileInputStream fis = null;\n", 
            "-            try {\n", 
            "-                KeyStore keyStore = KeyStore.getInstance(type);\n", 
            "-                fis = new FileInputStream(location);\n", 
            "-                log.info(\"Loading Identity Keystore from : \" + location);\n", 
            "-\n", 
            "-                keyStore.load(fis, storePassword.toCharArray());\n", 
            "-                KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(\n", 
            "-                    KeyManagerFactory.getDefaultAlgorithm());\n", 
            "-                kmfactory.init(keyStore, keyPassword.toCharArray());\n", 
            "-                keymanagers = kmfactory.getKeyManagers();\n", 
            "-\n", 
            "-            } catch (GeneralSecurityException gse) {\n", 
            "-                log.error(\"Error loading Key store : \" + location, gse);\n", 
            "-                throw new AxisFault(\"Error loading Key store : \" + location, gse);\n", 
            "-            } catch (IOException ioe) {\n", 
            "-                log.error(\"Error opening Key store : \" + location, ioe);\n", 
            "-                throw new AxisFault(\"Error opening Key store : \" + location, ioe);\n", 
            "-            } finally {\n", 
            "-                if (fis != null) {\n", 
            "-                    try {\n", 
            "-                        fis.close();\n", 
            "-                    } catch (IOException ignore) {}\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        if (trustParam != null) {\n", 
            "-            OMElement tsEle      = trustParam.getParameterElement().getFirstElement();\n", 
            "-            String location      = tsEle.getFirstChildWithName(new QName(\"Location\")).getText();\n", 
            "-            String type          = tsEle.getFirstChildWithName(new QName(\"Type\")).getText();\n", 
            "-            String storePassword = tsEle.getFirstChildWithName(new QName(\"Password\")).getText();\n", 
            "-\n", 
            "-            FileInputStream fis = null;\n", 
            "-            try {\n", 
            "-                KeyStore trustStore = KeyStore.getInstance(type);\n", 
            "-                fis = new FileInputStream(location);\n", 
            "-                log.info(\"Loading Trust Keystore from : \" + location);\n", 
            "-\n", 
            "-                trustStore.load(fis, storePassword.toCharArray());\n", 
            "-                TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance(\n", 
            "-                    TrustManagerFactory.getDefaultAlgorithm());\n", 
            "-                trustManagerfactory.init(trustStore);\n", 
            "-                trustManagers = trustManagerfactory.getTrustManagers();\n", 
            "-\n", 
            "-            } catch (GeneralSecurityException gse) {\n", 
            "-                log.error(\"Error loading Key store : \" + location, gse);\n", 
            "-                throw new AxisFault(\"Error loading Key store : \" + location, gse);\n", 
            "-            } catch (IOException ioe) {\n", 
            "-                log.error(\"Error opening Key store : \" + location, ioe);\n", 
            "-                throw new AxisFault(\"Error opening Key store : \" + location, ioe);\n", 
            "-            } finally {\n", 
            "-                if (fis != null) {\n", 
            "-                    try {\n", 
            "-                        fis.close();\n", 
            "-                    } catch (IOException ignore) {}\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        try {\n", 
            "-            SSLContext sslcontext = SSLContext.getInstance(\"TLS\");\n", 
            "-            sslcontext.init(keymanagers, trustManagers, null);\n", 
            "-            return sslcontext;\n", 
            "-\n", 
            "-        } catch (GeneralSecurityException gse) {\n", 
            "-            log.error(\"Unable to create SSL context with the given configuration\", gse);\n", 
            "-            throw new AxisFault(\"Unable to create SSL context with the given configuration\", gse);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Create the SSLIOSessionHandler to initialize the SSL session / engine, and request for\n", 
            "-     * client authentication at the following levels, through an Axis2 transport configuration\n", 
            "-     * parameter as follows:\n", 
            "-     * SSLVerifyClient - none, optional, require\n", 
            "-     *\n", 
            "-     * @param transportIn the Axis2 transport configuration\n", 
            "-     * @return the SSLIOSessionHandler to be used\n", 
            "-     * @throws AxisFault if a configuration error occurs\n", 
            "-     */\n", 
            "-    protected SSLIOSessionHandler getSSLIOSessionHandler(TransportInDescription transportIn) throws AxisFault {\n", 
            "-\n", 
            "-        final Parameter clientAuth = transportIn.getParameter(\"SSLVerifyClient\");\n", 
            "-\n", 
            "-        return new SSLIOSessionHandler() {\n", 
            "-\n", 
            "-            public void initalize(SSLEngine sslengine, HttpParams params) {\n", 
            "-                if (clientAuth != null) {\n", 
            "-                    if (\"optional\".equals(clientAuth.getValue())) {\n", 
            "-                        sslengine.setWantClientAuth(true);\n", 
            "-                    } else if (\"require\".equals(clientAuth.getValue())) {\n", 
            "-                        sslengine.setNeedClientAuth(true);\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            }\n", 
            "-\n", 
            "-            public void verify(SocketAddress removeAddress, SSLSession session)\n", 
            "-                throws SSLException {}\n", 
            "-        };\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,44 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.http.impl.nio.DefaultClientIOEventDispatch;\n", 
            "-import org.apache.http.nio.NHttpClientHandler;\n", 
            "-import org.apache.http.nio.NHttpClientIOTarget;\n", 
            "-import org.apache.http.nio.reactor.IOSession;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-import org.apache.synapse.transport.passthru.logging.LoggingUtils;\n", 
            "-\n", 
            "-/**\n", 
            "- * This is a factory for creating the logging sessions or non-logging sessions.\n", 
            "- */\n", 
            "-public class TargetIOEventDispatch extends DefaultClientIOEventDispatch {\n", 
            "-\n", 
            "-    public TargetIOEventDispatch(final NHttpClientHandler handler, final HttpParams params) {\n", 
            "-        super(LoggingUtils.decorate(handler), params);\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    protected NHttpClientIOTarget createConnection(IOSession session) {\n", 
            "-        session = LoggingUtils.decorate(session, \"client\");\n", 
            "-        return LoggingUtils.createClientConnection(\n", 
            "-                session,\n", 
            "-                createHttpResponseFactory(),\n", 
            "-                this.allocator,\n", 
            "-                this.params);\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetIOEventDispatch.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetIOEventDispatch.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,361 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.axiom.om.OMAbstractFactory;\n", 
            "-import org.apache.axiom.soap.SOAPFactory;\n", 
            "-import org.apache.axiom.soap.SOAPEnvelope;\n", 
            "-import org.apache.axiom.soap.impl.llom.soap11.SOAP11Factory;\n", 
            "-import org.apache.axiom.util.UIDGenerator;\n", 
            "-import org.apache.axis2.Constants;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.builder.BuilderUtil;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.description.Parameter;\n", 
            "-import org.apache.axis2.transport.RequestResponseTransport;\n", 
            "-import org.apache.axis2.transport.TransportUtils;\n", 
            "-import org.apache.axis2.transport.http.HTTPConstants;\n", 
            "-import org.apache.axis2.transport.http.HTTPTransportUtils;\n", 
            "-import org.apache.axis2.util.MessageContextBuilder;\n", 
            "-import org.apache.axis2.addressing.EndpointReference;\n", 
            "-import org.apache.axis2.engine.AxisEngine;\n", 
            "-import org.apache.axis2.context.ConfigurationContext;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.HttpInetConnection;\n", 
            "-import org.apache.http.HttpStatus;\n", 
            "-import org.apache.http.nio.NHttpServerConnection;\n", 
            "-import org.apache.http.protocol.HTTP;\n", 
            "-import org.apache.synapse.transport.nhttp.HttpCoreRequestResponseTransport;\n", 
            "-import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            "-import org.apache.synapse.transport.nhttp.util.NhttpUtil;\n", 
            "-import org.apache.synapse.transport.passthru.config.SourceConfiguration;\n", 
            "-import org.apache.synapse.transport.passthru.util.SourceResponseFactory;\n", 
            "-\n", 
            "-import java.net.InetAddress;\n", 
            "-import java.util.*;\n", 
            "-\n", 
            "-/**\n", 
            "- * This is a worker thread for executing an incoming request in to the transport.\n", 
            "- */\n", 
            "-public class ServerWorker implements Runnable {\n", 
            "-\n", 
            "-    private static final Log log = LogFactory.getLog(ServerWorker.class);\n", 
            "-    /** the incoming message to be processed */\n", 
            "-    private org.apache.axis2.context.MessageContext msgContext = null;\n", 
            "-    /** the http request */\n", 
            "-    private SourceRequest request = null;\n", 
            "-    /** The configuration of the receiver */\n", 
            "-    private SourceConfiguration sourceConfiguration = null;\n", 
            "-\n", 
            "-    private static final String SOAP_ACTION_HEADER = \"SOAPAction\";\n", 
            "-\n", 
            "-    public ServerWorker(final SourceRequest request,\n", 
            "-                        final SourceConfiguration sourceConfiguration) {\n", 
            "-        this.request = request;\n", 
            "-        this.sourceConfiguration = sourceConfiguration;\n", 
            "-\n", 
            "-        this.msgContext = createMessageContext(request);\n", 
            "-\n", 
            "-        // set these properties to be accessed by the engine\n", 
            "-        msgContext.setProperty(\n", 
            "-                PassThroughConstants.PASS_THROUGH_SOURCE_REQUEST, request);\n", 
            "-        msgContext.setProperty(\n", 
            "-                PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION, sourceConfiguration);\n", 
            "-        msgContext.setProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION,\n", 
            "-                request.getConnection());\n", 
            "-    }\n", 
            "-\n", 
            "-    public void run() {\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            log.debug(\"Starting a new Server Worker instance\");\n", 
            "-        }\n", 
            "-        ConfigurationContext cfgCtx = sourceConfiguration.getConfigurationContext();        \n", 
            "-        msgContext.setProperty(Constants.Configuration.HTTP_METHOD, request.getMethod());\n", 
            "-\n", 
            "-        String uri = request.getUri();\n", 
            "-\n", 
            "-        if (uri.contains(cfgCtx.getServicePath())) {\n", 
            "-            // discard up to servicePath\n", 
            "-            uri = uri.substring(uri.indexOf(cfgCtx.getServicePath()) +\n", 
            "-                    cfgCtx.getServicePath().length());\n", 
            "-            // discard [proxy] service name if any\n", 
            "-            int pos = uri.indexOf(\"/\", 1);\n", 
            "-            if (pos > 0) {\n", 
            "-                uri = uri.substring(pos);\n", 
            "-            } else {\n", 
            "-                pos = uri.indexOf(\"?\");\n", 
            "-                if (pos != -1) {\n", 
            "-                    uri = uri.substring(pos);\n", 
            "-                } else {\n", 
            "-                    uri = \"\";\n", 
            "-                }\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            // remove any absolute prefix if any\n", 
            "-            int pos = uri.indexOf(\"://\");\n", 
            "-            if (pos != -1) {\n", 
            "-                uri = uri.substring(pos + 3);\n", 
            "-                pos = uri.indexOf(\"/\");\n", 
            "-                if (pos != -1) {\n", 
            "-                    uri = uri.substring(pos + 1);\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        msgContext.setTo(new EndpointReference(uri));\n", 
            "-        msgContext.setProperty(PassThroughConstants.REST_URL_POSTFIX, uri);\n", 
            "-\n", 
            "-        if (request.isEntityEnclosing()) {\n", 
            "-            processEntityEnclosingRequest();\n", 
            "-        } else {\n", 
            "-            processNonEntityEnclosingMethod();\n", 
            "-        }\n", 
            "-\n", 
            "-        sendAck();\n", 
            "-    }\n", 
            "-\n", 
            "-    private void sendAck() {\n", 
            "-        String respWritten = \"\";\n", 
            "-        if (msgContext.getOperationContext() != null) {\n", 
            "-            respWritten = (String) msgContext.getOperationContext().getProperty(\n", 
            "-                    Constants.RESPONSE_WRITTEN);\n", 
            "-        }\n", 
            "-        boolean respWillFollow = !Constants.VALUE_TRUE.equals(respWritten)\n", 
            "-                && !\"SKIP\".equals(respWritten);\n", 
            "-        boolean ack = (((RequestResponseTransport) msgContext.getProperty(\n", 
            "-                    RequestResponseTransport.TRANSPORT_CONTROL)).getStatus()\n", 
            "-                    == RequestResponseTransport.RequestResponseTransportStatus.ACKED);\n", 
            "-        boolean forced = msgContext.isPropertyTrue(NhttpConstants.FORCE_SC_ACCEPTED);\n", 
            "-        boolean nioAck = msgContext.isPropertyTrue(\"NIO-ACK-Requested\", false);\n", 
            "-        if (respWillFollow || ack || forced || nioAck) {\n", 
            "-            NHttpServerConnection conn = request.getConnection();\n", 
            "-            SourceResponse sourceResponse;\n", 
            "-            if (!nioAck) {\n", 
            "-                msgContext.removeProperty(MessageContext.TRANSPORT_HEADERS);\n", 
            "-                sourceResponse = SourceResponseFactory.create(msgContext,\n", 
            "-                        request, sourceConfiguration);\n", 
            "-                sourceResponse.setStatus(HttpStatus.SC_ACCEPTED);\n", 
            "-            } else {\n", 
            "-                if (log.isDebugEnabled()) {\n", 
            "-                    log.debug(\"Sending ACK response with status \"\n", 
            "-                            + msgContext.getProperty(NhttpConstants.HTTP_SC)\n", 
            "-                            + \", for MessageID : \" + msgContext.getMessageID());\n", 
            "-                }\n", 
            "-                sourceResponse = SourceResponseFactory.create(msgContext,\n", 
            "-                        request, sourceConfiguration);\n", 
            "-                sourceResponse.setStatus(Integer.parseInt(\n", 
            "-                        msgContext.getProperty(NhttpConstants.HTTP_SC).toString()));\n", 
            "-            }\n", 
            "-\n", 
            "-            SourceContext.setResponse(conn, sourceResponse);\n", 
            "-            ProtocolState state = SourceContext.getState(conn);\n", 
            "-            if (state != null && state.compareTo(ProtocolState.REQUEST_DONE) <= 0) {\n", 
            "-                conn.requestOutput();\n", 
            "-            } else {\n", 
            "-                SourceContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-                sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private void processNonEntityEnclosingMethod() {\n", 
            "-        String soapAction = request.getHeaders().get(SOAP_ACTION_HEADER);\n", 
            "-        if ((soapAction != null) && soapAction.startsWith(\"\\\"\") && soapAction.endsWith(\"\\\"\")) {\n", 
            "-            soapAction = soapAction.substring(1, soapAction.length() - 1);\n", 
            "-        }\n", 
            "-\n", 
            "-        msgContext.setSoapAction(soapAction);\n", 
            "-        msgContext.setTo(new EndpointReference(request.getUri()));\n", 
            "-        msgContext.setServerSide(true);\n", 
            "-        msgContext.setDoingREST(true);\n", 
            "-        msgContext.setProperty(PassThroughConstants.NO_ENTITY_BODY, Boolean.TRUE);\n", 
            "-\n", 
            "-        try {\n", 
            "-            msgContext.setEnvelope(new SOAP11Factory().getDefaultEnvelope());\n", 
            "-\n", 
            "-            AxisEngine.receive(msgContext);\n", 
            "-        } catch (AxisFault axisFault) {\n", 
            "-            handleException(\"Error processing \" + request.getMethod() +\n", 
            "-                \" request for : \" + request.getUri(), axisFault);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private void processEntityEnclosingRequest() {\n", 
            "-        try {\n", 
            "-            String contentTypeHeader = request.getHeaders().get(HTTP.CONTENT_TYPE);\n", 
            "-            contentTypeHeader = contentTypeHeader != null ? contentTypeHeader : inferContentType();\n", 
            "-\n", 
            "-            String charSetEncoding = BuilderUtil.getCharSetEncoding(contentTypeHeader);\n", 
            "-            String contentType = TransportUtils.getContentType(contentTypeHeader, msgContext);\n", 
            "-\n", 
            "-            // get the contentType of char encoding\n", 
            "-            if (charSetEncoding == null) {\n", 
            "-                charSetEncoding = MessageContext.DEFAULT_CHAR_SET_ENCODING;\n", 
            "-            }\n", 
            "-\n", 
            "-            msgContext.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEncoding);\n", 
            "-            msgContext.setProperty(Constants.Configuration.CONTENT_TYPE, contentTypeHeader);\n", 
            "-            msgContext.setProperty(Constants.Configuration.MESSAGE_TYPE, contentType);\n", 
            "-\n", 
            "-            msgContext.setTo(new EndpointReference(request.getUri()));\n", 
            "-            msgContext.setProperty(HTTPConstants.HTTP_METHOD, request.getMethod());\n", 
            "-            msgContext.setServerSide(true);\n", 
            "-\n", 
            "-            if (HTTPTransportUtils.isRESTRequest(contentTypeHeader)) {\n", 
            "-\n", 
            "-                msgContext.setProperty(PassThroughConstants.REST_REQUEST_CONTENT_TYPE, contentType);\n", 
            "-                msgContext.setDoingREST(true);\n", 
            "-\n", 
            "-                String messageType =\n", 
            "-                        (String) msgContext.getProperty(Constants.Configuration.MESSAGE_TYPE);\n", 
            "-                if (HTTPConstants.MEDIA_TYPE_X_WWW_FORM.equals(messageType) ||\n", 
            "-                        HTTPConstants.MEDIA_TYPE_MULTIPART_FORM_DATA.equals(messageType)) {\n", 
            "-                    msgContext.setProperty(Constants.Configuration.MESSAGE_TYPE,\n", 
            "-                            HTTPConstants.MEDIA_TYPE_APPLICATION_XML);\n", 
            "-                }\n", 
            "-\n", 
            "-                SOAPFactory fac = OMAbstractFactory.getSOAP12Factory();\n", 
            "-                SOAPEnvelope envelope = fac.getDefaultEnvelope();\n", 
            "-\n", 
            "-                msgContext.setEnvelope(envelope);\n", 
            "-            } else {\n", 
            "-                String soapAction = request.getHeaders().get(SOAP_ACTION_HEADER);\n", 
            "-\n", 
            "-                int soapVersion = HTTPTransportUtils.\n", 
            "-                        initializeMessageContext(msgContext, soapAction,\n", 
            "-                                request.getUri(), contentTypeHeader);\n", 
            "-                SOAPEnvelope envelope;\n", 
            "-\n", 
            "-                if (soapVersion == 1) {\n", 
            "-                    SOAPFactory fac = OMAbstractFactory.getSOAP11Factory();\n", 
            "-                    envelope = fac.getDefaultEnvelope();\n", 
            "-                } else if (soapVersion == 2) {\n", 
            "-                    SOAPFactory fac = OMAbstractFactory.getSOAP12Factory();\n", 
            "-                    envelope = fac.getDefaultEnvelope();\n", 
            "-                } else {\n", 
            "-                    SOAPFactory fac = OMAbstractFactory.getSOAP12Factory();\n", 
            "-                    envelope = fac.getDefaultEnvelope();\n", 
            "-                }\n", 
            "-\n", 
            "-                msgContext.setEnvelope(envelope);\n", 
            "-            }\n", 
            "-\n", 
            "-            msgContext.setProperty(PassThroughConstants.PASS_THROUGH_PIPE, request.getPipe());\n", 
            "-\n", 
            "-            AxisEngine.receive(msgContext);\n", 
            "-        } catch (AxisFault axisFault) {\n", 
            "-            handleException(\"Error processing \" + request.getMethod() +\n", 
            "-                \" request for : \" + request.getUri(), axisFault);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Create an Axis2 message context for the given http request. The request may be in the\n", 
            "-     * process of being streamed\n", 
            "-     *\n", 
            "-     * @param request the http request to be used to create the corresponding Axis2 message context\n", 
            "-     * @return the Axis2 message context created\n", 
            "-     */\n", 
            "-    private MessageContext createMessageContext(SourceRequest request) {\n", 
            "-        ConfigurationContext cfgCtx = sourceConfiguration.getConfigurationContext();\n", 
            "-        MessageContext msgContext =\n", 
            "-                new MessageContext();\n", 
            "-        msgContext.setMessageID(UIDGenerator.generateURNString());\n", 
            "-\n", 
            "-        // Axis2 spawns a new threads to send a message if this is TRUE - and it has to\n", 
            "-        // be the other way\n", 
            "-        msgContext.setProperty(MessageContext.CLIENT_API_NON_BLOCKING,\n", 
            "-                Boolean.FALSE);\n", 
            "-        msgContext.setConfigurationContext(cfgCtx);\n", 
            "-\n", 
            "-        msgContext.setTransportOut(cfgCtx.getAxisConfiguration()\n", 
            "-                .getTransportOut(Constants.TRANSPORT_HTTP));\n", 
            "-        msgContext.setTransportIn(cfgCtx.getAxisConfiguration()\n", 
            "-                .getTransportIn(Constants.TRANSPORT_HTTP));\n", 
            "-        msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTP);\n", 
            "-        msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, this);\n", 
            "-\n", 
            "-        msgContext.setServerSide(true);\n", 
            "-        msgContext.setProperty(\n", 
            "-                Constants.Configuration.TRANSPORT_IN_URL, request.getUri());\n", 
            "-\n", 
            "-        // http transport header names are case insensitive\n", 
            "-        Map<String, String> headers = new TreeMap<String, String>(new Comparator<String>() {\n", 
            "-            public int compare(String o1, String o2) {\n", 
            "-                return o1.compareToIgnoreCase(o2);\n", 
            "-            }\n", 
            "-        });\n", 
            "-\n", 
            "-        Set<Map.Entry<String, String>> entries = request.getHeaders().entrySet();\n", 
            "-        for (Map.Entry<String, String> entry : entries) {\n", 
            "-            headers.put(entry.getKey(), entry.getValue());\n", 
            "-        }\n", 
            "-        msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, headers);\n", 
            "-\n", 
            "-        // Following section is required for throttling to work\n", 
            "-        NHttpServerConnection conn = request.getConnection();\n", 
            "-        if (conn instanceof HttpInetConnection) {\n", 
            "-            HttpInetConnection netConn = (HttpInetConnection) conn;\n", 
            "-            InetAddress remoteAddress = netConn.getRemoteAddress();\n", 
            "-            if (remoteAddress != null) {\n", 
            "-                msgContext.setProperty(\n", 
            "-                        MessageContext.REMOTE_ADDR, remoteAddress.getHostAddress());\n", 
            "-                msgContext.setProperty(\n", 
            "-                        NhttpConstants.REMOTE_HOST, NhttpUtil.getHostName(remoteAddress));\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        msgContext.setProperty(RequestResponseTransport.TRANSPORT_CONTROL,\n", 
            "-                new HttpCoreRequestResponseTransport(msgContext));\n", 
            "-\n", 
            "-        return msgContext;\n", 
            "-    }\n", 
            "-\n", 
            "-    private void handleException(String msg, Exception e) {\n", 
            "-        if (e == null) {\n", 
            "-            log.error(msg);\n", 
            "-        } else {\n", 
            "-            log.error(msg, e);\n", 
            "-        }\n", 
            "-\n", 
            "-        if (e == null) {\n", 
            "-            e = new Exception(msg);\n", 
            "-        }\n", 
            "-\n", 
            "-        try {\n", 
            "-            MessageContext faultContext =\n", 
            "-                    MessageContextBuilder.createFaultMessageContext(\n", 
            "-                    msgContext, e);\n", 
            "-            AxisEngine.sendFault(faultContext);\n", 
            "-        } catch (Exception ignored) {}\n", 
            "-    }\n", 
            "-\n", 
            "-    private String inferContentType() {\n", 
            "-        Parameter param = sourceConfiguration.getConfigurationContext().getAxisConfiguration().\n", 
            "-                getParameter(PassThroughConstants.REQUEST_CONTENT_TYPE);\n", 
            "-        if (param != null) {\n", 
            "-            return param.getValue().toString();\n", 
            "-        }\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    MessageContext getRequestContext() {\n", 
            "-        return msgContext;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,42 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-/**\n", 
            "- * State of a request or a response in transport receiver or sender\n", 
            "- * is represented in these values.\n", 
            "- */\n", 
            "-public enum ProtocolState {\n", 
            "-    /** Connection is at the initial stage ready to receive a request */\n", 
            "-    REQUEST_READY,\n", 
            "-    /** The connection is reading the request headers */\n", 
            "-    REQUEST_HEAD,\n", 
            "-    /** The connection is reading the request body */\n", 
            "-    REQUEST_BODY,\n", 
            "-    /** Request is completely received */\n", 
            "-    REQUEST_DONE,\n", 
            "-    /** The connection is reading the response headers */\n", 
            "-    RESPONSE_HEAD,\n", 
            "-    /** The connection si reading the response body */\n", 
            "-    RESPONSE_BODY,\n", 
            "-    /** The response is completed */\n", 
            "-    RESPONSE_DONE,\n", 
            "-    /** The connection is closing */\n", 
            "-    CLOSING,\n", 
            "-    /** The connection is closed */\n", 
            "-    CLOSED\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ProtocolState.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ProtocolState.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,248 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.addressing.EndpointReference;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.nio.NHttpClientConnection;\n", 
            "-import org.apache.synapse.transport.passthru.config.TargetConfiguration;\n", 
            "-import org.apache.synapse.transport.passthru.connections.TargetConnections;\n", 
            "-import org.apache.synapse.transport.passthru.util.TargetRequestFactory;\n", 
            "-\n", 
            "-import java.io.OutputStream;\n", 
            "-import java.util.Queue;\n", 
            "-import java.util.Map;\n", 
            "-import java.util.concurrent.ConcurrentHashMap;\n", 
            "-import java.util.concurrent.ConcurrentLinkedQueue;\n", 
            "-import java.net.URL;\n", 
            "-import java.net.MalformedURLException;\n", 
            "-import java.util.concurrent.locks.Lock;\n", 
            "-import java.util.concurrent.locks.ReentrantLock;\n", 
            "-\n", 
            "-/**\n", 
            "- * This class acts as a gateway for differed delivery of the messages. When a message is to be\n", 
            "- * delivered it is submitted to this class. If a connection is available to the target this\n", 
            "- * class will try to deliver the message immediately over that connection. If a connection is\n", 
            "- * not available it will queue the message and request a connection from the pool. When a new\n", 
            "- * connection is available a queued message will be sent through it. \n", 
            "- */\n", 
            "-public class DeliveryAgent {\n", 
            "-\n", 
            "-    private static final Log log = LogFactory.getLog(DeliveryAgent.class);\n", 
            "-\n", 
            "-    /**\n", 
            "-     * This Map holds the messages that need to be delivered. But at the moment maximum\n", 
            "-     * number of connections to the host:pair is being used. So these messages has to wait\n", 
            "-     * until a new connection is available.\n", 
            "-     */\n", 
            "-    private Map<String, Queue<MessageContext>> waitingMessages =\n", 
            "-            new ConcurrentHashMap<String, Queue<MessageContext>>();\n", 
            "-\n", 
            "-    /** The connection management */\n", 
            "-    private TargetConnections targetConnections;\n", 
            "-\n", 
            "-    /** Configuration of the sender */\n", 
            "-    private TargetConfiguration targetConfiguration;\n", 
            "-\n", 
            "-    /** The maximum number of messages that can wait for a connection */\n", 
            "-    private int maxWaitingMessages = Integer.MAX_VALUE;\n", 
            "-\n", 
            "-    private TargetErrorHandler targetErrorHandler;\n", 
            "-\n", 
            "-    /** Lock for synchronizing access */\n", 
            "-    private Lock lock = new ReentrantLock();\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Create a delivery agent with the target configuration and connection management.\n", 
            "-     *\n", 
            "-     * @param targetConfiguration configuration of the sender\n", 
            "-     * @param targetConnections connection management\n", 
            "-     */\n", 
            "-    public DeliveryAgent(TargetConfiguration targetConfiguration,\n", 
            "-                         TargetConnections targetConnections) {\n", 
            "-        this.targetConfiguration = targetConfiguration;\n", 
            "-        this.targetConnections = targetConnections;\n", 
            "-        this.targetErrorHandler = new TargetErrorHandler(targetConfiguration);\n", 
            "-    }\n", 
            "-\n", 
            "-\n", 
            "-    /**\n", 
            "-     * This method queues the message for delivery. If a connection is already existing for\n", 
            "-     * the destination epr, the message will be delivered immediately. Otherwise message has\n", 
            "-     * to wait until a connection is established. In this case this method will inform the\n", 
            "-     * system about the need for a connection.\n", 
            "-     *\n", 
            "-     * @param msgContext the message context to be sent\n", 
            "-     * @param epr the endpoint to which the message should be sent\n", 
            "-     * @throws AxisFault if an error occurs\n", 
            "-     */\n", 
            "-    public void submit(MessageContext msgContext, EndpointReference epr)\n", 
            "-            throws AxisFault {\n", 
            "-        try {\n", 
            "-            URL url = new URL(epr.getAddress());\n", 
            "-            String host = url.getHost();\n", 
            "-            int port = url.getPort();\n", 
            "-            if (port == -1) {\n", 
            "-                // use default\n", 
            "-                if (\"http\".equals(url.getProtocol())) {\n", 
            "-                    port = 80;\n", 
            "-                } else if (\"https\".equals(url.getProtocol())) {\n", 
            "-                    port = 443;\n", 
            "-                }\n", 
            "-            }\n", 
            "-\n", 
            "-            String key = host + \":\" + port;\n", 
            "-\n", 
            "-            // first we queue the message\n", 
            "-            Queue<MessageContext> queue = null;\n", 
            "-            lock.lock();\n", 
            "-            try {\n", 
            "-                queue = waitingMessages.get(key);\n", 
            "-                if (queue == null) {\n", 
            "-                    queue = new ConcurrentLinkedQueue<MessageContext>();\n", 
            "-                    waitingMessages.put(key, queue);\n", 
            "-                }\n", 
            "-                if (queue.size() == maxWaitingMessages) {\n", 
            "-                    MessageContext msgCtx = queue.poll();\n", 
            "-\n", 
            "-                    targetErrorHandler.handleError(msgCtx,\n", 
            "-                            ErrorCodes.CONNECTION_TIMEOUT,\n", 
            "-                            \"Error connecting to the back end\",\n", 
            "-                            null,\n", 
            "-                            ProtocolState.REQUEST_READY);\n", 
            "-                }\n", 
            "-\n", 
            "-                queue.add(msgContext);\n", 
            "-            } finally {\n", 
            "-                lock.unlock();\n", 
            "-            }\n", 
            "-\n", 
            "-            NHttpClientConnection conn = targetConnections.getConnection(host, port);\n", 
            "-            if (conn != null) {\n", 
            "-                MessageContext messageContext = queue.poll();\n", 
            "-\n", 
            "-                if (messageContext != null) {\n", 
            "-                    tryNextMessage(messageContext, conn);\n", 
            "-                }\n", 
            "-            }\n", 
            "-\n", 
            "-        } catch (MalformedURLException e) {\n", 
            "-            handleException(\"Malformed URL in the target EPR\", e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void errorConnecting(String host, int port, int errorCode, String message) {\n", 
            "-        String key = host + \":\" + port;\n", 
            "-\n", 
            "-        Queue<MessageContext> queue = waitingMessages.get(key);\n", 
            "-        if (queue != null) {\n", 
            "-            MessageContext msgCtx = queue.poll();\n", 
            "-\n", 
            "-            if (msgCtx != null) {\n", 
            "-                targetErrorHandler.handleError(msgCtx,\n", 
            "-                        errorCode,\n", 
            "-                        \"Error connecting to the back end\",\n", 
            "-                        null,\n", 
            "-                        ProtocolState.REQUEST_READY);\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            throw new IllegalStateException(\"Queue cannot be null for: \" + key);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Notification for a connection availability. When this occurs a message in the\n", 
            "-     * queue for delivery will be tried.\n", 
            "-     *\n", 
            "-     * @param host name of the remote host\n", 
            "-     * @param port remote port number\n", 
            "-     */\n", 
            "-    public void connected(String host, int port) {\n", 
            "-        Queue<MessageContext> queue = null;\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            queue = waitingMessages.get(host + \":\" + port);\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-\n", 
            "-        while (queue.size() > 0) {\n", 
            "-            NHttpClientConnection conn = targetConnections.getConnection(host, port);\n", 
            "-            if (conn != null) {\n", 
            "-                MessageContext messageContext = queue.poll();\n", 
            "-\n", 
            "-                if (messageContext != null) {\n", 
            "-                    tryNextMessage(messageContext, conn);\n", 
            "-                }\n", 
            "-            } else {\n", 
            "-                break;\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private void tryNextMessage(MessageContext messageContext, NHttpClientConnection conn) {\n", 
            "-        if (conn != null) {\n", 
            "-            try {\n", 
            "-                TargetContext.get(conn).setRequestMsgCtx(messageContext);\n", 
            "-\n", 
            "-                submitRequest(conn, messageContext);\n", 
            "-            } catch (AxisFault e) {\n", 
            "-                log.error(\"IO error while sending the request out\", e);\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private void submitRequest(NHttpClientConnection conn, MessageContext msgContext) throws AxisFault {\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            log.debug(\"Submitting new request to the connection: \" + conn);\n", 
            "-        }\n", 
            "-\n", 
            "-        TargetRequest request = TargetRequestFactory.create(msgContext, targetConfiguration);\n", 
            "-        TargetContext.setRequest(conn, request);\n", 
            "-\n", 
            "-        Pipe pipe = (Pipe) msgContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE);\n", 
            "-        if (pipe != null) {\n", 
            "-            pipe.attachConsumer(conn);\n", 
            "-            request.connect(pipe);\n", 
            "-            if (Boolean.TRUE.equals(msgContext.getProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED))) {\n", 
            "-                synchronized (msgContext) {\n", 
            "-                    OutputStream out = pipe.getOutputStream();\n", 
            "-                    msgContext.setProperty(\"GET_ME_OUT\", out);\n", 
            "-                    msgContext.setProperty(\"READY2ROCK\", Boolean.TRUE);\n", 
            "-                    msgContext.notifyAll();\n", 
            "-                }\n", 
            "-                return;\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        conn.requestOutput();\n", 
            "-    }    \n", 
            "-\n", 
            "-    /**\n", 
            "-     * Throws an AxisFault if an error occurs at this level\n", 
            "-     * @param s a message describing the error\n", 
            "-     * @param e original exception leads to the error condition\n", 
            "-     * @throws AxisFault wrapping the original exception\n", 
            "-     */\n", 
            "-    private void handleException(String s, Exception e) throws AxisFault {\n", 
            "-        log.error(s, e);\n", 
            "-        throw new AxisFault(s, e);\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/DeliveryAgent.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/DeliveryAgent.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,175 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-package org.apache.synapse.transport.passthru.connections;\n", 
            "-\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.nio.NHttpServerConnection;\n", 
            "-import org.apache.synapse.transport.passthru.SourceContext;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-import java.util.ArrayList;\n", 
            "-import java.util.List;\n", 
            "-import java.util.concurrent.locks.Lock;\n", 
            "-import java.util.concurrent.locks.ReentrantLock;\n", 
            "-\n", 
            "-/**\n", 
            "- * Keeps track of the connections coming in to the transport.\n", 
            "- */\n", 
            "-public class SourceConnections {\n", 
            "-    private static Log log = LogFactory.getLog(SourceConnections.class);\n", 
            "-\n", 
            "-    /** The pool of connections in use */\n", 
            "-    private volatile List<NHttpServerConnection> busyConnections = new ArrayList<NHttpServerConnection>();\n", 
            "-\n", 
            "-    /** The pool of connections that are not being used */\n", 
            "-    private volatile List<NHttpServerConnection> freeConnections = new ArrayList<NHttpServerConnection>();\n", 
            "-\n", 
            "-    /** Lock for synchronizing the access to the pools */\n", 
            "-    private final Lock lock = new ReentrantLock();\n", 
            "-\n", 
            "-    /** Max free connections allowed in a given instance of time */\n", 
            "-    private int maxFreeConnections;\n", 
            "-\n", 
            "-    /** Max busy connections allowed in a given instance of time */\n", 
            "-    private int maxBusyConnections;\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Add a connection to the pool.\n", 
            "-     *\n", 
            "-     * @param conn connection to be added\n", 
            "-     */\n", 
            "-    public void addConnection(NHttpServerConnection conn) {\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            freeConnections.add(conn);\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * This method should be called when ever a connection being used for processing\n", 
            "-     * a request-response.\n", 
            "-     *\n", 
            "-     * @param conn the connection to be used\n", 
            "-     */\n", 
            "-    public void useConnection(NHttpServerConnection conn) {\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            boolean freeConnection = freeConnections.remove(conn);\n", 
            "-            if (freeConnection) {\n", 
            "-                busyConnections.add(conn);\n", 
            "-            } else {\n", 
            "-                if (busyConnections.contains(conn)) {\n", 
            "-                    throw new IllegalStateException(\"The connection is busy. \" +\n", 
            "-                            \"Cannot use it for new request\");\n", 
            "-                } else {\n", 
            "-                    throw new IllegalStateException(\"Trying to use a connection \" +\n", 
            "-                            \"which is not in free connections \" + conn);\n", 
            "-                }\n", 
            "-            }\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * This method should be called after a connection is being used for a request-response.\n", 
            "-     *\n", 
            "-     * @param conn the connection being used\n", 
            "-     */\n", 
            "-    public void releaseConnection(NHttpServerConnection conn) {\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            SourceContext.get(conn).reset();\n", 
            "-\n", 
            "-            if (busyConnections.remove(conn)) {\n", 
            "-                freeConnections.add(conn);\n", 
            "-            } else {\n", 
            "-                throw new IllegalStateException(\"Trying to finish using a connection \" +\n", 
            "-                        \"which is not in busy connections \" + conn);\n", 
            "-            }\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Shutdown a connection\n", 
            "-     *\n", 
            "-     * @param conn the connection that needs to be shut down\n", 
            "-     */\n", 
            "-    public void shutDownConnection(NHttpServerConnection conn) {\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            log.debug(\"Shutting down connection forcefully \" + conn);\n", 
            "-        }\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            SourceContext.get(conn).reset();\n", 
            "-\n", 
            "-            if (!busyConnections.remove(conn)) {\n", 
            "-                freeConnections.remove(conn);\n", 
            "-            }\n", 
            "-\n", 
            "-            try {\n", 
            "-                conn.shutdown();\n", 
            "-            } catch (IOException ignored) {\n", 
            "-            }\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Close a connection gracefully.\n", 
            "-     *\n", 
            "-     * @param conn the connection that needs to be closed.\n", 
            "-     */\n", 
            "-    public void closeConnection(NHttpServerConnection conn) {\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            log.debug(\"Shutting down connection forcefully \" + conn);\n", 
            "-        }\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            SourceContext.get(conn).reset();\n", 
            "-\n", 
            "-            if (!busyConnections.remove(conn)) {\n", 
            "-                freeConnections.remove(conn);\n", 
            "-            }\n", 
            "-\n", 
            "-            try {\n", 
            "-                conn.close();\n", 
            "-            } catch (IOException ignored) {\n", 
            "-            }\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void destroy() {\n", 
            "-        for (NHttpServerConnection conn : freeConnections) {\n", 
            "-            shutDownConnection(conn);\n", 
            "-        }\n", 
            "-\n", 
            "-        // for all the busy connections we have to notify that their cannot\n", 
            "-        // be anymore requests over them\n", 
            "-        for (NHttpServerConnection conn : busyConnections) {\n", 
            "-            SourceContext.get(conn).setShutDown(true);\n", 
            "-        }\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/SourceConnections.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/SourceConnections.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,176 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.connections;\n", 
            "-\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.nio.NHttpClientConnection;\n", 
            "-import org.apache.http.nio.reactor.ConnectingIOReactor;\n", 
            "-import org.apache.synapse.transport.passthru.ConnectCallback;\n", 
            "-import org.apache.synapse.transport.passthru.PassThroughConstants;\n", 
            "-import org.apache.synapse.transport.passthru.TargetContext;\n", 
            "-import org.apache.synapse.transport.passthru.config.TargetConfiguration;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-import java.util.Map;\n", 
            "-import java.util.concurrent.ConcurrentHashMap;\n", 
            "-import java.net.InetSocketAddress;\n", 
            "-\n", 
            "-/**\n", 
            "- * Manages the connection from transport to the back end servers. It keeps track of the\n", 
            "- * connections for host:port pair. \n", 
            "- */\n", 
            "-public class TargetConnections {\n", 
            "-    private static final Log log = LogFactory.getLog(TargetConnections.class);\n", 
            "-\n", 
            "-    /** map to hold the ConnectionPools. The key is host:port */\n", 
            "-    private final Map<String, HostConnections> poolMap =\n", 
            "-            new ConcurrentHashMap<String, HostConnections>();\n", 
            "-\n", 
            "-    /** max connections per host:port pair. At the moment all the host:ports can\n", 
            "-     * have the same max */\n", 
            "-    private int maxConnections;\n", 
            "-\n", 
            "-    /** io-reactor to use for creating connections */\n", 
            "-    private ConnectingIOReactor ioReactor;\n", 
            "-\n", 
            "-    /** callback invoked when a connection is made */\n", 
            "-    private ConnectCallback callback = null;\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Create a TargetConnections with the given IO-Reactor\n", 
            "-     *\n", 
            "-     * @param ioReactor the IO-Reactor\n", 
            "-     * @param targetConfiguration the configuration of the sender\n", 
            "-     * @param callback the callback\n", 
            "-     */\n", 
            "-    public TargetConnections(ConnectingIOReactor ioReactor,\n", 
            "-                             TargetConfiguration targetConfiguration,\n", 
            "-                             ConnectCallback callback) {\n", 
            "-\n", 
            "-        this.maxConnections = targetConfiguration.getMaxConnections();\n", 
            "-        this.ioReactor = ioReactor;\n", 
            "-        this.callback = callback;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Return a connection to the host:port pair. If a connection is not available\n", 
            "-     * return <code>null</code>. If the particular host:port allows to create more connections\n", 
            "-     * this method will try to connect asynchronously. If the connection is successful it will\n", 
            "-     * be notified in a separate thread.\n", 
            "-     *\n", 
            "-     * @param host host\n", 
            "-     * @param port port\n", 
            "-     * @return Either returns a connection if already available or returns null and notifies\n", 
            "-     *         the delivery agent when the connection is available\n", 
            "-     */\n", 
            "-    public NHttpClientConnection getConnection(String host, int port) {\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            log.debug(\"Trying to get a connection to the \" + host + \":\" + port);\n", 
            "-        }\n", 
            "-\n", 
            "-        HostConnections pool = getConnectionPool(host, port);\n", 
            "-\n", 
            "-        // trying to get an existing connection\n", 
            "-        NHttpClientConnection connection = pool.getConnection();\n", 
            "-        if (connection == null) {\n", 
            "-            if (pool.canHaveMoreConnections()) {\n", 
            "-                ioReactor.connect(new InetSocketAddress(host, port), null, pool, callback);\n", 
            "-            } else {\n", 
            "-                log.warn(\"Connection pool reached maximum allowed connections for: \"\n", 
            "-                        + host + \":\" + port + \". Target server may have become slow\");\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        return connection;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * This connection is no longer valid. So we need to shutdownConnection connection.\n", 
            "-     *\n", 
            "-     * @param conn connection to shutdownConnection\n", 
            "-     */\n", 
            "-    public void shutdownConnection(NHttpClientConnection conn) {\n", 
            "-        HostConnections pool = (HostConnections) conn.getContext().getAttribute(\n", 
            "-                PassThroughConstants.CONNECTION_POOL);\n", 
            "-\n", 
            "-        TargetContext.get(conn).reset();\n", 
            "-\n", 
            "-        if (pool != null) {\n", 
            "-            pool.forget(conn);\n", 
            "-        } else {\n", 
            "-            // we shouldn't get here\n", 
            "-            log.fatal(\"Connection without a pool. Something wrong. Need to fix.\");\n", 
            "-        }\n", 
            "-\n", 
            "-        try {\n", 
            "-            conn.shutdown();\n", 
            "-        } catch (IOException ignored) {\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Release an active connection to the pool\n", 
            "-     *\n", 
            "-     * @param conn connection to be released\n", 
            "-     */\n", 
            "-    public void releaseConnection(NHttpClientConnection conn) {\n", 
            "-        HostConnections pool = (HostConnections) conn.getContext().getAttribute(\n", 
            "-                PassThroughConstants.CONNECTION_POOL);\n", 
            "-\n", 
            "-        TargetContext.get(conn).reset();\n", 
            "-\n", 
            "-        if (pool != null) {\n", 
            "-            pool.release(conn);\n", 
            "-        } else {\n", 
            "-            // we shouldn't get here\n", 
            "-            log.fatal(\"Connection without a pool. Something wrong. Need to fix.\");\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * This method is called when a new connection is made.\n", 
            "-     *\n", 
            "-     * @param conn connection to the target server     \n", 
            "-     */\n", 
            "-    public void addConnection(NHttpClientConnection conn) {\n", 
            "-        HostConnections pool = (HostConnections) conn.getContext().getAttribute(\n", 
            "-                PassThroughConstants.CONNECTION_POOL);\n", 
            "-        if (pool != null) {\n", 
            "-            pool.addConnection(conn);\n", 
            "-        } else {\n", 
            "-            // we shouldn't get here\n", 
            "-            log.fatal(\"Connection without a pool. Something wrong. Need to fix.\");            \n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private HostConnections getConnectionPool(String host, int port) {\n", 
            "-        String key = host + \":\" + port;\n", 
            "-        // see weather a pool already exists for this host:port\n", 
            "-        HostConnections pool = poolMap.get(key);\n", 
            "-        synchronized (poolMap) {\n", 
            "-            if (pool == null) {\n", 
            "-                pool = new HostConnections(host, port, maxConnections);\n", 
            "-                poolMap.put(key, pool);\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        return pool;\n", 
            "-    }\n", 
            "-\n", 
            "-\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/TargetConnections.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/TargetConnections.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,160 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.connections;\n", 
            "-\n", 
            "-import org.apache.http.nio.NHttpClientConnection;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.protocol.ExecutionContext;\n", 
            "-import org.apache.http.protocol.HttpContext;\n", 
            "-\n", 
            "-import java.util.List;\n", 
            "-import java.util.ArrayList;\n", 
            "-import java.util.concurrent.locks.Lock;\n", 
            "-import java.util.concurrent.locks.ReentrantLock;\n", 
            "-\n", 
            "-/**\n", 
            "- * This stores connections for a particular host + port.\n", 
            "- */\n", 
            "-public class HostConnections {\n", 
            "-    private static final Log log = LogFactory.getLog(HostConnections.class);\n", 
            "-    // host\n", 
            "-    private String host;\n", 
            "-    // port\n", 
            "-    private int port;\n", 
            "-    // maximum number of connections allowed for this host + port\n", 
            "-    private int maxSize;\n", 
            "-    // number of awaiting connections\n", 
            "-    private int pendingConnections;\n", 
            "-    // list of free connections available\n", 
            "-    private List<NHttpClientConnection> freeConnections = new ArrayList<NHttpClientConnection>();\n", 
            "-    // list of connections in use\n", 
            "-    private List<NHttpClientConnection> busyConnections = new ArrayList<NHttpClientConnection>();\n", 
            "-\n", 
            "-    private Lock lock = new ReentrantLock();\n", 
            "-\n", 
            "-    public HostConnections(String host, int port, int maxSize) {\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            log.debug(\"Creating new connection pool to the host: \" + host + \", port: \" + port);\n", 
            "-        }\n", 
            "-        this.host = host;\n", 
            "-        this.port = port;\n", 
            "-        this.maxSize = maxSize;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Get a connection for the host:port\n", 
            "-     *\n", 
            "-     * @return a connection\n", 
            "-     */\n", 
            "-    public NHttpClientConnection getConnection() {\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            if (freeConnections.size() > 0) {\n", 
            "-                if (log.isDebugEnabled()) {\n", 
            "-                    log.debug(\"Returning an existing free connection to \" + host + \":\" + port);\n", 
            "-                }\n", 
            "-                NHttpClientConnection conn = freeConnections.get(0);\n", 
            "-                freeConnections.remove(conn);\n", 
            "-                busyConnections.add(conn);\n", 
            "-                return conn;\n", 
            "-            }\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void release(NHttpClientConnection conn) {\n", 
            "-        conn.getMetrics().reset();\n", 
            "-        HttpContext ctx = conn.getContext();\n", 
            "-        ctx.removeAttribute(ExecutionContext.HTTP_REQUEST);\n", 
            "-        ctx.removeAttribute(ExecutionContext.HTTP_RESPONSE);\n", 
            "-\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            if (busyConnections.remove(conn)) {\n", 
            "-                freeConnections.add(conn);\n", 
            "-            } else {\n", 
            "-                log.error(\"Attempted to releaseConnection connection not in the busy list\");\n", 
            "-            }\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void forget(NHttpClientConnection conn) {\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            if (!freeConnections.remove(conn)) {\n", 
            "-                busyConnections.remove(conn);\n", 
            "-            }\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void addConnection(NHttpClientConnection conn) {\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            log.debug(\"New connection to \" + host + \":\" + port + \" is added to the free list\");\n", 
            "-        }\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            freeConnections.add(conn);\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Indicates that a connection has been successfully established with a remote server\n", 
            "-     * as notified by the session request call back.\n", 
            "-     */\n", 
            "-    public synchronized void pendingConnectionSucceeded() {\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            pendingConnections--;\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Keep track of the number of times connections to this host:port has failed\n", 
            "-     * consecutively\n", 
            "-     */\n", 
            "-    public void pendingConnectionFailed() {\n", 
            "-        lock.lock();\n", 
            "-        try {\n", 
            "-            pendingConnections--;\n", 
            "-        } finally {\n", 
            "-            lock.unlock();\n", 
            "-        }\n", 
            "-    }    \n", 
            "-\n", 
            "-    public String getHost() {\n", 
            "-        return host;\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getPort() {\n", 
            "-        return port;\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean canHaveMoreConnections() {\n", 
            "-        return busyConnections.size() + pendingConnections < maxSize;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/HostConnections.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/HostConnections.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,92 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-public class PassThroughConstants {\n", 
            "-\n", 
            "-    public static final int DEFAULT_IO_THREAD_COUNT = Runtime.getRuntime().availableProcessors();\n", 
            "-    public static final int DEFAULT_MAX_CONN_PER_HOST_PORT = Integer.MAX_VALUE;\n", 
            "-    \n", 
            "-    public static final String REQUEST_MESSAGE_CONTEXT = \"REQUEST_MESSAGE_CONTEXT\";\n", 
            "-    public static final String CONNECTION_POOL = \"CONNECTION_POOL\";\n", 
            "-\n", 
            "-    public static final String TRUE = \"TRUE\";\n", 
            "-\n", 
            "-    public static final String FAULT_MESSAGE = \"FAULT_MESSAGE\"; // corresponds with BaseConstants\n", 
            "-    public static final String FAULTS_AS_HTTP_200 = \"FAULTS_AS_HTTP_200\";\n", 
            "-    public static final String SC_ACCEPTED = \"SC_ACCEPTED\";\n", 
            "-    public static final String HTTP_SC = \"HTTP_SC\";\n", 
            "-    public static final String FORCE_HTTP_1_0 = \"FORCE_HTTP_1.0\";\n", 
            "-    public static final String DISABLE_CHUNKING = \"DISABLE_CHUNKING\";\n", 
            "-    public static final String FULL_URI = \"FULL_URI\";\n", 
            "-    public static final String NO_KEEPALIVE = \"NO_KEEPALIVE\";\n", 
            "-    public static final String DISABLE_KEEPALIVE = \"http.connection.disable.keepalive\";\n", 
            "-    public static final String IGNORE_SC_ACCEPTED = \"IGNORE_SC_ACCEPTED\";\n", 
            "-    public static final String FORCE_SC_ACCEPTED = \"FORCE_SC_ACCEPTED\";\n", 
            "-    public static final String DISCARD_ON_COMPLETE = \"DISCARD_ON_COMPLETE\";\n", 
            "-\n", 
            "-    public static final String SERVICE_URI_LOCATION = \"ServiceURI\";\n", 
            "-\n", 
            "-    public static final String WSDL_EPR_PREFIX = \"WSDLEPRPrefix\";\n", 
            "-\n", 
            "-    public static final String EPR_TO_SERVICE_NAME_MAP = \"service.epr.map\";\n", 
            "-    public static final String NON_BLOCKING_TRANSPORT = \"NonBlockingTransport\";\n", 
            "-    public static final String SERIALIZED_BYTES = \"SerializedBytes\";\n", 
            "-\n", 
            "-    public static final String CONTENT_TYPE = \"CONTENT_TYPE\";\n", 
            "-\n", 
            "-    public static final String DEFAULT_CONTENT_TYPE = \"application/octet-stream\";\n", 
            "-\n", 
            "-    public static final String HIDDEN_SERVICE_PARAM_NAME = \"hiddenService\";\n", 
            "-\n", 
            "-    /** An Axis2 message context property indicating a transport send failure */\n", 
            "-    public static final String SENDING_FAULT = \"SENDING_FAULT\";\n", 
            "-    /** The message context property name which holds the error code for the last encountered exception */\n", 
            "-    public static final String ERROR_CODE = \"ERROR_CODE\";\n", 
            "-    /** The MC property name which holds the error message for the last encountered exception */\n", 
            "-    public static final String ERROR_MESSAGE = \"ERROR_MESSAGE\";\n", 
            "-    /** The message context property name which holds the error detail (stack trace) for the last encountered exception */\n", 
            "-    public static final String ERROR_DETAIL = \"ERROR_DETAIL\";\n", 
            "-    /** The message context property name which holds the exception (if any) for the last encountered exception */\n", 
            "-    public static final String ERROR_EXCEPTION = \"ERROR_EXCEPTION\";\n", 
            "-\n", 
            "-    // ********** DO NOT CHANGE THESE UNLESS CORRESPONDING SYNAPSE CONSTANT ARE CHANGED ************\n", 
            "-\n", 
            "-    public static final String REST_URL_POSTFIX = \"REST_URL_POSTFIX\";\n", 
            "-    public static final String SERVICE_PREFIX = \"SERVICE_PREFIX\";\n", 
            "-    public static final String NO_ENTITY_BODY = \"NO_ENTITY_BODY\";\n", 
            "-\n", 
            "-    protected static final String PASS_THROUGH_TRANSPORT_WORKER_POOL =\n", 
            "-            \"PASS_THROUGH_TRANSPORT_WORKER_POOL\";\n", 
            "-    protected static final String PASS_THROUGH_SOURCE_CONFIGURATION =\n", 
            "-            \"PASS_THROUGH_SOURCE_CONFIGURATION\";\n", 
            "-    protected static final String PASS_THROUGH_SOURCE_CONNECTION = \"pass-through.Source-Connection\";\n", 
            "-    protected static final String PASS_THROUGH_SOURCE_REQUEST = \"pass-through.Source-Request\";\n", 
            "-\n", 
            "-    protected static final String PASS_THROUGH_TARGET_CONNECTION = \"pass-through.Target-Connection\";\n", 
            "-    protected static final String PASS_THROUGH_TARGET_RESPONSE = \"pass-through.Target-Response\";\n", 
            "-\n", 
            "-    public static final String PASS_THROUGH_PIPE = \"pass-through.pipe\";\n", 
            "-\n", 
            "-    // used to define the default content type as a parameter in the axis2.xml\n", 
            "-    public static final String REQUEST_CONTENT_TYPE = \"DEFAULT_REQUEST_CONTENT_TYPE\";\n", 
            "-\n", 
            "-    // This is a workaround  for  axis2 RestUtils behaviour\n", 
            "-    public static final String REST_REQUEST_CONTENT_TYPE = \"synapse.internal.rest.contentType\";\n", 
            "-\n", 
            "-    public static final String MESSAGE_BUILDER_INVOKED = \"message.builder.invoked\";\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,202 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.http.nio.NHttpConnection;\n", 
            "-import org.apache.synapse.transport.passthru.config.SourceConfiguration;\n", 
            "-\n", 
            "-import java.nio.ByteBuffer;\n", 
            "-import java.util.concurrent.locks.Lock;\n", 
            "-import java.util.concurrent.locks.ReentrantLock;\n", 
            "-\n", 
            "-/**\n", 
            "- * This class represents the information about a TCP Connection at a given point in time.\n", 
            "- * In a Single TCP Connection there can be multiple HTTP Requests.\n", 
            "- */\n", 
            "-public class SourceContext {\n", 
            "-    public static final String CONNECTION_INFORMATION = \"CONNECTION_INFORMATION\";\n", 
            "-\n", 
            "-    private SourceConfiguration sourceConfiguration;\n", 
            "-\n", 
            "-    private ProtocolState state = ProtocolState.REQUEST_READY;\n", 
            "-\n", 
            "-    private SourceRequest request;\n", 
            "-\n", 
            "-    private SourceResponse response;\n", 
            "-\n", 
            "-    /** Mark the connection to be shut down after the current request-response is completed. */\n", 
            "-    private boolean shutDown = false;\n", 
            "-\n", 
            "-    private Pipe reader;\n", 
            "-\n", 
            "-    private Pipe writer;\n", 
            "-\n", 
            "-    private Lock lock = new ReentrantLock();\n", 
            "-\n", 
            "-    public SourceContext(SourceConfiguration sourceConfiguration) {\n", 
            "-        this.sourceConfiguration = sourceConfiguration;\n", 
            "-    }\n", 
            "-\n", 
            "-    public ProtocolState getState() {\n", 
            "-        return state;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setState(ProtocolState state) {\n", 
            "-        this.state = state;\n", 
            "-    }\n", 
            "-\n", 
            "-    public SourceRequest getRequest() {\n", 
            "-        return request;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setRequest(SourceRequest request) {\n", 
            "-        this.request = request;\n", 
            "-    }\n", 
            "-\n", 
            "-    public SourceResponse getResponse() {\n", 
            "-        return response;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setResponse(SourceResponse response) {\n", 
            "-        this.response = response;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void reset() {\n", 
            "-        this.request = null;\n", 
            "-        this.response = null;\n", 
            "-        this.state = ProtocolState.REQUEST_READY;\n", 
            "-\n", 
            "-        if (writer != null) {\n", 
            "-            ByteBuffer buffer = writer.getBuffer();\n", 
            "-            buffer.clear();\n", 
            "-            sourceConfiguration.getBufferFactory().release(buffer);\n", 
            "-        }\n", 
            "-\n", 
            "-        this.reader = null;\n", 
            "-        this.writer = null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public Lock getLock() {\n", 
            "-        return lock;\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean isShutDown() {\n", 
            "-        return shutDown;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setShutDown(boolean shutDown) {\n", 
            "-        this.shutDown = shutDown;\n", 
            "-    }\n", 
            "-\n", 
            "-    public Pipe getReader() {\n", 
            "-        return reader;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setReader(Pipe reader) {\n", 
            "-        this.reader = reader;\n", 
            "-    }\n", 
            "-\n", 
            "-    public Pipe getWriter() {\n", 
            "-        return writer;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setWriter(Pipe writer) {\n", 
            "-        this.writer = writer;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static void create(NHttpConnection conn, ProtocolState state,\n", 
            "-                              SourceConfiguration configuration) {\n", 
            "-        SourceContext info = new SourceContext(configuration);\n", 
            "-\n", 
            "-        conn.getContext().setAttribute(CONNECTION_INFORMATION, info);\n", 
            "-\n", 
            "-        info.setState(state);\n", 
            "-    }\n", 
            "-\n", 
            "-    public static void updateState(NHttpConnection conn, ProtocolState state) {\n", 
            "-        SourceContext info = (SourceContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        if (info != null) {\n", 
            "-            info.setState(state);\n", 
            "-        }  else {\n", 
            "-            throw new IllegalStateException(\"Connection information should be present\");\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public static boolean assertState(NHttpConnection conn, ProtocolState state) {\n", 
            "-        SourceContext info = (SourceContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        return info != null && info.getState() == state;\n", 
            "-\n", 
            "-    }\n", 
            "-\n", 
            "-    public static ProtocolState getState(NHttpConnection conn) {\n", 
            "-        SourceContext info = (SourceContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        return info != null ? info.getState() : null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static void setRequest(NHttpConnection conn, SourceRequest request) {\n", 
            "-        SourceContext info = (SourceContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        if (info != null) {\n", 
            "-            info.setRequest(request);\n", 
            "-        } else {\n", 
            "-            throw new IllegalStateException(\"Connection information should be present\");\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public static void setResponse(NHttpConnection conn, SourceResponse response) {\n", 
            "-        SourceContext info = (SourceContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        if (info != null) {\n", 
            "-            info.setResponse(response);\n", 
            "-        } else {\n", 
            "-            throw new IllegalStateException(\"Connection information should be present\");\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public static SourceRequest getRequest(NHttpConnection conn) {\n", 
            "-        SourceContext info = (SourceContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        return info != null ? info.getRequest() : null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static SourceResponse getResponse(NHttpConnection conn) {\n", 
            "-        SourceContext info = (SourceContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        return info != null ? info.getResponse() : null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static SourceContext get(NHttpConnection conn) {\n", 
            "-        return (SourceContext) conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-    }\n", 
            "-\n", 
            "-    public static Lock getLock(NHttpConnection conn) {\n", 
            "-        SourceContext info = (SourceContext)\n", 
            "-                conn.getContext().getAttribute(CONNECTION_INFORMATION);\n", 
            "-\n", 
            "-        return info != null ? info.getLock() : null;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceContext.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceContext.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,175 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.http.*;\n", 
            "-import org.apache.http.entity.BasicHttpEntity;\n", 
            "-import org.apache.http.impl.DefaultConnectionReuseStrategy;\n", 
            "-import org.apache.http.nio.ContentDecoder;\n", 
            "-import org.apache.http.nio.NHttpClientConnection;\n", 
            "-import org.apache.synapse.transport.passthru.config.TargetConfiguration;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-import java.util.HashMap;\n", 
            "-import java.util.Map;\n", 
            "-\n", 
            "-/**\n", 
            "- * This class represents a response coming from the target server.\n", 
            "- */\n", 
            "-public class TargetResponse {\n", 
            "-    // private Log log = LogFactory.getLog(TargetResponse.class);\n", 
            "-    /** To pipe the incoming data through */\n", 
            "-    private Pipe pipe = null;\n", 
            "-    /** Headers of the response */\n", 
            "-    private Map<String, String> headers = new HashMap<String, String>();\n", 
            "-    /** The status of the response */\n", 
            "-    private int status = HttpStatus.SC_OK;\n", 
            "-    /** Http status line */\n", 
            "-    private String statusLine = \"OK\";\n", 
            "-    /** The Http response */\n", 
            "-    private HttpResponse response = null;\n", 
            "-    /** Configuration of the sender */\n", 
            "-    private TargetConfiguration targetConfiguration;\n", 
            "-    /** Protocol version */\n", 
            "-    private ProtocolVersion version = HttpVersion.HTTP_1_1;\n", 
            "-    /** This utility class is used for determining weather we need to close the connection\n", 
            "-     * after submitting the response */\n", 
            "-    private ConnectionReuseStrategy connStrategy = new DefaultConnectionReuseStrategy();\n", 
            "-    /** The connection */\n", 
            "-    private NHttpClientConnection connection;\n", 
            "-    /** Weather this response has a body */\n", 
            "-    private boolean expectResponseBody = true;\n", 
            "-\n", 
            "-    public TargetResponse(TargetConfiguration targetConfiguration,\n", 
            "-                          HttpResponse response,\n", 
            "-                          NHttpClientConnection conn,\n", 
            "-                          boolean expectResponseBody) {\n", 
            "-        this.targetConfiguration = targetConfiguration;\n", 
            "-        this.response = response;\n", 
            "-        this.connection = conn;\n", 
            "-\n", 
            "-        this.version = response.getProtocolVersion();\n", 
            "-\n", 
            "-        this.status = response.getStatusLine().getStatusCode();\n", 
            "-        this.statusLine = response.getStatusLine().getReasonPhrase();\n", 
            "-\n", 
            "-        Header[] headers = response.getAllHeaders();\n", 
            "-        if (headers != null) {\n", 
            "-            for (Header header : headers) {\n", 
            "-                this.headers.put(header.getName(), header.getValue());\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        this.expectResponseBody = expectResponseBody;\n", 
            "-    }    \n", 
            "-\n", 
            "-    /**\n", 
            "-     * Starts the response\n", 
            "-     * @param conn the client connection\n", 
            "-     */\n", 
            "-    public void start(NHttpClientConnection conn) {\n", 
            "-        TargetContext.updateState(conn, ProtocolState.RESPONSE_HEAD);\n", 
            "-        \n", 
            "-        if (expectResponseBody) {\n", 
            "-            pipe\n", 
            "-                = new Pipe(conn, targetConfiguration.getBufferFactory().getBuffer(), \"target\", targetConfiguration);\n", 
            "-\n", 
            "-            TargetContext.get(conn).setReader(pipe);\n", 
            "-\n", 
            "-            BasicHttpEntity entity = new BasicHttpEntity();\n", 
            "-            if (response.getStatusLine().getProtocolVersion().greaterEquals(HttpVersion.HTTP_1_1)) {\n", 
            "-                entity.setChunked(true);\n", 
            "-            }\n", 
            "-            response.setEntity(entity);\n", 
            "-        } else {            \n", 
            "-            if (!connStrategy.keepAlive(response, conn.getContext())) {\n", 
            "-                try {\n", 
            "-                    // this is a connection we should not re-use\n", 
            "-                    TargetContext.updateState(conn, ProtocolState.CLOSING);\n", 
            "-                    targetConfiguration.getConnections().releaseConnection(conn);\n", 
            "-                    \n", 
            "-                    conn.close();\n", 
            "-                } catch (Exception ignore) {\n", 
            "-\n", 
            "-                }\n", 
            "-            } else {\n", 
            "-                targetConfiguration.getConnections().releaseConnection(conn);\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Read the data from the wire and read in to the pipe so that other end of\n", 
            "-     * the pipe can write.\n", 
            "-     * @param conn the target connection\n", 
            "-     * @param decoder content decoder\n", 
            "-     * @throws java.io.IOException if an error occurs\n", 
            "-     * @return number of bites read\n", 
            "-     */\n", 
            "-    public int read(NHttpClientConnection conn, ContentDecoder decoder) throws IOException {\n", 
            "-        int bytes = pipe.produce(decoder);\n", 
            "-\n", 
            "-        // Update connection state\n", 
            "-        if (decoder.isCompleted()) {\n", 
            "-            TargetContext.updateState(conn, ProtocolState.RESPONSE_DONE);\n", 
            "-\n", 
            "-            targetConfiguration.getMetrics().notifyReceivedMessageSize(\n", 
            "-                    conn.getMetrics().getReceivedBytesCount());\n", 
            "-\n", 
            "-            if (!this.connStrategy.keepAlive(response, conn.getContext())) {\n", 
            "-                TargetContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-\n", 
            "-                targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-            } else {\n", 
            "-                targetConfiguration.getConnections().releaseConnection(conn);\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return bytes;\n", 
            "-    }\n", 
            "-\n", 
            "-    public String getHeader(String name) {\n", 
            "-        return headers.get(name);\n", 
            "-    }\n", 
            "-\n", 
            "-    public Map<String, String> getHeaders() {\n", 
            "-        return headers;\n", 
            "-    }\n", 
            "-\n", 
            "-    public Pipe getPipe() {\n", 
            "-        return pipe;\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getStatus() {\n", 
            "-        return status;\n", 
            "-    }\n", 
            "-\n", 
            "-    public String getStatusLine() {\n", 
            "-        return statusLine;\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean isExpectResponseBody() {\n", 
            "-        return expectResponseBody;\n", 
            "-    }\n", 
            "-\n", 
            "-    public NHttpClientConnection getConnection() {\n", 
            "-        return connection;\n", 
            "-    }\n", 
            "-\n", 
            "-    public ProtocolVersion getVersion() {\n", 
            "-        return version;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetResponse.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetResponse.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,90 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.http.nio.reactor.SessionRequestCallback;\n", 
            "-import org.apache.http.nio.reactor.SessionRequest;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.synapse.transport.passthru.connections.HostConnections;\n", 
            "-\n", 
            "-public class ConnectCallback implements SessionRequestCallback {\n", 
            "-\n", 
            "-    private static Log log = LogFactory.getLog(ConnectCallback.class);     \n", 
            "-\n", 
            "-    /** The agent used for delivering requests */\n", 
            "-    private DeliveryAgent deliveryAgent;\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Create the callback for the handling events on a given connection     \n", 
            "-     */\n", 
            "-    public ConnectCallback() {\n", 
            "-\n", 
            "-    }\n", 
            "-\n", 
            "-    public void completed(SessionRequest request) {\n", 
            "-        HostConnections pool = (HostConnections) request.getAttachment();\n", 
            "-        pool.pendingConnectionSucceeded();\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            if (request.getSession() != null &&\n", 
            "-                    request.getSession().getLocalAddress() != null) {\n", 
            "-                log.debug(\"Connected to remote address: \" +\n", 
            "-                        request.getSession().getRemoteAddress() +\n", 
            "-                        \" from local address: \" + request.getSession().getLocalAddress());\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void failed(SessionRequest request) {\n", 
            "-        HostConnections pool = (HostConnections) request.getAttachment();\n", 
            "-        pool.pendingConnectionFailed();\n", 
            "-\n", 
            "-        deliveryAgent.errorConnecting(pool.getHost(), pool.getPort(),\n", 
            "-                ErrorCodes.CONNECTION_FAILED, \"Connection Failed\");\n", 
            "-\n", 
            "-        handleError(\"Connection refused or failed for : \" + request.getRemoteAddress());\n", 
            "-    }\n", 
            "-\n", 
            "-    public void timeout(SessionRequest request) {\n", 
            "-        HostConnections pool = (HostConnections) request.getAttachment();\n", 
            "-        pool.pendingConnectionFailed();\n", 
            "-\n", 
            "-        deliveryAgent.errorConnecting(pool.getHost(), pool.getPort(),\n", 
            "-                ErrorCodes.CONNECT_TIMEOUT, \"Connection Timeout\");\n", 
            "-\n", 
            "-        handleError(\"Timeout connecting to : \" + request.getRemoteAddress());\n", 
            "-        request.cancel();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void cancelled(SessionRequest request) {\n", 
            "-        HostConnections pool = (HostConnections) request.getAttachment();\n", 
            "-        pool.pendingConnectionFailed();\n", 
            "-\n", 
            "-        deliveryAgent.errorConnecting(pool.getHost(), pool.getPort(),\n", 
            "-                ErrorCodes.CONNECT_CANCEL, \"Connection Cancel\");\n", 
            "-\n", 
            "-        handleError(\"Connection cancelled for : \" + request.getRemoteAddress());\n", 
            "-    }\n", 
            "-\n", 
            "-    private void handleError(String errorMessage) {\n", 
            "-        log.warn(errorMessage);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setDeliveryAgent(DeliveryAgent deliveryAgent) {\n", 
            "-        this.deliveryAgent = deliveryAgent;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ConnectCallback.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ConnectCallback.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,157 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.logging;\n", 
            "-\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.http.nio.reactor.IOSession;\n", 
            "-import org.apache.http.nio.reactor.SessionOutputBuffer;\n", 
            "-import org.apache.http.nio.reactor.SessionInputBuffer;\n", 
            "-import org.apache.http.nio.util.ByteBufferAllocator;\n", 
            "-import org.apache.http.nio.NHttpClientHandler;\n", 
            "-import org.apache.http.nio.NHttpMessageWriter;\n", 
            "-import org.apache.http.nio.NHttpMessageParser;\n", 
            "-import org.apache.http.*;\n", 
            "-import org.apache.http.impl.nio.DefaultNHttpClientConnection;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-import java.nio.channels.ReadableByteChannel;\n", 
            "-\n", 
            "-public class LoggingNHttpTargetConnection extends DefaultNHttpClientConnection {\n", 
            "-    private final Log log;\n", 
            "-    private final Log headerLog;\n", 
            "-\n", 
            "-    public LoggingNHttpTargetConnection(\n", 
            "-            final Log log,\n", 
            "-            final Log headerlog,\n", 
            "-            final IOSession iosession,\n", 
            "-            final HttpResponseFactory responseFactory,\n", 
            "-            final ByteBufferAllocator allocator,\n", 
            "-            final HttpParams params) {\n", 
            "-        super(iosession, responseFactory, allocator, params);\n", 
            "-        this.log = log;\n", 
            "-        this.headerLog = headerlog;\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void close() throws IOException {\n", 
            "-        this.log.debug(\"Close connection\");\n", 
            "-        super.close();\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void shutdown() throws IOException {\n", 
            "-        this.log.debug(\"Shutdown connection\");\n", 
            "-        super.shutdown();\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void submitRequest(final HttpRequest request) throws IOException, HttpException {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + this + \": \"  + request.getRequestLine().toString());\n", 
            "-        }\n", 
            "-        super.submitRequest(request);\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void consumeInput(final NHttpClientHandler handler) {\n", 
            "-        this.log.debug(\"Consume input\");\n", 
            "-        super.consumeInput(handler);\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void produceOutput(final NHttpClientHandler handler) {\n", 
            "-        this.log.debug(\"Produce output\");\n", 
            "-        super.produceOutput(handler);\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    protected NHttpMessageWriter createRequestWriter(\n", 
            "-            final SessionOutputBuffer buffer,\n", 
            "-            final HttpParams params) {\n", 
            "-        return new LoggingNHttpMessageWriter(\n", 
            "-                super.createRequestWriter(buffer, params));\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    protected NHttpMessageParser createResponseParser(\n", 
            "-            final SessionInputBuffer buffer,\n", 
            "-            final HttpResponseFactory responseFactory,\n", 
            "-            final HttpParams params) {\n", 
            "-        return new LoggingNHttpMessageParser(\n", 
            "-                super.createResponseParser(buffer, responseFactory, params));\n", 
            "-    }\n", 
            "-\n", 
            "-    class LoggingNHttpMessageWriter implements NHttpMessageWriter {\n", 
            "-\n", 
            "-        private final NHttpMessageWriter writer;\n", 
            "-\n", 
            "-        public LoggingNHttpMessageWriter(final NHttpMessageWriter writer) {\n", 
            "-            super();\n", 
            "-            this.writer = writer;\n", 
            "-        }\n", 
            "-\n", 
            "-        public void reset() {\n", 
            "-            this.writer.reset();\n", 
            "-        }\n", 
            "-\n", 
            "-        public void write(final HttpMessage message) throws IOException, HttpException {\n", 
            "-            if (message != null && headerLog.isDebugEnabled()) {\n", 
            "-                HttpRequest request = (HttpRequest) message;\n", 
            "-                headerLog.debug(\">> \" + request.getRequestLine().toString());\n", 
            "-                Header[] headers = request.getAllHeaders();\n", 
            "-                for (Header header : headers) {\n", 
            "-                    headerLog.debug(\">> \" + header.toString());\n", 
            "-                }\n", 
            "-            }\n", 
            "-            this.writer.write(message);\n", 
            "-        }\n", 
            "-\n", 
            "-    }\n", 
            "-\n", 
            "-    class LoggingNHttpMessageParser implements NHttpMessageParser {\n", 
            "-\n", 
            "-        private final NHttpMessageParser parser;\n", 
            "-\n", 
            "-        public LoggingNHttpMessageParser(final NHttpMessageParser parser) {\n", 
            "-            super();\n", 
            "-            this.parser = parser;\n", 
            "-        }\n", 
            "-\n", 
            "-        public void reset() {\n", 
            "-            this.parser.reset();\n", 
            "-        }\n", 
            "-\n", 
            "-        public int fillBuffer(final ReadableByteChannel channel) throws IOException {\n", 
            "-            return this.parser.fillBuffer(channel);\n", 
            "-        }\n", 
            "-\n", 
            "-        public HttpMessage parse() throws IOException, HttpException {\n", 
            "-            HttpMessage message = this.parser.parse();\n", 
            "-            if (message != null && headerLog.isDebugEnabled()) {\n", 
            "-                HttpResponse response = (HttpResponse) message;\n", 
            "-                headerLog.debug(\"<< \" + response.getStatusLine().toString());\n", 
            "-                Header[] headers = response.getAllHeaders();\n", 
            "-                for (Header header : headers) {\n", 
            "-                    headerLog.debug(\"<< \" + header.toString());\n", 
            "-                }\n", 
            "-            }\n", 
            "-            return message;\n", 
            "-        }\n", 
            "-\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpTargetConnection.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpTargetConnection.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,120 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.logging;\n", 
            "-\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.nio.NHttpClientHandler;\n", 
            "-import org.apache.http.nio.NHttpClientConnection;\n", 
            "-import org.apache.http.nio.ContentEncoder;\n", 
            "-import org.apache.http.nio.ContentDecoder;\n", 
            "-import org.apache.http.HttpException;\n", 
            "-import org.apache.http.HttpResponse;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-\n", 
            "-public class LoggingTargetHandler implements NHttpClientHandler {\n", 
            "-\n", 
            "-    private final Log log;\n", 
            "-    \n", 
            "-    private final NHttpClientHandler handler;\n", 
            "-\n", 
            "-    public LoggingTargetHandler(final NHttpClientHandler handler) {\n", 
            "-        super();\n", 
            "-        if (handler == null) {\n", 
            "-            throw new IllegalArgumentException(\"HTTP client handler may not be null\");\n", 
            "-        }\n", 
            "-        this.handler = handler;\n", 
            "-        this.log = LogFactory.getLog(handler.getClass());\n", 
            "-    }\n", 
            "-\n", 
            "-    public void connected(final NHttpClientConnection conn, final Object attachment) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Connected (\" + attachment + \")\");\n", 
            "-        }\n", 
            "-        this.handler.connected(conn, attachment);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void closed(final NHttpClientConnection conn) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Closed\");\n", 
            "-        }\n", 
            "-        this.handler.closed(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void exception(final NHttpClientConnection conn, final IOException ex) {\n", 
            "-        this.log.error(\"HTTP connection \" + conn + \": \" + ex.getMessage(), ex);\n", 
            "-        this.handler.exception(conn, ex);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void exception(final NHttpClientConnection conn, final HttpException ex) {\n", 
            "-        this.log.error(\"HTTP connection \" + conn + \": \" + ex.getMessage(), ex);\n", 
            "-        this.handler.exception(conn, ex);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void requestReady(final NHttpClientConnection conn) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": InRequest ready\" + getRequestMessageID(conn));\n", 
            "-        }\n", 
            "-        this.handler.requestReady(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Output ready\" + getRequestMessageID(conn));\n", 
            "-        }\n", 
            "-        this.handler.outputReady(conn, encoder);\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Content encoder \" + encoder);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void responseReceived(final NHttpClientConnection conn) {\n", 
            "-        HttpResponse response = conn.getHttpResponse();\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \" : \"\n", 
            "-                    + response.getStatusLine() + getRequestMessageID(conn));\n", 
            "-        }\n", 
            "-        this.handler.responseReceived(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Input ready\" + getRequestMessageID(conn));\n", 
            "-        }\n", 
            "-        this.handler.inputReady(conn, decoder);\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Content decoder \" + decoder);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void timeout(final NHttpClientConnection conn) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Timeout\" + getRequestMessageID(conn));\n", 
            "-        }\n", 
            "-        this.handler.timeout(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    private static String getRequestMessageID(final NHttpClientConnection conn) {\n", 
            "-        /*Axis2HttpRequest axis2Request = (Axis2HttpRequest)\n", 
            "-                conn.getContext().getAttribute(ClientHandler.AXIS2_HTTP_REQUEST);\n", 
            "-        if (axis2Request != null) {\n", 
            "-            return \" [InRequest Message ID : \" + axis2Request.getMsgContext().getMessageID() + \"]\";\n", 
            "-        }*/        \n", 
            "-        return \"\";\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingTargetHandler.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingTargetHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,225 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.logging;\n", 
            "-\n", 
            "-import org.apache.http.nio.reactor.IOSession;\n", 
            "-import org.apache.http.nio.reactor.SessionBufferStatus;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-\n", 
            "-import java.util.concurrent.atomic.AtomicLong;\n", 
            "-import java.nio.channels.ByteChannel;\n", 
            "-import java.nio.channels.SelectionKey;\n", 
            "-import java.nio.ByteBuffer;\n", 
            "-import java.net.SocketAddress;\n", 
            "-import java.io.IOException;\n", 
            "-\n", 
            "-class LoggingIOSession implements IOSession {\n", 
            "-\n", 
            "-    private static AtomicLong COUNT = new AtomicLong(0);\n", 
            "-\n", 
            "-    private final Log log;\n", 
            "-    private final Wire wirelog;\n", 
            "-    private final IOSession session;\n", 
            "-    private final ByteChannel channel;\n", 
            "-    private final String id;\n", 
            "-\n", 
            "-    public LoggingIOSession(            \n", 
            "-            final Log wirelog,\n", 
            "-            final IOSession session,\n", 
            "-            final String id) {\n", 
            "-        super();\n", 
            "-        if (session == null) {\n", 
            "-            throw new IllegalArgumentException(\"I/O session may not be null\");\n", 
            "-        }\n", 
            "-        this.session = session;\n", 
            "-        this.channel = new LoggingByteChannel();\n", 
            "-        this.id = id + \"-\" + COUNT.incrementAndGet();\n", 
            "-        this.log = LogFactory.getLog(session.getClass());\n", 
            "-        this.wirelog = new Wire(wirelog);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getStatus() {\n", 
            "-        return this.session.getStatus();\n", 
            "-    }\n", 
            "-\n", 
            "-    public ByteChannel channel() {\n", 
            "-        return this.channel;\n", 
            "-    }\n", 
            "-\n", 
            "-    public SocketAddress getLocalAddress() {\n", 
            "-        return this.session.getLocalAddress();\n", 
            "-    }\n", 
            "-\n", 
            "-    public SocketAddress getRemoteAddress() {\n", 
            "-        return this.session.getRemoteAddress();\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getEventMask() {\n", 
            "-        return this.session.getEventMask();\n", 
            "-    }\n", 
            "-\n", 
            "-    private static String formatOps(int ops) {\n", 
            "-        StringBuffer buffer = new StringBuffer(6);\n", 
            "-        buffer.append('[');\n", 
            "-        if ((ops & SelectionKey.OP_READ) > 0) {\n", 
            "-            buffer.append('r');\n", 
            "-        }\n", 
            "-        if ((ops & SelectionKey.OP_WRITE) > 0) {\n", 
            "-            buffer.append('w');\n", 
            "-        }\n", 
            "-        if ((ops & SelectionKey.OP_ACCEPT) > 0) {\n", 
            "-            buffer.append('a');\n", 
            "-        }\n", 
            "-        if ((ops & SelectionKey.OP_CONNECT) > 0) {\n", 
            "-            buffer.append('c');\n", 
            "-        }\n", 
            "-        buffer.append(']');\n", 
            "-        return buffer.toString();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setEventMask(int ops) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"I/O session \" + this.id + \" \" + this.session + \": Set event mask \"\n", 
            "-                    + formatOps(ops));\n", 
            "-        }\n", 
            "-        this.session.setEventMask(ops);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setEvent(int op) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"I/O session \" + this.id + \" \" + this.session + \": Set event \"\n", 
            "-                    + formatOps(op));\n", 
            "-        }\n", 
            "-        this.session.setEvent(op);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void clearEvent(int op) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"I/O session \" + this.id + \" \" + this.session + \": Clear event \"\n", 
            "-                    + formatOps(op));\n", 
            "-        }\n", 
            "-        this.session.clearEvent(op);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void close() {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"I/O session \" + this.id + \" \" + this.session + \": Close\");\n", 
            "-        }\n", 
            "-        this.session.close();\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean isClosed() {\n", 
            "-        return this.session.isClosed();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void shutdown() {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"I/O session \" + this.id + \" \" + this.session + \": Shutdown\");\n", 
            "-        }\n", 
            "-        this.session.shutdown();\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getSocketTimeout() {\n", 
            "-        return this.session.getSocketTimeout();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setSocketTimeout(int timeout) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"I/O session \" + this.id + \" \" + this.session + \": Set timeout \"\n", 
            "-                    + timeout);\n", 
            "-        }\n", 
            "-        this.session.setSocketTimeout(timeout);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setBufferStatus(final SessionBufferStatus status) {\n", 
            "-        this.session.setBufferStatus(status);\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean hasBufferedInput() {\n", 
            "-        return this.session.hasBufferedInput();\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean hasBufferedOutput() {\n", 
            "-        return this.session.hasBufferedOutput();\n", 
            "-    }\n", 
            "-\n", 
            "-    public Object getAttribute(final String name) {\n", 
            "-        return this.session.getAttribute(name);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setAttribute(final String name, final Object obj) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"I/O session \" + this.id + \" \" + this.session + \": Set attribute \"\n", 
            "-                    + name);\n", 
            "-        }\n", 
            "-        this.session.setAttribute(name, obj);\n", 
            "-    }\n", 
            "-\n", 
            "-    public Object removeAttribute(final String name) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"I/O session \" + this.id + \" \" + this.session + \": Remove attribute \"\n", 
            "-                    + name);\n", 
            "-        }\n", 
            "-        return this.session.removeAttribute(name);\n", 
            "-    }\n", 
            "-\n", 
            "-    class LoggingByteChannel implements ByteChannel {\n", 
            "-\n", 
            "-        public int read(final ByteBuffer dst) throws IOException {\n", 
            "-            int bytesRead = session.channel().read(dst);\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"I/O session \" + id + \" \" + session + \": \" + bytesRead + \" bytes read\");\n", 
            "-            }\n", 
            "-            if (bytesRead > 0 && wirelog.isEnabled()) {\n", 
            "-                ByteBuffer b = dst.duplicate();\n", 
            "-                int p = b.position();\n", 
            "-                b.limit(p);\n", 
            "-                b.position(p - bytesRead);\n", 
            "-                wirelog.input(b);\n", 
            "-            }\n", 
            "-            return bytesRead;\n", 
            "-        }\n", 
            "-\n", 
            "-        public int write(final ByteBuffer src) throws IOException {\n", 
            "-            int byteWritten = session.channel().write(src);\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"I/O session \" + id + \" \" + session + \": \" + byteWritten + \" bytes written\");\n", 
            "-            }\n", 
            "-            if (byteWritten > 0 && wirelog.isEnabled()) {\n", 
            "-                ByteBuffer b = src.duplicate();\n", 
            "-                int p = b.position();\n", 
            "-                b.limit(p);\n", 
            "-                b.position(p - byteWritten);\n", 
            "-                wirelog.output(b);\n", 
            "-            }\n", 
            "-            return byteWritten;\n", 
            "-        }\n", 
            "-\n", 
            "-        public void close() throws IOException {\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"I/O session \" + id + \" \" + session + \": Channel close\");\n", 
            "-            }\n", 
            "-            session.channel().close();\n", 
            "-        }\n", 
            "-\n", 
            "-        public boolean isOpen() {\n", 
            "-            return session.channel().isOpen();\n", 
            "-        }\n", 
            "-\n", 
            "-    }       \n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingIOSession.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingIOSession.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,157 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.logging;\n", 
            "-\n", 
            "-import org.apache.http.impl.nio.DefaultNHttpServerConnection;\n", 
            "-import org.apache.http.nio.reactor.IOSession;\n", 
            "-import org.apache.http.nio.reactor.SessionOutputBuffer;\n", 
            "-import org.apache.http.nio.reactor.SessionInputBuffer;\n", 
            "-import org.apache.http.nio.util.ByteBufferAllocator;\n", 
            "-import org.apache.http.nio.NHttpServiceHandler;\n", 
            "-import org.apache.http.nio.NHttpMessageWriter;\n", 
            "-import org.apache.http.nio.NHttpMessageParser;\n", 
            "-import org.apache.http.*;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-import java.nio.channels.ReadableByteChannel;\n", 
            "-\n", 
            "-public class LoggingNHttpSourceConnection extends DefaultNHttpServerConnection {\n", 
            "-    private final Log log;\n", 
            "-    private final Log headerLog;\n", 
            "-\n", 
            "-    public LoggingNHttpSourceConnection(\n", 
            "-            final Log log,\n", 
            "-            final Log headerlog,\n", 
            "-            final IOSession session,\n", 
            "-            final HttpRequestFactory requestFactory,\n", 
            "-            final ByteBufferAllocator allocator,\n", 
            "-            final HttpParams params) {\n", 
            "-        super(session, requestFactory, allocator, params);\n", 
            "-        this.log = log;\n", 
            "-        this.headerLog = headerlog;\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void close() throws IOException {\n", 
            "-        this.log.debug(\"Close connection\");\n", 
            "-        super.close();\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void shutdown() throws IOException {\n", 
            "-        this.log.debug(\"Shutdown connection\");\n", 
            "-        super.shutdown();\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void submitResponse(final HttpResponse response) throws IOException, HttpException {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + this + \": \"  + response.getStatusLine().toString());\n", 
            "-        }\n", 
            "-        super.submitResponse(response);\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void consumeInput(final NHttpServiceHandler handler) {\n", 
            "-        this.log.debug(\"Consume input\");\n", 
            "-        super.consumeInput(handler);\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void produceOutput(final NHttpServiceHandler handler) {\n", 
            "-        this.log.debug(\"Produce output\");\n", 
            "-        super.produceOutput(handler);\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    protected NHttpMessageWriter createResponseWriter(\n", 
            "-            final SessionOutputBuffer buffer,\n", 
            "-            final HttpParams params) {\n", 
            "-        return new LoggingNHttpMessageWriter(\n", 
            "-                super.createResponseWriter(buffer, params));\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    protected NHttpMessageParser createRequestParser(\n", 
            "-            final SessionInputBuffer buffer,\n", 
            "-            final HttpRequestFactory requestFactory,\n", 
            "-            final HttpParams params) {\n", 
            "-        return new LoggingNHttpMessageParser(\n", 
            "-                super.createRequestParser(buffer, requestFactory, params));\n", 
            "-    }\n", 
            "-\n", 
            "-    class LoggingNHttpMessageWriter implements NHttpMessageWriter {\n", 
            "-\n", 
            "-        private final NHttpMessageWriter writer;\n", 
            "-\n", 
            "-        public LoggingNHttpMessageWriter(final NHttpMessageWriter writer) {\n", 
            "-            super();\n", 
            "-            this.writer = writer;\n", 
            "-        }\n", 
            "-\n", 
            "-        public void reset() {\n", 
            "-            this.writer.reset();\n", 
            "-        }\n", 
            "-\n", 
            "-        public void write(final HttpMessage message) throws IOException, HttpException {\n", 
            "-            if (message != null && headerLog.isDebugEnabled()) {\n", 
            "-                HttpResponse response = (HttpResponse) message;\n", 
            "-                headerLog.debug(\"<< \" + response.getStatusLine().toString());\n", 
            "-                Header[] headers = response.getAllHeaders();\n", 
            "-                for (Header header : headers) {\n", 
            "-                    headerLog.debug(\"<< \" + header.toString());\n", 
            "-                }\n", 
            "-            }\n", 
            "-            this.writer.write(message);\n", 
            "-        }\n", 
            "-\n", 
            "-    }\n", 
            "-\n", 
            "-    class LoggingNHttpMessageParser implements NHttpMessageParser {\n", 
            "-\n", 
            "-        private final NHttpMessageParser parser;\n", 
            "-\n", 
            "-        public LoggingNHttpMessageParser(final NHttpMessageParser parser) {\n", 
            "-            super();\n", 
            "-            this.parser = parser;\n", 
            "-        }\n", 
            "-\n", 
            "-        public void reset() {\n", 
            "-            this.parser.reset();\n", 
            "-        }\n", 
            "-\n", 
            "-        public int fillBuffer(final ReadableByteChannel channel) throws IOException {\n", 
            "-            return this.parser.fillBuffer(channel);\n", 
            "-        }\n", 
            "-\n", 
            "-        public HttpMessage parse() throws IOException, HttpException {\n", 
            "-            HttpMessage message = this.parser.parse();\n", 
            "-            if (message != null && headerLog.isDebugEnabled()) {\n", 
            "-                HttpRequest request = (HttpRequest) message;\n", 
            "-                headerLog.debug(\">> \" + request.getRequestLine().toString());\n", 
            "-                Header[] headers = request.getAllHeaders();\n", 
            "-                for (Header header : headers) {\n", 
            "-                    headerLog.debug(\">> \" + header.toString());\n", 
            "-                }\n", 
            "-            }\n", 
            "-            return message;\n", 
            "-        }\n", 
            "-    }\n", 
            "-}\n", 
            "-\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpSourceConnection.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpSourceConnection.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,121 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.logging;\n", 
            "-\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.nio.NHttpServiceHandler;\n", 
            "-import org.apache.http.nio.NHttpServerConnection;\n", 
            "-import org.apache.http.nio.ContentEncoder;\n", 
            "-import org.apache.http.nio.ContentDecoder;\n", 
            "-import org.apache.http.ConnectionClosedException;\n", 
            "-import org.apache.http.HttpException;\n", 
            "-import org.apache.http.HttpRequest;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-\n", 
            "-public class LoggingSourceHandler implements NHttpServiceHandler {\n", 
            "-\n", 
            "-    private final Log log;\n", 
            "-\n", 
            "-    private final NHttpServiceHandler handler;\n", 
            "-\n", 
            "-    public LoggingSourceHandler (final NHttpServiceHandler handler) {\n", 
            "-        super();\n", 
            "-        if (handler == null) {\n", 
            "-            throw new IllegalArgumentException(\"HTTP service handler may not be null\");\n", 
            "-        }\n", 
            "-        this.handler = handler;\n", 
            "-        this.log = LogFactory.getLog(handler.getClass());\n", 
            "-    }\n", 
            "-\n", 
            "-    public void connected(final NHttpServerConnection conn) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Connected\");\n", 
            "-        }\n", 
            "-        this.handler.connected(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void closed(final NHttpServerConnection conn) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Closed\");\n", 
            "-        }\n", 
            "-        this.handler.closed(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void exception(final NHttpServerConnection conn, final IOException ex) {\n", 
            "-        if (ex instanceof ConnectionClosedException ||\n", 
            "-                ex.getMessage().contains(\"Connection reset by peer\") ||\n", 
            "-                ex.getMessage().contains(\"forcibly closed\")) {\n", 
            "-            if (this.log.isDebugEnabled()) {\n", 
            "-                this.log.debug(\"HTTP connection \" + conn + \": \" + ex.getMessage() +\n", 
            "-                    \" (Probably the keepalive connection was closed)\");\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            this.log.error(\"IO Error occured on HTTP connection \" + conn + \": \" + ex.getMessage(), ex);\n", 
            "-        }\n", 
            "-        this.handler.exception(conn, ex);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void exception(final NHttpServerConnection conn, final HttpException ex) {\n", 
            "-        this.log.error(\"HTTP Error occured on connection \" + conn + \": \" + ex.getMessage(), ex);\n", 
            "-        this.handler.exception(conn, ex);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void requestReceived(final NHttpServerConnection conn) {\n", 
            "-        HttpRequest request = conn.getHttpRequest();\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP InRequest Received on connection \" + conn + \": \"\n", 
            "-                    + request.getRequestLine());\n", 
            "-        }\n", 
            "-        this.handler.requestReceived(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Output ready\");\n", 
            "-        }\n", 
            "-        this.handler.outputReady(conn, encoder);\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Content encoder \" + encoder);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void responseReady(final NHttpServerConnection conn) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Response ready\");\n", 
            "-        }\n", 
            "-        this.handler.responseReady(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Input ready\");\n", 
            "-        }\n", 
            "-        this.handler.inputReady(conn, decoder);\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Content decoder \" + decoder);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void timeout(final NHttpServerConnection conn) {\n", 
            "-        if (this.log.isDebugEnabled()) {\n", 
            "-            this.log.debug(\"HTTP connection \" + conn + \": Timeout\");\n", 
            "-        }\n", 
            "-        this.handler.timeout(conn);\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingSourceHandler.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingSourceHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,107 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.logging;\n", 
            "-\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-\n", 
            "-import java.nio.ByteBuffer;\n", 
            "-\n", 
            "-public class Wire {\n", 
            "-    private final Log log;\n", 
            "-\n", 
            "-    public Wire(final Log log) {\n", 
            "-        super();\n", 
            "-        this.log = log;\n", 
            "-    }\n", 
            "-\n", 
            "-    private void wire(final String header, final byte[] b, int pos, int off) {\n", 
            "-        StringBuilder buffer = new StringBuilder();\n", 
            "-        for (int i = 0; i < off; i++) {\n", 
            "-            int ch = b[pos + i];\n", 
            "-            if (ch == 13) {\n", 
            "-                buffer.append(\"[\\\\r]\");\n", 
            "-            } else if (ch == 10) {\n", 
            "-                    buffer.append(\"[\\\\n]\\\"\");\n", 
            "-                    buffer.insert(0, \"\\\"\");\n", 
            "-                    buffer.insert(0, header);\n", 
            "-                    this.log.debug(buffer.toString());\n", 
            "-                    buffer.setLength(0);\n", 
            "-            } else if ((ch < 32) || (ch > 127)) {\n", 
            "-                buffer.append(\"[0x\");\n", 
            "-                buffer.append(Integer.toHexString(ch));\n", 
            "-                buffer.append(\"]\");\n", 
            "-            } else {\n", 
            "-                buffer.append((char) ch);\n", 
            "-            }\n", 
            "-        }\n", 
            "-        if (buffer.length() > 0) {\n", 
            "-            buffer.append('\\\"');\n", 
            "-            buffer.insert(0, '\\\"');\n", 
            "-            buffer.insert(0, header);\n", 
            "-            this.log.debug(buffer.toString());\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-\n", 
            "-    public boolean isEnabled() {\n", 
            "-        return this.log.isDebugEnabled();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void output(final byte[] b, int pos, int off) {\n", 
            "-        wire(\"<< \", b, pos, off);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void input(final byte[] b, int pos, int off) {\n", 
            "-        wire(\">> \", b, pos, off);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void output(byte[] b) {\n", 
            "-        output(b, 0, b.length);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void input(byte[] b) {\n", 
            "-        input(b, 0, b.length);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void output(int b) {\n", 
            "-        output(new byte[] {(byte) b});\n", 
            "-    }\n", 
            "-\n", 
            "-    public void input(int b) {\n", 
            "-        input(new byte[] {(byte) b});\n", 
            "-    }\n", 
            "-\n", 
            "-    public void output(final ByteBuffer b) {\n", 
            "-        if (b.hasArray()) {\n", 
            "-            output(b.array(), b.arrayOffset() + b.position(), b.remaining());\n", 
            "-        } else {\n", 
            "-            byte[] tmp = new byte[b.remaining()];\n", 
            "-            b.get(tmp);\n", 
            "-            output(tmp);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void input(final ByteBuffer b) {\n", 
            "-        if (b.hasArray()) {\n", 
            "-            input(b.array(), b.arrayOffset() + b.position(), b.remaining());\n", 
            "-        } else {\n", 
            "-            byte[] tmp = new byte[b.remaining()];\n", 
            "-            b.get(tmp);\n", 
            "-            input(tmp);\n", 
            "-        }\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/Wire.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/Wire.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,111 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.logging;\n", 
            "-\n", 
            "-import org.apache.http.nio.reactor.IOSession;\n", 
            "-import org.apache.http.nio.NHttpClientHandler;\n", 
            "-import org.apache.http.nio.NHttpServiceHandler;\n", 
            "-import org.apache.http.nio.NHttpClientIOTarget;\n", 
            "-import org.apache.http.nio.NHttpServerIOTarget;\n", 
            "-import org.apache.http.nio.util.ByteBufferAllocator;\n", 
            "-import org.apache.http.HttpResponseFactory;\n", 
            "-import org.apache.http.HttpRequestFactory;\n", 
            "-import org.apache.http.impl.nio.DefaultNHttpClientConnection;\n", 
            "-import org.apache.http.impl.nio.DefaultNHttpServerConnection;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-\n", 
            "-\n", 
            "-public class LoggingUtils {\n", 
            "-    public final static String HEADER_LOG_ID = \"org.wso2.carbon.transport.passthru.headers\";\n", 
            "-    public final static String WIRE_LOG_ID = \"org.wso2.carbon.transport.passthru.wire\";\n", 
            "-\n", 
            "-    public static IOSession decorate(IOSession session, final String id) {\n", 
            "-        Log log = LogFactory.getLog(session.getClass());\n", 
            "-        Log wirelog = LogFactory.getLog(WIRE_LOG_ID);\n", 
            "-        if (wirelog.isDebugEnabled() || log.isDebugEnabled()) {\n", 
            "-            session = new LoggingIOSession(wirelog, session, id);\n", 
            "-        }\n", 
            "-        return session;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static NHttpClientHandler decorate(NHttpClientHandler handler) {\n", 
            "-        Log log = LogFactory.getLog(handler.getClass());\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            handler = new LoggingTargetHandler(handler);\n", 
            "-        }\n", 
            "-        return handler;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static NHttpServiceHandler decorate(NHttpServiceHandler handler) {\n", 
            "-        Log log = LogFactory.getLog(handler.getClass());\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            handler = new LoggingSourceHandler(handler);\n", 
            "-        }\n", 
            "-        return handler;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static NHttpClientIOTarget createClientConnection(\n", 
            "-            final IOSession iosession,\n", 
            "-            final HttpResponseFactory responseFactory,\n", 
            "-            final ByteBufferAllocator allocator,\n", 
            "-            final HttpParams params) {\n", 
            "-        Log log = LogFactory.getLog(DefaultNHttpClientConnection.class);\n", 
            "-        Log headerlog = LogFactory.getLog(HEADER_LOG_ID);\n", 
            "-        if (headerlog.isDebugEnabled() || log.isDebugEnabled()) {\n", 
            "-            return new LoggingNHttpTargetConnection(\n", 
            "-                    log,\n", 
            "-                    headerlog,\n", 
            "-                    iosession,\n", 
            "-                    responseFactory,\n", 
            "-                    allocator,\n", 
            "-                    params);\n", 
            "-        } else {\n", 
            "-            return new DefaultNHttpClientConnection(\n", 
            "-                    iosession,\n", 
            "-                    responseFactory,\n", 
            "-                    allocator,\n", 
            "-                    params);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public static NHttpServerIOTarget createServerConnection(\n", 
            "-            final IOSession iosession,\n", 
            "-            final HttpRequestFactory requestFactory,\n", 
            "-            final ByteBufferAllocator allocator,\n", 
            "-            final HttpParams params) {\n", 
            "-        Log log = LogFactory.getLog(DefaultNHttpClientConnection.class);\n", 
            "-        Log headerlog = LogFactory.getLog(HEADER_LOG_ID);\n", 
            "-        if (headerlog.isDebugEnabled() || log.isDebugEnabled()) {\n", 
            "-            return new LoggingNHttpSourceConnection(\n", 
            "-                    log,\n", 
            "-                    headerlog,\n", 
            "-                    iosession,\n", 
            "-                    requestFactory,\n", 
            "-                    allocator,\n", 
            "-                    params);\n", 
            "-        } else {\n", 
            "-            return new DefaultNHttpServerConnection(\n", 
            "-                    iosession,\n", 
            "-                    requestFactory,\n", 
            "-                    allocator,\n", 
            "-                    params);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingUtils.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingUtils.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,39 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-/**\n", 
            "- * Error codes exposed by this transport. \n", 
            "- */\n", 
            "-public class ErrorCodes {\n", 
            "-    public static final int SND_IO_ERROR       = 102500;\n", 
            "-\n", 
            "-    public static final int SND_HTTP_ERROR     = 102510;\n", 
            "-\n", 
            "-    public static final int SND_INVALID_STATE  = 102510;\n", 
            "-\n", 
            "-    public static final int CONNECTION_FAILED  = 102530;\n", 
            "-\n", 
            "-    public static final int CONNECTION_TIMEOUT = 102540;\n", 
            "-\n", 
            "-    public static final int CONNECTION_CLOSED  = 102550;\n", 
            "-\n", 
            "-    public static final int PROTOCOL_VIOLATION = 102560;\n", 
            "-\n", 
            "-    public static final int CONNECT_CANCEL     = 101507;\n", 
            "-\n", 
            "-    public static final int CONNECT_TIMEOUT    = 101508;    \n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ErrorCodes.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ErrorCodes.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,428 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.axiom.om.OMOutputFormat;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.Constants;\n", 
            "-import org.apache.axis2.util.MessageProcessorSelector;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.handlers.AbstractHandler;\n", 
            "-import org.apache.axis2.addressing.AddressingHelper;\n", 
            "-import org.apache.axis2.addressing.EndpointReference;\n", 
            "-import org.apache.axis2.addressing.AddressingConstants;\n", 
            "-import org.apache.axis2.context.ConfigurationContext;\n", 
            "-import org.apache.axis2.description.TransportOutDescription;\n", 
            "-import org.apache.axis2.transport.MessageFormatter;\n", 
            "-import org.apache.axis2.transport.TransportSender;\n", 
            "-import org.apache.axis2.transport.TransportUtils;\n", 
            "-import org.apache.axis2.transport.base.BaseConstants;\n", 
            "-import org.apache.axis2.transport.base.threads.NativeThreadFactory;\n", 
            "-import org.apache.axis2.transport.base.threads.WorkerPool;\n", 
            "-import org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor;\n", 
            "-import org.apache.http.impl.nio.reactor.SSLSetupHandler;\n", 
            "-import org.apache.http.nio.NHttpClientHandler;\n", 
            "-import org.apache.http.nio.reactor.IOReactorExceptionHandler;\n", 
            "-import org.apache.http.nio.reactor.IOReactorException;\n", 
            "-import org.apache.http.nio.reactor.IOEventDispatch;\n", 
            "-import org.apache.http.nio.NHttpServerConnection;\n", 
            "-import org.apache.http.*;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            "-import org.apache.synapse.transport.passthru.config.SourceConfiguration;\n", 
            "-import org.apache.synapse.transport.passthru.config.TargetConfiguration;\n", 
            "-import org.apache.synapse.transport.passthru.connections.TargetConnections;\n", 
            "-import org.apache.synapse.transport.passthru.jmx.MBeanRegistrar;\n", 
            "-import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;\n", 
            "-import org.apache.synapse.transport.passthru.jmx.TransportView;\n", 
            "-import org.apache.synapse.transport.passthru.util.PassThroughTransportUtils;\n", 
            "-import org.apache.synapse.transport.passthru.util.SourceResponseFactory;\n", 
            "-\n", 
            "-import javax.net.ssl.SSLContext;\n", 
            "-import java.io.IOException;\n", 
            "-import java.io.OutputStream;\n", 
            "-\n", 
            "-/**\n", 
            "- * PassThroughHttpSender for Synapse based on HttpCore and NIO extensions\n", 
            "- */\n", 
            "-public class PassThroughHttpSender extends AbstractHandler implements TransportSender {\n", 
            "-\n", 
            "-    protected Log log;\n", 
            "-\n", 
            "-    /** IOReactor used to create connections and manage them */\n", 
            "-    private DefaultConnectingIOReactor ioReactor;\n", 
            "-\n", 
            "-    /** Delivery agent used for delivering the messages to the servers */\n", 
            "-    private DeliveryAgent deliveryAgent;\n", 
            "-\n", 
            "-    /** The configuration of the sender */\n", 
            "-    private TargetConfiguration targetConfiguration;\n", 
            "-\n", 
            "-    /** state of the sender */\n", 
            "-    private volatile int state = BaseConstants.STOPPED;\n", 
            "-\n", 
            "-    private String namePrefix;\n", 
            "-\n", 
            "-    public PassThroughHttpSender() {\n", 
            "-        log = LogFactory.getLog(this.getClass().getName());\n", 
            "-    }\n", 
            "-\n", 
            "-    public void init(ConfigurationContext configurationContext,\n", 
            "-                     TransportOutDescription transportOutDescription) throws AxisFault {\n", 
            "-        log.info(\"Initializing Pass-through HTTP/S Sender...\");\n", 
            "-\n", 
            "-        // is this an SSL Sender?\n", 
            "-        SSLContext sslContext = getSSLContext(transportOutDescription);\n", 
            "-        SSLSetupHandler sslSetupHandler = getSSLSetupHandler(transportOutDescription);\n", 
            "-        namePrefix = (sslContext == null) ? \"HTTP\" : \"HTTPS\";\n", 
            "-\n", 
            "-        WorkerPool workerPool = null;\n", 
            "-        Object obj = configurationContext.getProperty(\n", 
            "-                PassThroughConstants.PASS_THROUGH_TRANSPORT_WORKER_POOL);\n", 
            "-        if (obj != null) {\n", 
            "-            workerPool = (WorkerPool) obj;                                   \n", 
            "-        }\n", 
            "-\n", 
            "-        targetConfiguration = new TargetConfiguration(configurationContext,\n", 
            "-                transportOutDescription, workerPool);\n", 
            "-        targetConfiguration.build();\n", 
            "-        configurationContext.setProperty(PassThroughConstants.PASS_THROUGH_TRANSPORT_WORKER_POOL,\n", 
            "-                targetConfiguration.getWorkerPool());\n", 
            "-\n", 
            "-        PassThroughTransportMetricsCollector metrics = new\n", 
            "-                PassThroughTransportMetricsCollector(false, sslContext != null);\n", 
            "-        TransportView view = new TransportView(null, this, metrics, null);\n", 
            "-        MBeanRegistrar.getInstance().registerMBean(view, \"Transport\",\n", 
            "-                 \"passthru-\" + namePrefix.toLowerCase() + \"-sender\");\n", 
            "-        targetConfiguration.setMetrics(metrics);\n", 
            "-\n", 
            "-        try {\n", 
            "-            String prefix = namePrefix + \"-Sender I/O dispatcher\";\n", 
            "-\n", 
            "-            ioReactor = new DefaultConnectingIOReactor(\n", 
            "-                            targetConfiguration.getIOThreadsPerReactor(),\n", 
            "-                            new NativeThreadFactory(new ThreadGroup(prefix + \" Thread Group\"), prefix),\n", 
            "-                            targetConfiguration.getHttpParameters());\n", 
            "-\n", 
            "-            ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {\n", 
            "-\n", 
            "-                public boolean handle(IOException ioException) {\n", 
            "-                    log.warn(\"System may be unstable: \" + namePrefix +\n", 
            "-                            \" ConnectingIOReactor encountered a checked exception : \" +\n", 
            "-                            ioException.getMessage(), ioException);\n", 
            "-                    return true;\n", 
            "-                }\n", 
            "-\n", 
            "-                public boolean handle(RuntimeException runtimeException) {\n", 
            "-                    log.warn(\"System may be unstable: \" + namePrefix +\n", 
            "-                            \" ConnectingIOReactor encountered a runtime exception : \"\n", 
            "-                            + runtimeException.getMessage(), runtimeException);\n", 
            "-                    return true;\n", 
            "-                }\n", 
            "-            });\n", 
            "-        } catch (IOReactorException e) {\n", 
            "-            handleException(\"Error starting \" + namePrefix + \" ConnectingIOReactor\", e);\n", 
            "-        }\n", 
            "-\n", 
            "-        ConnectCallback connectCallback = new ConnectCallback();\n", 
            "-        // manage target connections\n", 
            "-        TargetConnections targetConnections =\n", 
            "-                new TargetConnections(ioReactor, targetConfiguration, connectCallback);\n", 
            "-        targetConfiguration.setConnections(targetConnections);\n", 
            "-\n", 
            "-        // create the delivery agent to hand over messages\n", 
            "-        deliveryAgent = new DeliveryAgent(targetConfiguration, targetConnections);\n", 
            "-        // we need to set the delivery agent\n", 
            "-        connectCallback.setDeliveryAgent(deliveryAgent);        \n", 
            "-\n", 
            "-        TargetHandler handler = new TargetHandler(deliveryAgent, targetConfiguration);\n", 
            "-        final IOEventDispatch ioEventDispatch =\n", 
            "-                getEventDispatch(handler, sslContext, sslSetupHandler,\n", 
            "-                        targetConfiguration.getHttpParameters(), transportOutDescription);\n", 
            "-\n", 
            "-        // start the sender in a separate thread\n", 
            "-        Thread t = new Thread(new Runnable() {\n", 
            "-            public void run() {\n", 
            "-                try {\n", 
            "-                    ioReactor.execute(ioEventDispatch);\n", 
            "-                } catch (Exception ex) {\n", 
            "-                   log.fatal(\"Exception encountered in the \" + namePrefix + \" Sender. \" +\n", 
            "-                            \"No more connections will be initiated by this transport\", ex);\n", 
            "-                }\n", 
            "-                log.info(namePrefix + \" Sender shutdown\");\n", 
            "-            }\n", 
            "-        }, \"PassThrough\" + namePrefix + \"Sender\");\n", 
            "-        t.start();\n", 
            "-\n", 
            "-        state = BaseConstants.STARTED;\n", 
            "-\n", 
            "-        log.info(\"Pass-through \" + namePrefix + \" Sender started...\");\n", 
            "-    }\n", 
            "-\n", 
            "-    public void cleanup(org.apache.axis2.context.MessageContext messageContext) throws AxisFault {\n", 
            "-\n", 
            "-    }\n", 
            "-\n", 
            "-    public void stop() {\n", 
            "-        try {\n", 
            "-            ioReactor.shutdown();\n", 
            "-        } catch (IOException e) {\n", 
            "-            log.error(\"Error shutting down the PassThroughHttpSender\", e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-\n", 
            "-    public InvocationResponse invoke(org.apache.axis2.context.MessageContext msgContext) throws AxisFault {\n", 
            "-        // remove unwanted HTTP headers (if any from the current message)\n", 
            "-        PassThroughTransportUtils.removeUnwantedHeaders(msgContext,\n", 
            "-                targetConfiguration.isPreserveServerHeader(),\n", 
            "-                targetConfiguration.isPreserveUserAgentHeader());\n", 
            "-\n", 
            "-        if (AddressingHelper.isReplyRedirected(msgContext)\n", 
            "-                && !msgContext.getReplyTo().hasNoneAddress()) {\n", 
            "-\n", 
            "-            msgContext.setProperty(PassThroughConstants.IGNORE_SC_ACCEPTED, Constants.VALUE_TRUE);\n", 
            "-        }\n", 
            "-\n", 
            "-        EndpointReference epr = PassThroughTransportUtils.getDestinationEPR(msgContext);\n", 
            "-        if (epr != null) {\n", 
            "-            if (!epr.hasNoneAddress()) {\n", 
            "-                if (msgContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE) == null) {\n", 
            "-                    Pipe pipe = new Pipe(targetConfiguration.getBufferFactory().getBuffer(),\n", 
            "-                            \"Test\", targetConfiguration);\n", 
            "-                    msgContext.setProperty(PassThroughConstants.PASS_THROUGH_PIPE, pipe);\n", 
            "-                    msgContext.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED, Boolean.TRUE);\n", 
            "-                }\n", 
            "-                deliveryAgent.submit(msgContext, epr);\n", 
            "-                sendRequestContent(msgContext);\n", 
            "-            } else {\n", 
            "-                handleException(\"Cannot send message to \" + AddressingConstants.Final.WSA_NONE_URI);\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            if (msgContext.getProperty(Constants.OUT_TRANSPORT_INFO) != null) {\n", 
            "-                if (msgContext.getProperty(Constants.OUT_TRANSPORT_INFO) instanceof ServerWorker) {\n", 
            "-                    try {\n", 
            "-                        submitResponse(msgContext);\n", 
            "-                    } catch (Exception e) {\n", 
            "-                        handleException(\"Failed to submit the response\", e);\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            } else {\n", 
            "-                handleException(\"No valid destination EPR to send message\");\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        if (msgContext.getOperationContext() != null) {\n", 
            "-            msgContext.getOperationContext().setProperty(\n", 
            "-                Constants.RESPONSE_WRITTEN, Constants.VALUE_TRUE);\n", 
            "-        }\n", 
            "-\n", 
            "-        return InvocationResponse.CONTINUE;\n", 
            "-    }\n", 
            "-\n", 
            "-    private void sendRequestContent(final MessageContext msgContext) throws AxisFault {\n", 
            "-        if (Boolean.TRUE.equals(msgContext.getProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED))) {\n", 
            "-            synchronized (msgContext) {\n", 
            "-                while (!Boolean.TRUE.equals(msgContext.getProperty(\"READY2ROCK\")) &&\n", 
            "-                        !Boolean.TRUE.equals(msgContext.getProperty(\"PASSTHRU_CONNECT_ERROR\"))) {\n", 
            "-                    try {\n", 
            "-                        msgContext.wait();\n", 
            "-                    } catch (InterruptedException e) {\n", 
            "-                        e.printStackTrace();\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            }\n", 
            "-\n", 
            "-            if (Boolean.TRUE.equals(msgContext.getProperty(\"PASSTHRU_CONNECT_ERROR\"))) {\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            OutputStream out = (OutputStream) msgContext.getProperty(\"GET_ME_OUT\");\n", 
            "-            if (out != null) {\n", 
            "-                MessageFormatter formatter = MessageProcessorSelector.getMessageFormatter(msgContext);\n", 
            "-                OMOutputFormat format = PassThroughTransportUtils.getOMOutputFormat(msgContext);\n", 
            "-                formatter.writeTo(msgContext, format, out, false);\n", 
            "-                Pipe pipe = (Pipe) msgContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE);\n", 
            "-                pipe.setSerializationComplete(true);\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Return the IOEventDispatch implementation to be used. This is overridden by the\n", 
            "-     * SSL sender\n", 
            "-     *\n", 
            "-     * @param handler The passthru target handler instance\n", 
            "-     * @param sslContext SSL context used by the sender or null\n", 
            "-     * @param sslIOSessionHandler SSL session handler or null\n", 
            "-     * @param params HTTP parameters\n", 
            "-     * @param trpOut Transport out description\n", 
            "-     * @return an IOEventDispatch instance\n", 
            "-     * @throws AxisFault on error\n", 
            "-     */\n", 
            "-    protected IOEventDispatch getEventDispatch(NHttpClientHandler handler,\n", 
            "-                                               SSLContext sslContext,\n", 
            "-                                               SSLSetupHandler sslIOSessionHandler,\n", 
            "-                                               HttpParams params, TransportOutDescription trpOut) throws AxisFault {\n", 
            "-\n", 
            "-        return new TargetIOEventDispatch(handler, params);\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Always return null, as this implementation does not support outgoing SSL\n", 
            "-     *\n", 
            "-     * @param transportOut The transport out description\n", 
            "-     * @return null\n", 
            "-     * @throws AxisFault on error\n", 
            "-     */\n", 
            "-    protected SSLContext getSSLContext(TransportOutDescription transportOut) throws AxisFault {\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Create the SSL IO Session handler to be used by this listener\n", 
            "-     *\n", 
            "-     * @param transportOut Transport out description\n", 
            "-     * @return always null\n", 
            "-     * @throws AxisFault on error\n", 
            "-     */\n", 
            "-    protected SSLSetupHandler getSSLSetupHandler(TransportOutDescription transportOut)\n", 
            "-        throws AxisFault {\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void submitResponse(MessageContext msgContext)\n", 
            "-            throws IOException, HttpException {\n", 
            "-        SourceConfiguration sourceConfiguration = (SourceConfiguration) msgContext.getProperty(\n", 
            "-                        PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION);\n", 
            "-\n", 
            "-        NHttpServerConnection conn = (NHttpServerConnection) msgContext.getProperty(\n", 
            "-                PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION);\n", 
            "-        if (conn == null) {\n", 
            "-            ServerWorker serverWorker = (ServerWorker) msgContext.getProperty(Constants.OUT_TRANSPORT_INFO);\n", 
            "-            if (serverWorker != null) {\n", 
            "-                MessageContext requestContext = serverWorker.getRequestContext();\n", 
            "-                conn = (NHttpServerConnection) requestContext.getProperty(\n", 
            "-                        PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION);\n", 
            "-                sourceConfiguration = (SourceConfiguration) requestContext.getProperty(\n", 
            "-                        PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION);\n", 
            "-            } else {\n", 
            "-                throw new IllegalStateException(\"Unable to correlate the response to a request\");\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        SourceRequest sourceRequest = SourceContext.getRequest(conn);\n", 
            "-\n", 
            "-        SourceResponse sourceResponse = SourceResponseFactory.create(msgContext,\n", 
            "-                sourceRequest, sourceConfiguration);\n", 
            "-\n", 
            "-        SourceContext.setResponse(conn, sourceResponse);\n", 
            "-\n", 
            "-        Boolean noEntityBody = (Boolean) msgContext.getProperty(PassThroughConstants.NO_ENTITY_BODY);\n", 
            "-        Pipe pipe = (Pipe) msgContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE);\n", 
            "-        if ((noEntityBody == null || !noEntityBody) || pipe != null) {\n", 
            "-            if (pipe == null) {\n", 
            "-                pipe = new Pipe(sourceConfiguration.getBufferFactory().getBuffer(),\n", 
            "-                        \"Test\", sourceConfiguration);\n", 
            "-                msgContext.setProperty(PassThroughConstants.PASS_THROUGH_PIPE, pipe);\n", 
            "-                msgContext.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED, Boolean.TRUE);\n", 
            "-            }\n", 
            "-\n", 
            "-            pipe.attachConsumer(conn);\n", 
            "-            sourceResponse.connect(pipe);\n", 
            "-        }\n", 
            "-\n", 
            "-        Integer errorCode = (Integer) msgContext.getProperty(PassThroughConstants.ERROR_CODE);\n", 
            "-        if (errorCode != null) {\n", 
            "-            sourceResponse.setStatus(HttpStatus.SC_BAD_GATEWAY);\n", 
            "-            SourceContext.get(conn).setShutDown(true);\n", 
            "-        }\n", 
            "-\n", 
            "-        ProtocolState state = SourceContext.getState(conn);\n", 
            "-        if (state != null && state.compareTo(ProtocolState.REQUEST_DONE) <= 0) {\n", 
            "-            // start sending the response if we\n", 
            "-            if (msgContext.isPropertyTrue(PassThroughConstants.MESSAGE_BUILDER_INVOKED) && pipe != null) {\n", 
            "-                OutputStream out = pipe.getOutputStream();\n", 
            "-                if (msgContext.isPropertyTrue(NhttpConstants.SC_ACCEPTED)) {\n", 
            "-                    out.write(new byte[0]);\n", 
            "-                } else {\n", 
            "-                    MessageFormatter formatter = MessageProcessorSelector.getMessageFormatter(msgContext);\n", 
            "-                    OMOutputFormat format = PassThroughTransportUtils.getOMOutputFormat(msgContext);\n", 
            "-                    formatter.writeTo(msgContext, format, out, false);\n", 
            "-                }\n", 
            "-                pipe.setSerializationComplete(true);\n", 
            "-                out.close();\n", 
            "-            }\n", 
            "-            conn.requestOutput();\n", 
            "-        } else {\n", 
            "-            // nothing much to do as we have started the response already\n", 
            "-            if (errorCode != null) {\n", 
            "-                if (log.isDebugEnabled()) {\n", 
            "-                    log.warn(\"A Source connection is closed because of an \" +\n", 
            "-                            \"error in target: \" + conn);\n", 
            "-                }\n", 
            "-            } else {\n", 
            "-                log.debug(\"A Source Connection is closed, because source handler \" +\n", 
            "-                        \"is already in the process of writing a response while \" +\n", 
            "-                        \"another response is submitted: \" + conn);\n", 
            "-            }\n", 
            "-\n", 
            "-            SourceContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            sourceConfiguration.getSourceConnections().shutDownConnection(conn);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void pause() throws AxisFault {\n", 
            "-        if (state != BaseConstants.STARTED) {\n", 
            "-            return;\n", 
            "-        }\n", 
            "-        state = BaseConstants.PAUSED;\n", 
            "-        log.info(namePrefix + \" Sender Paused\");\n", 
            "-    }\n", 
            "-\n", 
            "-    public void resume() throws AxisFault {\n", 
            "-        if (state != BaseConstants.PAUSED) {\n", 
            "-            return;\n", 
            "-        }\n", 
            "-        state = BaseConstants.STARTED;\n", 
            "-        log.info(namePrefix + \" Sender Resumed\");\n", 
            "-    }\n", 
            "-\n", 
            "-    public void maintenanceShutdown(long millis) throws AxisFault {\n", 
            "-        if (state != BaseConstants.STARTED) return;\n", 
            "-        try {\n", 
            "-            long start = System.currentTimeMillis();\n", 
            "-            ioReactor.shutdown(millis);\n", 
            "-            state = BaseConstants.STOPPED;\n", 
            "-            log.info(\"Sender shutdown in : \" + (System.currentTimeMillis() - start) / 1000 + \"s\");\n", 
            "-        } catch (IOException e) {\n", 
            "-            handleException(\"Error shutting down the IOReactor for maintenence\", e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private void handleException(String s, Exception e) throws AxisFault {\n", 
            "-        log.error(s, e);\n", 
            "-        throw new AxisFault(s, e);\n", 
            "-    }\n", 
            "-\n", 
            "-    private void handleException(String msg) throws AxisFault {\n", 
            "-        log.error(msg);\n", 
            "-        throw new AxisFault(msg);\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,219 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.axis2.addressing.AddressingConstants;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.http.protocol.HTTP;\n", 
            "-import org.apache.axis2.builder.BuilderUtil;\n", 
            "-import org.apache.axis2.context.ConfigurationContext;\n", 
            "-import org.apache.axis2.Constants;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.wsdl.WSDLConstants;\n", 
            "-import org.apache.axis2.description.WSDL2Constants;\n", 
            "-import org.apache.axis2.description.Parameter;\n", 
            "-import org.apache.axis2.engine.AxisEngine;\n", 
            "-import org.apache.axiom.soap.*;\n", 
            "-import org.apache.axiom.soap.impl.llom.soap11.SOAP11Factory;\n", 
            "-import org.apache.axiom.om.OMAbstractFactory;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-import java.util.Map;\n", 
            "-import java.util.Set;\n", 
            "-import java.util.TreeMap;\n", 
            "-import java.util.Comparator;\n", 
            "-\n", 
            "-public class ClientWorker implements Runnable {\n", 
            "-    private Log log = LogFactory.getLog(ClientWorker.class);\n", 
            "-    /** the Axis2 configuration context */\n", 
            "-    private ConfigurationContext cfgCtx = null;\n", 
            "-    /** the response message context that would be created */\n", 
            "-    private org.apache.axis2.context.MessageContext responseMsgCtx = null;\n", 
            "-    /** the HttpResponse received */\n", 
            "-    private TargetResponse response = null;\n", 
            "-    /** weather a body is expected or not */\n", 
            "-    private boolean expectEntityBody = true;\n", 
            "-\n", 
            "-    public ClientWorker(ConfigurationContext cfgCtx,\n", 
            "-                        MessageContext outMsgCtx,\n", 
            "-                        TargetResponse response) {\n", 
            "-        this.cfgCtx = cfgCtx;\n", 
            "-        this.response = response;\n", 
            "-        this.expectEntityBody = response.isExpectResponseBody();\n", 
            "-\n", 
            "-        try {\n", 
            "-            responseMsgCtx = outMsgCtx.getOperationContext().\n", 
            "-                getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);\n", 
            "-            // fix for RM to work because of a soapAction and wsaAction conflict\n", 
            "-            if (responseMsgCtx != null) {\n", 
            "-                responseMsgCtx.setSoapAction(\"\");\n", 
            "-            }\n", 
            "-        } catch (AxisFault af) {\n", 
            "-            log.error(\"Error getting IN message context from the operation context\", af);\n", 
            "-            return;\n", 
            "-        }\n", 
            "-\n", 
            "-        if (responseMsgCtx == null) {\n", 
            "-            if (outMsgCtx.getOperationContext().isComplete()) {\n", 
            "-                if (log.isDebugEnabled()) {\n", 
            "-                    log.debug(\"Error getting IN message context from the operation context. \" +\n", 
            "-                            \"Possibly an RM terminate sequence message\");\n", 
            "-                }\n", 
            "-                return;\n", 
            "-\n", 
            "-            }\n", 
            "-            responseMsgCtx = new MessageContext();\n", 
            "-            responseMsgCtx.setOperationContext(outMsgCtx.getOperationContext());\n", 
            "-        }\n", 
            "-\n", 
            "-        // copy the important properties from the original message context\n", 
            "-        responseMsgCtx.setProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION,\n", 
            "-                outMsgCtx.getProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION));\n", 
            "-        responseMsgCtx.setProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION,\n", 
            "-                outMsgCtx.getProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION));\n", 
            "-\n", 
            "-        responseMsgCtx.setServerSide(true);\n", 
            "-        responseMsgCtx.setDoingREST(outMsgCtx.isDoingREST());\n", 
            "-        responseMsgCtx.setProperty(MessageContext.TRANSPORT_IN, outMsgCtx\n", 
            "-                .getProperty(MessageContext.TRANSPORT_IN));\n", 
            "-        responseMsgCtx.setTransportIn(outMsgCtx.getTransportIn());\n", 
            "-        responseMsgCtx.setTransportOut(outMsgCtx.getTransportOut());\n", 
            "-\n", 
            "-        // set any transport headers received\n", 
            "-        Set<Map.Entry<String, String>> headerEntries = response.getHeaders().entrySet();\n", 
            "-        Map<String, String> headerMap = new TreeMap<String, String>(new Comparator<String>() {\n", 
            "-            public int compare(String o1, String o2) {\n", 
            "-                return o1.compareToIgnoreCase(o2);\n", 
            "-            }\n", 
            "-        });\n", 
            "-\n", 
            "-        for (Map.Entry<String, String> headerEntry : headerEntries) {\n", 
            "-            headerMap.put(headerEntry.getKey(), headerEntry.getValue());\n", 
            "-        }\n", 
            "-        responseMsgCtx.setProperty(MessageContext.TRANSPORT_HEADERS, headerMap);\n", 
            "-\n", 
            "-        if (response.getStatus() == 202) {\n", 
            "-            responseMsgCtx.setProperty(AddressingConstants.\n", 
            "-                    DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);\n", 
            "-            responseMsgCtx.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED, Boolean.TRUE);\n", 
            "-            responseMsgCtx.setProperty(NhttpConstants.SC_ACCEPTED, Boolean.TRUE);\n", 
            "-        }\n", 
            "-\n", 
            "-        responseMsgCtx.setAxisMessage(outMsgCtx.getOperationContext().getAxisOperation().\n", 
            "-                getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));\n", 
            "-        responseMsgCtx.setOperationContext(outMsgCtx.getOperationContext());\n", 
            "-        responseMsgCtx.setConfigurationContext(outMsgCtx.getConfigurationContext());\n", 
            "-        responseMsgCtx.setTo(null);\n", 
            "-\n", 
            "-        responseMsgCtx.setProperty(PassThroughConstants.PASS_THROUGH_PIPE, response.getPipe());\n", 
            "-        responseMsgCtx.setProperty(PassThroughConstants.PASS_THROUGH_TARGET_RESPONSE, response);\n", 
            "-        responseMsgCtx.setProperty(PassThroughConstants.PASS_THROUGH_TARGET_CONNECTION,\n", 
            "-                response.getConnection());\n", 
            "-    }\n", 
            "-\n", 
            "-    public void run() {\n", 
            "-        if (responseMsgCtx == null) {\n", 
            "-            return;\n", 
            "-        }\n", 
            "-       \n", 
            "-        try {\n", 
            "-            if (expectEntityBody) {\n", 
            "-                String cType = response.getHeader(HTTP.CONTENT_TYPE);\n", 
            "-                String contentType;\n", 
            "-                if (cType != null) {\n", 
            "-                    // This is the most common case - Most of the time servers send the Content-Type\n", 
            "-                    contentType = cType;\n", 
            "-                } else {\n", 
            "-                    // Server hasn't sent the header - Try to infer the content type\n", 
            "-                    contentType = inferContentType();\n", 
            "-                }\n", 
            "-\n", 
            "-                responseMsgCtx.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);\n", 
            "-\n", 
            "-                String charSetEnc = BuilderUtil.getCharSetEncoding(contentType);\n", 
            "-                if (charSetEnc == null) {\n", 
            "-                    charSetEnc = MessageContext.DEFAULT_CHAR_SET_ENCODING;\n", 
            "-                }\n", 
            "-\n", 
            "-                responseMsgCtx.setProperty(\n", 
            "-                        Constants.Configuration.CHARACTER_SET_ENCODING,\n", 
            "-                        contentType.indexOf(HTTP.CHARSET_PARAM) > 0 ?\n", 
            "-                                charSetEnc : MessageContext.DEFAULT_CHAR_SET_ENCODING);\n", 
            "-                \n", 
            "-                responseMsgCtx.setServerSide(false);\n", 
            "-                SOAPFactory fac = OMAbstractFactory.getSOAP11Factory();\n", 
            "-                SOAPEnvelope envelope = fac.getDefaultEnvelope();\n", 
            "-                try {\n", 
            "-                    responseMsgCtx.setEnvelope(envelope);\n", 
            "-                } catch (AxisFault axisFault) {\n", 
            "-                    log.error(\"Error setting SOAP envelope\", axisFault);\n", 
            "-                }\n", 
            "-\n", 
            "-                responseMsgCtx.setServerSide(true);\n", 
            "-            } else {\n", 
            "-                // there is no response entity-body\n", 
            "-                responseMsgCtx.setProperty(PassThroughConstants.NO_ENTITY_BODY, Boolean.TRUE);\n", 
            "-                responseMsgCtx.setEnvelope(new SOAP11Factory().getDefaultEnvelope());\n", 
            "-            }\n", 
            "-\n", 
            "-            // copy the HTTP status code as a message context property with the key HTTP_SC to be\n", 
            "-            // used at the sender to set the proper status code when passing the message\n", 
            "-            int statusCode = this.response.getStatus();\n", 
            "-            responseMsgCtx.setProperty(PassThroughConstants.HTTP_SC, statusCode);\n", 
            "-            if (statusCode >= 400) {\n", 
            "-                responseMsgCtx.setProperty(PassThroughConstants.FAULT_MESSAGE,\n", 
            "-                        PassThroughConstants.TRUE);\n", 
            "-            } /*else if (statusCode == 202 && responseMsgCtx.getOperationContext().isComplete()) {\n", 
            "-                // Handle out-only invocation scenario\n", 
            "-                responseMsgCtx.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED, Boolean.TRUE);\n", 
            "-            }*/\n", 
            "-            responseMsgCtx.setProperty(PassThroughConstants.NON_BLOCKING_TRANSPORT, true);\n", 
            "-\n", 
            "-            // process response received\n", 
            "-            try {\n", 
            "-                AxisEngine.receive(responseMsgCtx);\n", 
            "-            } catch (AxisFault af) {\n", 
            "-                log.error(\"Fault processing response message through Axis2\", af);\n", 
            "-            }\n", 
            "-\n", 
            "-        } catch (AxisFault af) {\n", 
            "-            log.error(\"Fault creating response SOAP envelope\", af);            \n", 
            "-        } catch (IOException e) {\n", 
            "-            log.error(\"Error closing input stream from which message was read\", e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private String inferContentType() {\n", 
            "-        // Try to get the content type from the message context\n", 
            "-        Object cTypeProperty = responseMsgCtx.getProperty(PassThroughConstants.CONTENT_TYPE);\n", 
            "-        if (cTypeProperty != null) {\n", 
            "-            return cTypeProperty.toString();\n", 
            "-        }\n", 
            "-        // Try to get the content type from the axis configuration\n", 
            "-        Parameter cTypeParam = cfgCtx.getAxisConfiguration().getParameter(\n", 
            "-                PassThroughConstants.CONTENT_TYPE);\n", 
            "-        if (cTypeParam != null) {\n", 
            "-            return cTypeParam.getValue().toString();\n", 
            "-        }\n", 
            "-        // Unable to determine the content type - Return default value\n", 
            "-        return PassThroughConstants.DEFAULT_CONTENT_TYPE;\n", 
            "-    }\n", 
            "-\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ClientWorker.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ClientWorker.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,167 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.http.*;\n", 
            "-import org.apache.http.message.BasicHttpResponse;\n", 
            "-import org.apache.http.nio.ContentDecoder;\n", 
            "-import org.apache.http.nio.NHttpServerConnection;\n", 
            "-import org.apache.synapse.transport.passthru.config.SourceConfiguration;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-import java.util.HashMap;\n", 
            "-import java.util.Map;\n", 
            "-\n", 
            "-/**\n", 
            "- * Represents a Http Request.\n", 
            "- */\n", 
            "-public class SourceRequest {\n", 
            "-    // private Log log = LogFactory.getLog(SourceRequest.class);\n", 
            "-\n", 
            "-    private Pipe pipe = null;\n", 
            "-    /** HTTP Headers */\n", 
            "-    private Map<String, String> headers = new HashMap<String, String>();\n", 
            "-    /** HTTP URL */\n", 
            "-    private String url;\n", 
            "-    /** HTTP Method */\n", 
            "-    private String method;\n", 
            "-    /** Weather reqyest has a body */\n", 
            "-    private boolean entityEnclosing;\n", 
            "-    /** The http request */\n", 
            "-    private HttpRequest request = null;\n", 
            "-    /** Configuration of the receiver */\n", 
            "-    private SourceConfiguration sourceConfiguration;\n", 
            "-    /** HTTP Version */\n", 
            "-    private ProtocolVersion version = null;\n", 
            "-    /** The connection from the client */\n", 
            "-    private NHttpServerConnection connection = null;\n", 
            "-\n", 
            "-    public SourceRequest(SourceConfiguration sourceConfiguration,\n", 
            "-                         HttpRequest request,\n", 
            "-                         NHttpServerConnection conn) {\n", 
            "-        this.sourceConfiguration = sourceConfiguration;\n", 
            "-        this.request = request;\n", 
            "-        this.connection = conn;\n", 
            "-\n", 
            "-        this.url = request.getRequestLine().getUri();\n", 
            "-        this.method = request.getRequestLine().getMethod();\n", 
            "-        this.entityEnclosing = request instanceof HttpEntityEnclosingRequest;\n", 
            "-        this.version = request.getProtocolVersion();\n", 
            "-\n", 
            "-        this.version = request.getRequestLine().getProtocolVersion();\n", 
            "-        if (!version.lessEquals(HttpVersion.HTTP_1_1)) {\n", 
            "-            // Downgrade protocol version if greater than HTTP/1.1\n", 
            "-            this.version = HttpVersion.HTTP_1_1;\n", 
            "-        }\n", 
            "-\n", 
            "-        Header[] headers = request.getAllHeaders();\n", 
            "-        if (headers != null) {\n", 
            "-            for (Header header : headers) {\n", 
            "-                this.headers.put(header.getName(), header.getValue());\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Start processing the request by connecting the pipe if this request has an entity body.\n", 
            "-     * @param conn connection\n", 
            "-     * @throws IOException if an error occurs\n", 
            "-     * @throws HttpException if an error occurs\n", 
            "-     */\n", 
            "-    public void start(NHttpServerConnection conn) throws IOException, HttpException {\n", 
            "-        if (entityEnclosing) {\n", 
            "-            pipe = new Pipe(conn, sourceConfiguration.getBufferFactory().getBuffer(), \"source\", sourceConfiguration);\n", 
            "-\n", 
            "-            SourceContext.get(conn).setReader(pipe);\n", 
            "-\n", 
            "-            // See if the client expects a 100-Continue\n", 
            "-            if (((HttpEntityEnclosingRequest) request).expectContinue()) {\n", 
            "-                HttpResponse ack = new BasicHttpResponse(version, HttpStatus.SC_CONTINUE, \"Continue\");\n", 
            "-                conn.submitResponse(ack);\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            // this request is completed, there is nothing more to read\n", 
            "-            SourceContext.updateState(conn, ProtocolState.REQUEST_DONE);\n", 
            "-            // No httpRequest content expected. Suspend client input\n", 
            "-            conn.suspendInput();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Produce the content in to the pipe.\n", 
            "-     * @param conn the connection\n", 
            "-     * @param decoder content decoder\n", 
            "-     *\n", 
            "-     * @throws java.io.IOException if an error occurs\n", 
            "-     * @return number of bytes read\n", 
            "-     */\n", 
            "-    public int read(NHttpServerConnection conn, ContentDecoder decoder) throws IOException {\n", 
            "-        if (pipe == null) {\n", 
            "-            throw new IllegalStateException(\"A Pipe must be connected before calling read\");\n", 
            "-        }\n", 
            "-\n", 
            "-        if (entityEnclosing) {\n", 
            "-            int bytes = pipe.produce(decoder);\n", 
            "-\n", 
            "-            if (decoder.isCompleted()) {\n", 
            "-                sourceConfiguration.getMetrics().\n", 
            "-                        notifyReceivedMessageSize(conn.getMetrics().getReceivedBytesCount());\n", 
            "-\n", 
            "-                // Update connection state\n", 
            "-                SourceContext.updateState(conn, ProtocolState.REQUEST_DONE);\n", 
            "-                // Suspend client input\n", 
            "-                conn.suspendInput();\n", 
            "-            }\n", 
            "-            return bytes;\n", 
            "-        } else {\n", 
            "-            throw new IllegalStateException(\"Only Entity Enclosing Requests \" +\n", 
            "-                    \"can read content in to the pipe\");\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public Map<String, String> getHeaders() {\n", 
            "-        return headers;\n", 
            "-    }\n", 
            "-\n", 
            "-    public String getUri() {\n", 
            "-        return url;\n", 
            "-    }\n", 
            "-\n", 
            "-    public String getMethod() {\n", 
            "-        return method;\n", 
            "-    }\n", 
            "-\n", 
            "-    public Pipe getPipe() {\n", 
            "-        return pipe;\n", 
            "-    }\n", 
            "-\n", 
            "-    public NHttpServerConnection getConnection() {\n", 
            "-        return connection;\n", 
            "-    }\n", 
            "-\n", 
            "-    public ProtocolVersion getVersion() {\n", 
            "-        return version;\n", 
            "-    }\n", 
            "-\n", 
            "-    public HttpRequest getRequest() {\n", 
            "-        return request;\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean isEntityEnclosing() {\n", 
            "-        return entityEnclosing;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceRequest.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceRequest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,44 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.http.impl.nio.DefaultServerIOEventDispatch;\n", 
            "-import org.apache.http.nio.NHttpServiceHandler;\n", 
            "-import org.apache.http.nio.NHttpServerIOTarget;\n", 
            "-import org.apache.http.nio.reactor.IOSession;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-import org.apache.synapse.transport.passthru.logging.LoggingUtils;\n", 
            "-\n", 
            "-/**\n", 
            "- * This is a factory for creating the logging sessions or non-logging sessions.\n", 
            "- */\n", 
            "-public class SourceIOEventDispatch extends DefaultServerIOEventDispatch {\n", 
            "-\n", 
            "-    public SourceIOEventDispatch(final NHttpServiceHandler handler, final HttpParams params) {\n", 
            "-        super(LoggingUtils.decorate(handler), params);\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    protected NHttpServerIOTarget createConnection(IOSession session) {\n", 
            "-        session = LoggingUtils.decorate(session, \"server\");\n", 
            "-        return LoggingUtils.createServerConnection(\n", 
            "-                session,\n", 
            "-                createHttpRequestFactory(),\n", 
            "-                this.allocator,\n", 
            "-                this.params);\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceIOEventDispatch.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceIOEventDispatch.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,577 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "- *  or more contributor license agreements.  See the NOTICE file\n", 
            "- *  distributed with this work for additional information\n", 
            "- *  regarding copyright ownership.  The ASF licenses this file\n", 
            "- *  to you under the Apache License, Version 2.0 (the\n", 
            "- *  \"License\"); you may not use this file except in compliance\n", 
            "- *  with the License.  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing,\n", 
            "- *  software distributed under the License is distributed on an\n", 
            "- *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "- *  KIND, either express or implied.  See the License for the\n", 
            "- *  specific language governing permissions and limitations\n", 
            "- *  under the License.\n", 
            "- */\n", 
            "-\n", 
            "-\n", 
            "-/**\n", 
            "- * ************************************************************************\n", 
            "- * Copied from the not-yet-commons-ssl project at http://juliusdavies.ca/commons-ssl/\n", 
            "- * As the above project is accepted into Apache and its JARs become available in\n", 
            "- * the Maven 2 repos, we will have to switch to using the JARs instead\n", 
            "- * ************************************************************************\n", 
            "- * <p/>\n", 
            "- * Interface for checking if a hostname matches the names stored inside the\n", 
            "- * server's X.509 certificate.  Correctly implements\n", 
            "- * javax.net.ssl.HostnameVerifier, but that interface is not recommended.\n", 
            "- * Instead we added several check() methods that take SSLSocket,\n", 
            "- * or X509Certificate, or ultimately (they all end up calling this one),\n", 
            "- * String.  (It's easier to supply JUnit with Strings instead of mock\n", 
            "- * SSLSession objects!)\n", 
            "- * </p><p>Our check() methods throw exceptions if the name is\n", 
            "- * invalid, whereas javax.net.ssl.HostnameVerifier just returns true/false.\n", 
            "- * <p/>\n", 
            "- * We provide the HostnameVerifier.DEFAULT, HostnameVerifier.STRICT, and\n", 
            "- * HostnameVerifier.ALLOW_ALL implementations.  We also provide the more\n", 
            "- * specialized HostnameVerifier.DEFAULT_AND_LOCALHOST, as well as\n", 
            "- * HostnameVerifier.STRICT_IE6.  But feel free to define your own\n", 
            "- * implementations!\n", 
            "- * <p/>\n", 
            "- * Inspired by Sebastian Hauer's original StrictSSLProtocolSocketFactory in the\n", 
            "- * HttpClient \"contrib\" repository.\n", 
            "- *\n", 
            "- * @author Julius Davies\n", 
            "- * @author <a href=\"mailto:hauer@psicode.com\">Sebastian Hauer</a>\n", 
            "- * @since 8-Dec-2006\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import javax.net.ssl.SSLException;\n", 
            "-import javax.net.ssl.SSLPeerUnverifiedException;\n", 
            "-import javax.net.ssl.SSLSession;\n", 
            "-import javax.net.ssl.SSLSocket;\n", 
            "-import java.io.IOException;\n", 
            "-import java.io.InputStream;\n", 
            "-import java.security.cert.Certificate;\n", 
            "-import java.security.cert.CertificateParsingException;\n", 
            "-import java.security.cert.X509Certificate;\n", 
            "-import java.util.*;\n", 
            "-\n", 
            "-public interface HostnameVerifier extends javax.net.ssl.HostnameVerifier {\n", 
            "-\n", 
            "-    boolean verify(String host, SSLSession session);\n", 
            "-\n", 
            "-    void check(String host, SSLSocket ssl) throws IOException;\n", 
            "-\n", 
            "-    void check(String host, X509Certificate cert) throws SSLException;\n", 
            "-\n", 
            "-    void check(String host, String[] cns, String[] subjectAlts)\n", 
            "-        throws SSLException;\n", 
            "-\n", 
            "-    void check(String[] hosts, SSLSocket ssl) throws IOException;\n", 
            "-\n", 
            "-    void check(String[] hosts, X509Certificate cert) throws SSLException;\n", 
            "-\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Checks to see if the supplied hostname matches any of the supplied CNs\n", 
            "-     * or \"DNS\" Subject-Alts.  Most implementations only look at the first CN,\n", 
            "-     * and ignore any additional CNs.  Most implementations do look at all of\n", 
            "-     * the \"DNS\" Subject-Alts. The CNs or Subject-Alts may contain wildcards\n", 
            "-     * according to RFC 2818.\n", 
            "-     *\n", 
            "-     * @param cns         CN fields, in order, as extracted from the X.509\n", 
            "-     *                    certificate.\n", 
            "-     * @param subjectAlts Subject-Alt fields of type 2 (\"DNS\"), as extracted\n", 
            "-     *                    from the X.509 certificate.\n", 
            "-     * @param hosts       The array of hostnames to verify.\n", 
            "-     * @throws SSLException If verification failed.\n", 
            "-     */\n", 
            "-    void check(String[] hosts, String[] cns, String[] subjectAlts)\n", 
            "-        throws SSLException;\n", 
            "-\n", 
            "-\n", 
            "-    /**\n", 
            "-     * The DEFAULT HostnameVerifier works the same way as Curl and Firefox.\n", 
            "-     * <p/>\n", 
            "-     * The hostname must match either the first CN, or any of the subject-alts.\n", 
            "-     * A wildcard can occur in the CN, and in any of the subject-alts.\n", 
            "-     * <p/>\n", 
            "-     * The only difference between DEFAULT and STRICT is that a wildcard (such\n", 
            "-     * as \"*.foo.com\") with DEFAULT matches all subdomains, including\n", 
            "-     * \"a.b.foo.com\".\n", 
            "-     */\n", 
            "-    public final static HostnameVerifier DEFAULT =\n", 
            "-        new AbstractVerifier() {\n", 
            "-            public final void check(final String[] hosts, final String[] cns,\n", 
            "-                final String[] subjectAlts)\n", 
            "-                throws SSLException {\n", 
            "-                check(hosts, cns, subjectAlts, false, false);\n", 
            "-            }\n", 
            "-\n", 
            "-            public final String toString() {\n", 
            "-                return \"DEFAULT\";\n", 
            "-            }\n", 
            "-        };\n", 
            "-\n", 
            "-\n", 
            "-    /**\n", 
            "-     * The DEFAULT_AND_LOCALHOST HostnameVerifier works like the DEFAULT\n", 
            "-     * one with one additional relaxation:  a host of \"localhost\",\n", 
            "-     * \"localhost.localdomain\", \"127.0.0.1\", \"::1\" will always pass, no matter\n", 
            "-     * what is in the server's certificate.\n", 
            "-     */\n", 
            "-    public final static HostnameVerifier DEFAULT_AND_LOCALHOST =\n", 
            "-        new AbstractVerifier() {\n", 
            "-            public final void check(final String[] hosts, final String[] cns,\n", 
            "-                final String[] subjectAlts)\n", 
            "-                throws SSLException {\n", 
            "-                if (isLocalhost(hosts[0])) {\n", 
            "-                    return;\n", 
            "-                }\n", 
            "-                check(hosts, cns, subjectAlts, false, false);\n", 
            "-            }\n", 
            "-\n", 
            "-            public final String toString() {\n", 
            "-                return \"DEFAULT_AND_LOCALHOST\";\n", 
            "-            }\n", 
            "-        };\n", 
            "-\n", 
            "-    /**\n", 
            "-     * The STRICT HostnameVerifier works the same way as java.net.URL in Sun\n", 
            "-     * Java 1.4, Sun Java 5, Sun Java 6.  It's also pretty close to IE6.\n", 
            "-     * This implementation appears to be compliant with RFC 2818 for dealing\n", 
            "-     * with wildcards.\n", 
            "-     * <p/>\n", 
            "-     * The hostname must match either the first CN, or any of the subject-alts.\n", 
            "-     * A wildcard can occur in the CN, and in any of the subject-alts.  The\n", 
            "-     * one divergence from IE6 is how we only check the first CN.  IE6 allows\n", 
            "-     * a match against any of the CNs present.  We decided to follow in\n", 
            "-     * Sun Java 1.4's footsteps and only check the first CN.\n", 
            "-     * <p/>\n", 
            "-     * A wildcard such as \"*.foo.com\" matches only subdomains in the same\n", 
            "-     * level, for example \"a.foo.com\".  It does not match deeper subdomains\n", 
            "-     * such as \"a.b.foo.com\".\n", 
            "-     */\n", 
            "-    public final static HostnameVerifier STRICT =\n", 
            "-        new AbstractVerifier() {\n", 
            "-            public final void check(final String[] host, final String[] cns,\n", 
            "-                final String[] subjectAlts)\n", 
            "-                throws SSLException {\n", 
            "-                check(host, cns, subjectAlts, false, true);\n", 
            "-            }\n", 
            "-\n", 
            "-            public final String toString() {\n", 
            "-                return \"STRICT\";\n", 
            "-            }\n", 
            "-        };\n", 
            "-\n", 
            "-    /**\n", 
            "-     * The STRICT_IE6 HostnameVerifier works just like the STRICT one with one\n", 
            "-     * minor variation:  the hostname can match against any of the CN's in the\n", 
            "-     * server's certificate, not just the first one.  This behaviour is\n", 
            "-     * identical to IE6's behaviour.\n", 
            "-     */\n", 
            "-    public final static HostnameVerifier STRICT_IE6 =\n", 
            "-        new AbstractVerifier() {\n", 
            "-            public final void check(final String[] host, final String[] cns,\n", 
            "-                final String[] subjectAlts)\n", 
            "-                throws SSLException {\n", 
            "-                check(host, cns, subjectAlts, true, true);\n", 
            "-            }\n", 
            "-\n", 
            "-            public final String toString() {\n", 
            "-                return \"STRICT_IE6\";\n", 
            "-            }\n", 
            "-        };\n", 
            "-\n", 
            "-    /**\n", 
            "-     * The ALLOW_ALL HostnameVerifier essentially turns hostname verification\n", 
            "-     * off.  This implementation is a no-op, and never throws the SSLException.\n", 
            "-     */\n", 
            "-    public final static HostnameVerifier ALLOW_ALL =\n", 
            "-        new AbstractVerifier() {\n", 
            "-            public final void check(final String[] host, final String[] cns,\n", 
            "-                final String[] subjectAlts) {\n", 
            "-                // Allow everything - so never blowup.\n", 
            "-            }\n", 
            "-\n", 
            "-            public final String toString() {\n", 
            "-                return \"ALLOW_ALL\";\n", 
            "-            }\n", 
            "-        };\n", 
            "-\n", 
            "-    abstract class AbstractVerifier implements HostnameVerifier {\n", 
            "-\n", 
            "-        /**\n", 
            "-         * This contains a list of 2nd-level domains that aren't allowed to\n", 
            "-         * have wildcards when combined with country-codes.\n", 
            "-         * For example: [*.co.uk].\n", 
            "-         * <p/>\n", 
            "-         * The [*.co.uk] problem is an interesting one.  Should we just hope\n", 
            "-         * that CA's would never foolishly allow such a certificate to happen?\n", 
            "-         * Looks like we're the only implementation guarding against this.\n", 
            "-         * Firefox, Curl, Sun Java 1.4, 5, 6 don't bother with this check.\n", 
            "-         */\n", 
            "-        private final static String[] BAD_COUNTRY_2LDS =\n", 
            "-            {\"ac\", \"co\", \"com\", \"ed\", \"edu\", \"go\", \"gouv\", \"gov\", \"info\",\n", 
            "-                \"lg\", \"ne\", \"net\", \"or\", \"org\"};\n", 
            "-\n", 
            "-        private final static String[] LOCALHOSTS = {\"::1\", \"127.0.0.1\",\n", 
            "-            \"localhost\",\n", 
            "-            \"localhost.localdomain\"};\n", 
            "-\n", 
            "-\n", 
            "-        static {\n", 
            "-            // Just in case developer forgot to manually sort the array.  :-)\n", 
            "-            Arrays.sort(BAD_COUNTRY_2LDS);\n", 
            "-            Arrays.sort(LOCALHOSTS);\n", 
            "-        }\n", 
            "-\n", 
            "-        protected AbstractVerifier() {\n", 
            "-        }\n", 
            "-\n", 
            "-        /**\n", 
            "-         * The javax.net.ssl.HostnameVerifier contract.\n", 
            "-         *\n", 
            "-         * @param host    'hostname' we used to create our socket\n", 
            "-         * @param session SSLSession with the remote server\n", 
            "-         * @return true if the host matched the one in the certificate.\n", 
            "-         */\n", 
            "-        public boolean verify(String host, SSLSession session) {\n", 
            "-            try {\n", 
            "-                Certificate[] certs = session.getPeerCertificates();\n", 
            "-                X509Certificate x509 = (X509Certificate) certs[0];\n", 
            "-                check(new String[]{host}, x509);\n", 
            "-                return true;\n", 
            "-            }\n", 
            "-            catch (SSLException e) {\n", 
            "-                return false;\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        public void check(String host, SSLSocket ssl) throws IOException {\n", 
            "-            check(new String[]{host}, ssl);\n", 
            "-        }\n", 
            "-\n", 
            "-        public void check(String host, X509Certificate cert)\n", 
            "-            throws SSLException {\n", 
            "-            check(new String[]{host}, cert);\n", 
            "-        }\n", 
            "-\n", 
            "-        public void check(String host, String[] cns, String[] subjectAlts)\n", 
            "-            throws SSLException {\n", 
            "-            check(new String[]{host}, cns, subjectAlts);\n", 
            "-        }\n", 
            "-\n", 
            "-        public void check(String host[], SSLSocket ssl)\n", 
            "-            throws IOException {\n", 
            "-            if (host == null) {\n", 
            "-                throw new NullPointerException(\"host to verify is null\");\n", 
            "-            }\n", 
            "-\n", 
            "-            SSLSession session = ssl.getSession();\n", 
            "-            if (session == null) {\n", 
            "-                // In our experience this only happens under IBM 1.4.x when\n", 
            "-                // spurious (unrelated) certificates show up in the server'\n", 
            "-                // chain.  Hopefully this will unearth the real problem:\n", 
            "-                InputStream in = ssl.getInputStream();\n", 
            "-                in.available();\n", 
            "-                /*\n", 
            "-                  If you're looking at the 2 lines of code above because\n", 
            "-                  you're running into a problem, you probably have two\n", 
            "-                  options:\n", 
            "-\n", 
            "-                    #1.  Clean up the certificate chain that your server\n", 
            "-                         is presenting (e.g. edit \"/etc/apache2/server.crt\"\n", 
            "-                         or wherever it is your server's certificate chain\n", 
            "-                         is defined).\n", 
            "-\n", 
            "-                                               OR\n", 
            "-\n", 
            "-                    #2.   Upgrade to an IBM 1.5.x or greater JVM, or switch\n", 
            "-                          to a non-IBM JVM.\n", 
            "-                */\n", 
            "-\n", 
            "-                // If ssl.getInputStream().available() didn't cause an\n", 
            "-                // exception, maybe at least now the session is available?\n", 
            "-                session = ssl.getSession();\n", 
            "-                if (session == null) {\n", 
            "-                    // If it's still null, probably a startHandshake() will\n", 
            "-                    // unearth the real problem.\n", 
            "-                    ssl.startHandshake();\n", 
            "-\n", 
            "-                    // Okay, if we still haven't managed to cause an exception,\n", 
            "-                    // might as well go for the NPE.  Or maybe we're okay now?\n", 
            "-                    session = ssl.getSession();\n", 
            "-                }\n", 
            "-            }\n", 
            "-            Certificate[] certs;\n", 
            "-            try {\n", 
            "-                certs = session.getPeerCertificates();\n", 
            "-            } catch (SSLPeerUnverifiedException spue) {\n", 
            "-                InputStream in = ssl.getInputStream();\n", 
            "-                in.available();\n", 
            "-                // Didn't trigger anything interesting?  Okay, just throw\n", 
            "-                // original.\n", 
            "-                throw spue;\n", 
            "-            }\n", 
            "-            X509Certificate x509 = (X509Certificate) certs[0];\n", 
            "-            check(host, x509);\n", 
            "-        }\n", 
            "-\n", 
            "-        public void check(String[] host, X509Certificate cert)\n", 
            "-            throws SSLException {\n", 
            "-\n", 
            "-            String[] cns = Certificates.getCNs(cert);\n", 
            "-            String[] subjectAlts = Certificates.getDNSSubjectAlts(cert);\n", 
            "-            check(host, cns, subjectAlts);\n", 
            "-\n", 
            "-        }\n", 
            "-\n", 
            "-        public void check(final String[] hosts, final String[] cns,\n", 
            "-            final String[] subjectAlts, final boolean ie6,\n", 
            "-            final boolean strictWithSubDomains)\n", 
            "-            throws SSLException {\n", 
            "-            // Build up lists of allowed hosts For logging/debugging purposes.\n", 
            "-            StringBuffer buf = new StringBuffer(32);\n", 
            "-            buf.append('<');\n", 
            "-            for (int i = 0; i < hosts.length; i++) {\n", 
            "-                String h = hosts[i];\n", 
            "-                h = h != null ? h.trim().toLowerCase() : \"\";\n", 
            "-                hosts[i] = h;\n", 
            "-                if (i > 0) {\n", 
            "-                    buf.append('/');\n", 
            "-                }\n", 
            "-                buf.append(h);\n", 
            "-            }\n", 
            "-            buf.append('>');\n", 
            "-            String hostnames = buf.toString();\n", 
            "-            // Build the list of names we're going to check.  Our DEFAULT and\n", 
            "-            // STRICT implementations of the HostnameVerifier only use the\n", 
            "-            // first CN provided.  All other CNs are ignored.\n", 
            "-            // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).\n", 
            "-            TreeSet names = new TreeSet();\n", 
            "-            if (cns != null && cns.length > 0 && cns[0] != null) {\n", 
            "-                names.add(cns[0]);\n", 
            "-                if (ie6) {\n", 
            "-                    for (int i = 1; i < cns.length; i++) {\n", 
            "-                        names.add(cns[i]);\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            }\n", 
            "-            if (subjectAlts != null) {\n", 
            "-                for (int i = 0; i < subjectAlts.length; i++) {\n", 
            "-                    if (subjectAlts[i] != null) {\n", 
            "-                        names.add(subjectAlts[i]);\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            }\n", 
            "-            if (names.isEmpty()) {\n", 
            "-                String msg = \"Certificate for \" + hosts[0] + \" doesn't contain CN or DNS subjectAlt\";\n", 
            "-                throw new SSLException(msg);\n", 
            "-            }\n", 
            "-\n", 
            "-            // StringBuffer for building the error message.\n", 
            "-            buf = new StringBuffer();\n", 
            "-\n", 
            "-            boolean match = false;\n", 
            "-            out:\n", 
            "-            for (Iterator it = names.iterator(); it.hasNext();) {\n", 
            "-                // Don't trim the CN, though!\n", 
            "-                String cn = (String) it.next();\n", 
            "-                cn = cn.toLowerCase();\n", 
            "-                // Store CN in StringBuffer in case we need to report an error.\n", 
            "-                buf.append(\" <\");\n", 
            "-                buf.append(cn);\n", 
            "-                buf.append('>');\n", 
            "-                if (it.hasNext()) {\n", 
            "-                    buf.append(\" OR\");\n", 
            "-                }\n", 
            "-\n", 
            "-                // The CN better have at least two dots if it wants wildcard\n", 
            "-                // action.  It also can't be [*.co.uk] or [*.co.jp] or\n", 
            "-                // [*.org.uk], etc...\n", 
            "-                boolean doWildcard = cn.startsWith(\"*.\") &&\n", 
            "-                    cn.lastIndexOf('.') >= 0 &&\n", 
            "-                    !isIP4Address(cn) &&\n", 
            "-                    acceptableCountryWildcard(cn);\n", 
            "-\n", 
            "-                for (int i = 0; i < hosts.length; i++) {\n", 
            "-                    final String hostName = hosts[i].trim().toLowerCase();\n", 
            "-                    if (doWildcard) {\n", 
            "-                        match = hostName.endsWith(cn.substring(1));\n", 
            "-                        if (match && strictWithSubDomains) {\n", 
            "-                            // If we're in strict mode, then [*.foo.com] is not\n", 
            "-                            // allowed to match [a.b.foo.com]\n", 
            "-                            match = countDots(hostName) == countDots(cn);\n", 
            "-                        }\n", 
            "-                    } else {\n", 
            "-                        match = hostName.equals(cn);\n", 
            "-                    }\n", 
            "-                    if (match) {\n", 
            "-                        break out;\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            }\n", 
            "-            if (!match) {\n", 
            "-                throw new SSLException(\"hostname in certificate didn't match: \" + hostnames + \" !=\" + buf);\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        public static boolean isIP4Address(final String cn) {\n", 
            "-            boolean isIP4 = true;\n", 
            "-            String tld = cn;\n", 
            "-            int x = cn.lastIndexOf('.');\n", 
            "-            // We only bother analyzing the characters after the final dot\n", 
            "-            // in the name.\n", 
            "-            if (x >= 0 && x + 1 < cn.length()) {\n", 
            "-                tld = cn.substring(x + 1);\n", 
            "-            }\n", 
            "-            for (int i = 0; i < tld.length(); i++) {\n", 
            "-                if (!Character.isDigit(tld.charAt(0))) {\n", 
            "-                    isIP4 = false;\n", 
            "-                    break;\n", 
            "-                }\n", 
            "-            }\n", 
            "-            return isIP4;\n", 
            "-        }\n", 
            "-\n", 
            "-        public static boolean acceptableCountryWildcard(final String cn) {\n", 
            "-            int cnLen = cn.length();\n", 
            "-            if (cnLen >= 7 && cnLen <= 9) {\n", 
            "-                // Look for the '.' in the 3rd-last position:\n", 
            "-                if (cn.charAt(cnLen - 3) == '.') {\n", 
            "-                    // Trim off the [*.] and the [.XX].\n", 
            "-                    String s = cn.substring(2, cnLen - 3);\n", 
            "-                    // And test against the sorted array of bad 2lds:\n", 
            "-                    int x = Arrays.binarySearch(BAD_COUNTRY_2LDS, s);\n", 
            "-                    return x < 0;\n", 
            "-                }\n", 
            "-            }\n", 
            "-            return true;\n", 
            "-        }\n", 
            "-\n", 
            "-        public static boolean isLocalhost(String host) {\n", 
            "-            host = host != null ? host.trim().toLowerCase() : \"\";\n", 
            "-            if (host.startsWith(\"::1\")) {\n", 
            "-                int x = host.lastIndexOf('%');\n", 
            "-                if (x >= 0) {\n", 
            "-                    host = host.substring(0, x);\n", 
            "-                }\n", 
            "-            }\n", 
            "-            int x = Arrays.binarySearch(LOCALHOSTS, host);\n", 
            "-            return x >= 0;\n", 
            "-        }\n", 
            "-\n", 
            "-        /**\n", 
            "-         * Counts the number of dots \".\" in a string.\n", 
            "-         *\n", 
            "-         * @param s string to count dots from\n", 
            "-         * @return number of dots\n", 
            "-         */\n", 
            "-        public static int countDots(final String s) {\n", 
            "-            int count = 0;\n", 
            "-            for (int i = 0; i < s.length(); i++) {\n", 
            "-                if (s.charAt(i) == '.') {\n", 
            "-                    count++;\n", 
            "-                }\n", 
            "-            }\n", 
            "-            return count;\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    class Certificates {\n", 
            "-        public static String[] getCNs(X509Certificate cert) {\n", 
            "-            LinkedList cnList = new LinkedList();\n", 
            "-            /*\n", 
            "-           Sebastian Hauer's original StrictSSLProtocolSocketFactory used\n", 
            "-           getName() and had the following comment:\n", 
            "-\n", 
            "-              Parses a X.500 distinguished name for the value of the\n", 
            "-              \"Common Name\" field.  This is done a bit sloppy right\n", 
            "-              now and should probably be done a bit more according to\n", 
            "-              <code>RFC 2253</code>.\n", 
            "-\n", 
            "-            I've noticed that toString() seems to do a better job than\n", 
            "-            getName() on these X500Principal objects, so I'm hoping that\n", 
            "-            addresses Sebastian's concern.\n", 
            "-\n", 
            "-            For example, getName() gives me this:\n", 
            "-            1.2.840.113549.1.9.1=#16166a756c6975736461766965734063756362632e636f6d\n", 
            "-\n", 
            "-            whereas toString() gives me this:\n", 
            "-            EMAILADDRESS=juliusdavies@cucbc.com\n", 
            "-\n", 
            "-            Looks like toString() even works with non-ascii domain names!\n", 
            "-            I tested it with \"&#x82b1;&#x5b50;.co.jp\" and it worked fine.\n", 
            "-           */\n", 
            "-            String subjectPrincipal = cert.getSubjectX500Principal().toString();\n", 
            "-            StringTokenizer st = new StringTokenizer(subjectPrincipal, \",\");\n", 
            "-            while (st.hasMoreTokens()) {\n", 
            "-                String tok = st.nextToken();\n", 
            "-                int x = tok.indexOf(\"CN=\");\n", 
            "-                if (x >= 0) {\n", 
            "-                    cnList.add(tok.substring(x + 3));\n", 
            "-                }\n", 
            "-            }\n", 
            "-            if (!cnList.isEmpty()) {\n", 
            "-                String[] cns = new String[cnList.size()];\n", 
            "-                cnList.toArray(cns);\n", 
            "-                return cns;\n", 
            "-            } else {\n", 
            "-                return null;\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        /**\n", 
            "-         * Extracts the array of SubjectAlt DNS names from an X509Certificate.\n", 
            "-         * Returns null if there aren't any.\n", 
            "-         * <p/>\n", 
            "-         * Note:  Java doesn't appear able to extract international characters\n", 
            "-         * from the SubjectAlts.  It can only extract international characters\n", 
            "-         * from the CN field.\n", 
            "-         * <p/>\n", 
            "-         * (Or maybe the version of OpenSSL I'm using to test isn't storing the\n", 
            "-         * international characters correctly in the SubjectAlts?).\n", 
            "-         *\n", 
            "-         * @param cert X509Certificate\n", 
            "-         * @return Array of SubjectALT DNS names stored in the certificate.\n", 
            "-         */\n", 
            "-        public static String[] getDNSSubjectAlts(X509Certificate cert) {\n", 
            "-            LinkedList subjectAltList = new LinkedList();\n", 
            "-            Collection c = null;\n", 
            "-            try {\n", 
            "-                c = cert.getSubjectAlternativeNames();\n", 
            "-            }\n", 
            "-            catch (CertificateParsingException cpe) {\n", 
            "-                // Should probably log.debug() this?\n", 
            "-                cpe.printStackTrace();\n", 
            "-            }\n", 
            "-            if (c != null) {\n", 
            "-                Iterator it = c.iterator();\n", 
            "-                while (it.hasNext()) {\n", 
            "-                    List list = (List) it.next();\n", 
            "-                    int type = ((Integer) list.get(0)).intValue();\n", 
            "-                    // If type is 2, then we've got a dNSName\n", 
            "-                    if (type == 2) {\n", 
            "-                        String s = (String) list.get(1);\n", 
            "-                        subjectAltList.add(s);\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            }\n", 
            "-            if (!subjectAltList.isEmpty()) {\n", 
            "-                String[] subjectAlts = new String[subjectAltList.size()];\n", 
            "-                subjectAltList.toArray(subjectAlts);\n", 
            "-                return subjectAlts;\n", 
            "-            } else {\n", 
            "-                return null;\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/HostnameVerifier.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/HostnameVerifier.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,416 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.axiom.om.OMElement;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.addressing.EndpointReference;\n", 
            "-import org.apache.axis2.context.ConfigurationContext;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.context.SessionContext;\n", 
            "-import org.apache.axis2.description.*;\n", 
            "-import org.apache.axis2.engine.AxisConfiguration;\n", 
            "-import org.apache.axis2.engine.AxisEvent;\n", 
            "-import org.apache.axis2.engine.AxisObserver;\n", 
            "-import org.apache.axis2.transport.TransportListener;\n", 
            "-import org.apache.axis2.transport.base.BaseConstants;\n", 
            "-import org.apache.axis2.transport.base.BaseUtils;\n", 
            "-import org.apache.axis2.transport.base.threads.NativeThreadFactory;\n", 
            "-import org.apache.axis2.transport.base.threads.WorkerPool;\n", 
            "-import org.apache.axis2.util.JavaUtils;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.impl.nio.reactor.DefaultListeningIOReactor;\n", 
            "-import org.apache.http.impl.nio.reactor.SSLIOSessionHandler;\n", 
            "-import org.apache.http.nio.NHttpServiceHandler;\n", 
            "-import org.apache.http.nio.reactor.IOEventDispatch;\n", 
            "-import org.apache.http.nio.reactor.IOReactorException;\n", 
            "-import org.apache.http.nio.reactor.IOReactorExceptionHandler;\n", 
            "-import org.apache.http.nio.reactor.ListenerEndpoint;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-import org.apache.synapse.transport.passthru.config.SourceConfiguration;\n", 
            "-import org.apache.synapse.transport.passthru.jmx.MBeanRegistrar;\n", 
            "-import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;\n", 
            "-import org.apache.synapse.transport.passthru.jmx.TransportView;\n", 
            "-\n", 
            "-import javax.net.ssl.SSLContext;\n", 
            "-import java.io.IOException;\n", 
            "-import java.net.InetSocketAddress;\n", 
            "-import java.util.ArrayList;\n", 
            "-import java.util.HashMap;\n", 
            "-import java.util.Map;\n", 
            "-\n", 
            "-/**\n", 
            "- * This is the TransportListener listening for incoming connections. This class start the IOReactor\n", 
            "- * and registers the InRequest Handlers on it.\n", 
            "- */\n", 
            "-public class PassThroughHttpListener implements TransportListener {\n", 
            "-\n", 
            "-    protected Log log = LogFactory.getLog(this.getClass());\n", 
            "-\n", 
            "-    /** The reactor being used */\n", 
            "-    private DefaultListeningIOReactor ioReactor;\n", 
            "-\n", 
            "-    /** The configuration of the listener */\n", 
            "-    private SourceConfiguration sourceConfiguration = null;\n", 
            "-\n", 
            "-    /** SSLContext if this listener is a SSL listener */\n", 
            "-    private SSLContext sslContext = null;\n", 
            "-    \n", 
            "-    /** The SSL session handler that manages client authentication etc */\n", 
            "-    private SSLIOSessionHandler sslIOSessionHandler = null;\n", 
            "-\n", 
            "-    /** The custom URI map for the services if there are any */\n", 
            "-    private Map<String, String> serviceNameToEPRMap = new HashMap<String, String>();\n", 
            "-    /** The service name map for the custom URI if there are any */\n", 
            "-    private Map<String, String> eprToServiceNameMap = new HashMap<String, String>();\n", 
            "-    /** the axis observer that gets notified of service life cycle events*/\n", 
            "-    private final AxisObserver axisObserver = new GenericAxisObserver();\n", 
            "-\n", 
            "-    private volatile int state = BaseConstants.STOPPED;\n", 
            "-\n", 
            "-    private String namePrefix;\n", 
            "-\n", 
            "-    public void init(ConfigurationContext cfgCtx, TransportInDescription transportInDescription)\n", 
            "-            throws AxisFault {\n", 
            "-\n", 
            "-        log.info(\"Initializing Pass-through HTTP/S Listener...\");\n", 
            "-\n", 
            "-        Object obj = cfgCtx.getProperty(PassThroughConstants.PASS_THROUGH_TRANSPORT_WORKER_POOL);\n", 
            "-        WorkerPool workerPool = null;\n", 
            "-        if (obj != null) {\n", 
            "-            workerPool = (WorkerPool) obj;\n", 
            "-        }\n", 
            "-\n", 
            "-        // is this a SSL listener?\n", 
            "-        sslContext = getSSLContext(transportInDescription);\n", 
            "-        sslIOSessionHandler = getSSLIOSessionHandler(transportInDescription);\n", 
            "-\n", 
            "-        namePrefix = (sslContext == null) ? \"HTTP\" : \"HTTPS\";\n", 
            "-\n", 
            "-        sourceConfiguration = new SourceConfiguration(cfgCtx, transportInDescription, workerPool);\n", 
            "-        sourceConfiguration.build();\n", 
            "-\n", 
            "-        // register to receive updates on services for lifetime management\n", 
            "-        cfgCtx.getAxisConfiguration().addObservers(axisObserver);\n", 
            "-        cfgCtx.setProperty(PassThroughConstants.EPR_TO_SERVICE_NAME_MAP, eprToServiceNameMap);\n", 
            "-\n", 
            "-        cfgCtx.setProperty(PassThroughConstants.PASS_THROUGH_TRANSPORT_WORKER_POOL,\n", 
            "-                sourceConfiguration.getWorkerPool());\n", 
            "-\n", 
            "-        PassThroughTransportMetricsCollector metrics = new PassThroughTransportMetricsCollector(\n", 
            "-                                                            true, sslContext != null);\n", 
            "-\n", 
            "-        MBeanRegistrar.getInstance().registerMBean(\n", 
            "-                new TransportView(this, null, metrics, null), \"Transport\",\n", 
            "-                \"passthru-\" + namePrefix.toLowerCase() + \"-receiver\");\n", 
            "-        sourceConfiguration.setMetrics(metrics);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void start() throws AxisFault {\n", 
            "-\n", 
            "-        log.info(\"Starting Pass-through \" + namePrefix + \" Listener...\");\n", 
            "-\n", 
            "-        try {\n", 
            "-            String prefix = namePrefix + \"-Listener I/O dispatcher\";\n", 
            "-\n", 
            "-            ioReactor = new DefaultListeningIOReactor(\n", 
            "-                            sourceConfiguration.getIOThreadsPerReactor(),\n", 
            "-                            new NativeThreadFactory(new ThreadGroup(prefix + \" thread group\"), prefix),\n", 
            "-                            sourceConfiguration.getHttpParameters());\n", 
            "-            \n", 
            "-            ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {\n", 
            "-\n", 
            "-                public boolean handle(IOException ioException) {\n", 
            "-                    log.warn(\"System may be unstable: \" + namePrefix +\n", 
            "-                            \" ListeningIOReactor encountered a checked exception : \" +\n", 
            "-                            ioException.getMessage(), ioException);\n", 
            "-                    return true;\n", 
            "-                }\n", 
            "-\n", 
            "-                public boolean handle(RuntimeException runtimeException) {\n", 
            "-                    log.warn(\"System may be unstable: \" + namePrefix +\n", 
            "-                            \" ListeningIOReactor encountered a runtime exception : \"\n", 
            "-                            + runtimeException.getMessage(), runtimeException);\n", 
            "-                    return true;\n", 
            "-                }\n", 
            "-            });\n", 
            "-\n", 
            "-        } catch (IOReactorException e) {\n", 
            "-            handleException(\"Error starting \" + namePrefix + \" ListeningIOReactor\", e);\n", 
            "-        }\n", 
            "-\n", 
            "-        SourceHandler handler = new SourceHandler(sourceConfiguration);\n", 
            "-\n", 
            "-        final IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext,\n", 
            "-                                      sslIOSessionHandler, sourceConfiguration.getHttpParameters());\n", 
            "-\n", 
            "-        ListenerEndpoint endpoint = ioReactor.listen(\n", 
            "-                                      new InetSocketAddress(sourceConfiguration.getPort()));\n", 
            "-\n", 
            "-        Thread t = new Thread(new Runnable() {\n", 
            "-            public void run() {\n", 
            "-                try {\n", 
            "-                    ioReactor.execute(ioEventDispatch);\n", 
            "-                } catch (Exception e) {\n", 
            "-                    log.fatal(\"Exception encountered in the \" + namePrefix + \" Listener. \" +\n", 
            "-                            \"No more connections will be accepted by this transport\", e);\n", 
            "-                }\n", 
            "-                log.info(namePrefix + \" Listener shutdown.\");\n", 
            "-            }\n", 
            "-        }, \"PassThrough\" + namePrefix + \"Listener\");\n", 
            "-        t.start();\n", 
            "-\n", 
            "-        try {\n", 
            "-            endpoint.waitFor();\n", 
            "-        } catch (InterruptedException e) {\n", 
            "-            log.warn(\"PassThroughHttpListener start event was interrupted\", e);\n", 
            "-        }\n", 
            "-\n", 
            "-        state = BaseConstants.STARTED;\n", 
            "-\n", 
            "-        log.info(\"Pass-through \" + namePrefix + \" Listener \" + \"started on port : \" +\n", 
            "-                sourceConfiguration.getPort());\n", 
            "-    }\n", 
            "-\n", 
            "-    private void handleException(String s, Exception e) throws AxisFault {\n", 
            "-        log.error(s, e);\n", 
            "-        throw new AxisFault(s, e);\n", 
            "-    }\n", 
            "-\n", 
            "-    public EndpointReference getEPRForService(String serviceName, String ip) throws AxisFault {\n", 
            "-        String trailer = \"\";\n", 
            "-        //Strip out the operation name\n", 
            "-        if (serviceName.indexOf('/') != -1) {\n", 
            "-            trailer += serviceName.substring(serviceName.indexOf(\"/\"));\n", 
            "-            serviceName = serviceName.substring(0, serviceName.indexOf('/'));\n", 
            "-        }\n", 
            "-        // strip out the endpoint name if present\n", 
            "-        if (serviceName.indexOf('.') != -1) {\n", 
            "-            trailer += serviceName.substring(serviceName.indexOf(\".\"));\n", 
            "-            serviceName = serviceName.substring(0, serviceName.indexOf('.'));\n", 
            "-        }\n", 
            "-\n", 
            "-        if (serviceNameToEPRMap.containsKey(serviceName)) {\n", 
            "-            return new EndpointReference(\n", 
            "-                    sourceConfiguration.getCustomEPRPrefix() +\n", 
            "-                            serviceNameToEPRMap.get(serviceName) + trailer);\n", 
            "-        } else {\n", 
            "-            return new EndpointReference(sourceConfiguration.getServiceEPRPrefix() +\n", 
            "-                    serviceName + trailer);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Return the EPRs for the given service over this transport\n", 
            "-     * @param serviceName name of the service\n", 
            "-     * @param ip IP address\n", 
            "-     * @return the EndpointReferences for this service over the transport\n", 
            "-     * @throws AxisFault on error\n", 
            "-     */\n", 
            "-    public EndpointReference[] getEPRsForService(String serviceName, String ip) throws AxisFault {\n", 
            "-        String trailer = \"\";\n", 
            "-        //Strip out the operation name\n", 
            "-        if (serviceName.indexOf('/') != -1) {\n", 
            "-            trailer += serviceName.substring(serviceName.indexOf(\"/\"));\n", 
            "-            serviceName = serviceName.substring(0, serviceName.indexOf('/'));\n", 
            "-        }\n", 
            "-        // strip out the endpoint name if present\n", 
            "-        if (serviceName.indexOf('.') != -1) {\n", 
            "-            trailer += serviceName.substring(serviceName.indexOf(\".\"));\n", 
            "-            serviceName = serviceName.substring(0, serviceName.indexOf('.'));\n", 
            "-        }\n", 
            "-\n", 
            "-        EndpointReference[] endpointReferences = new EndpointReference[1];\n", 
            "-        if (serviceNameToEPRMap.containsKey(serviceName)) {\n", 
            "-            endpointReferences[0] = new EndpointReference(\n", 
            "-                    sourceConfiguration.getCustomEPRPrefix() +\n", 
            "-                            serviceNameToEPRMap.get(serviceName) + trailer);\n", 
            "-        } else {\n", 
            "-            endpointReferences[0]\n", 
            "-                    = new EndpointReference(sourceConfiguration.getServiceEPRPrefix() +\n", 
            "-                    serviceName + trailer);\n", 
            "-        }\n", 
            "-        return endpointReferences;\n", 
            "-    }\n", 
            "-\n", 
            "-    public SessionContext getSessionContext(MessageContext messageContext) {\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-\n", 
            "-    public void stop() throws AxisFault {\n", 
            "-        log.info(\"Stopping Pass-through \" + namePrefix + \" Listener..\");\n", 
            "-        try {\n", 
            "-            ioReactor.shutdown();\n", 
            "-        } catch (IOException e) {\n", 
            "-            handleException(\"Error shutting down \" + namePrefix + \" listening IO reactor\", e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void destroy() {\n", 
            "-        log.info(\"Destroying PassThroughHttpListener\");\n", 
            "-        sourceConfiguration.getConfigurationContext().\n", 
            "-                getAxisConfiguration().getObserversList().remove(axisObserver);\n", 
            "-\n", 
            "-        sourceConfiguration.getMetrics().destroy();\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Pause the listener - Stops accepting new connections, but continues processing existing\n", 
            "-     * connections until they complete. This helps bring an instance into a maintenance mode\n", 
            "-     *\n", 
            "-     * @throws AxisFault if pausing fails\n", 
            "-     */\n", 
            "-    public void pause() throws AxisFault {\n", 
            "-        if (state != BaseConstants.STARTED) return;\n", 
            "-        try {\n", 
            "-            ioReactor.pause();\n", 
            "-\n", 
            "-            state = BaseConstants.PAUSED;\n", 
            "-            log.info(namePrefix + \" Listener Paused\");\n", 
            "-        } catch (IOException e) {\n", 
            "-            handleException(\"Error pausing IOReactor\", e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Resume the lister - Brings the lister into active mode back from a paused state\n", 
            "-     *\n", 
            "-     * @throws AxisFault if the resume fails\n", 
            "-     */\n", 
            "-    public void resume() throws AxisFault {\n", 
            "-        if (state != BaseConstants.PAUSED) return;\n", 
            "-        try {\n", 
            "-            ioReactor.resume();\n", 
            "-            state = BaseConstants.STARTED;\n", 
            "-            log.info((sslContext == null ? \"HTTP\" : \"HTTPS\") + \"Listener Resumed\");\n", 
            "-        } catch (IOException e) {\n", 
            "-            handleException(\"Error resuming IOReactor\", e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Stop accepting new connections, and wait the maximum specified time for in-flight\n", 
            "-     * requests to complete before a controlled shutdown for maintenance\n", 
            "-     *\n", 
            "-     * @param milliSecs number of milliseconds to wait until pending requests complete\n", 
            "-     * @throws AxisFault if the shutdown fails\n", 
            "-     */\n", 
            "-    public void maintenanceShutdown(long milliSecs) throws AxisFault {\n", 
            "-        if (state != BaseConstants.STARTED) return;\n", 
            "-        try {\n", 
            "-            long start = System.currentTimeMillis();\n", 
            "-            ioReactor.pause();\n", 
            "-            ioReactor.shutdown(milliSecs);\n", 
            "-            state = BaseConstants.STOPPED;\n", 
            "-            log.info(\"Listener shutdown in : \" + (System.currentTimeMillis() - start) / 1000 + \"s\");\n", 
            "-        } catch (IOException e) {\n", 
            "-            handleException(\"Error shutting down the IOReactor for maintenance\", e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * An AxisObserver which will start listening for newly deployed or started services,\n", 
            "-     * and stop listening when services are un-deployed or stopped.\n", 
            "-     */\n", 
            "-    private class GenericAxisObserver implements AxisObserver {\n", 
            "-        public void init(AxisConfiguration axisConfig) {}\n", 
            "-\n", 
            "-        public void serviceUpdate(AxisEvent event, AxisService service) {\n", 
            "-            if (!ignoreService(service)\n", 
            "-                    && BaseUtils.isUsingTransport(service,\n", 
            "-                    sourceConfiguration.getInDescription().getName())) {\n", 
            "-                switch (event.getEventType()) {\n", 
            "-                    case AxisEvent.SERVICE_DEPLOY :\n", 
            "-                        addToServiceURIMap(service);\n", 
            "-                        break;\n", 
            "-                    case AxisEvent.SERVICE_REMOVE :\n", 
            "-                        removeServiceFfromURIMap(service);\n", 
            "-                        break;\n", 
            "-                    case AxisEvent.SERVICE_START  :\n", 
            "-                        addToServiceURIMap(service);\n", 
            "-                        break;\n", 
            "-                    case AxisEvent.SERVICE_STOP   :\n", 
            "-                        removeServiceFfromURIMap(service);\n", 
            "-                        break;\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        public void moduleUpdate(AxisEvent event, AxisModule module) {}\n", 
            "-        public void addParameter(Parameter parameter) throws AxisFault {}\n", 
            "-        public void removeParameter(Parameter parameter) throws AxisFault {}\n", 
            "-        public void deserializeParameters(OMElement parameterElement) throws AxisFault {}\n", 
            "-        public Parameter getParameter(String name) { return null; }\n", 
            "-        public ArrayList<Parameter> getParameters() { return null; }\n", 
            "-        public boolean isParameterLocked(String parameterName) { return false; }\n", 
            "-        public void serviceGroupUpdate(AxisEvent event, AxisServiceGroup serviceGroup) {}\n", 
            "-    }\n", 
            "-\n", 
            "-    private boolean ignoreService(AxisService service) {\n", 
            "-        // these are \"private\" services\n", 
            "-        return service.getName().startsWith(\"__\") || JavaUtils.isTrueExplicitly(\n", 
            "-                service.getParameter(PassThroughConstants.HIDDEN_SERVICE_PARAM_NAME));\n", 
            "-    }\n", 
            "-\n", 
            "-    private void addToServiceURIMap(AxisService service) {\n", 
            "-        Parameter param = service.getParameter(PassThroughConstants.SERVICE_URI_LOCATION);\n", 
            "-        if (param != null) {\n", 
            "-            String uriLocation = param.getValue().toString();\n", 
            "-            if (uriLocation.startsWith(\"/\")) {\n", 
            "-                uriLocation = uriLocation.substring(1);\n", 
            "-            }\n", 
            "-            serviceNameToEPRMap.put(service.getName(), uriLocation);\n", 
            "-            eprToServiceNameMap.put(uriLocation, service.getName());\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private void removeServiceFfromURIMap(AxisService service) {\n", 
            "-        eprToServiceNameMap.remove(serviceNameToEPRMap.get(service.getName()));\n", 
            "-        serviceNameToEPRMap.remove(service.getName());\n", 
            "-    }\n", 
            "-\n", 
            "-    protected IOEventDispatch getEventDispatch(\n", 
            "-            NHttpServiceHandler handler, SSLContext sslContext,\n", 
            "-            SSLIOSessionHandler sslioSessionHandler, HttpParams params) {\n", 
            "-        return new SourceIOEventDispatch(handler, params);\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Create the SSLContext to be used by this listener\n", 
            "-     * @param transportIn transport in description\n", 
            "-     * @return always null\n", 
            "-     * @throws AxisFault never thrown\n", 
            "-     */\n", 
            "-    protected SSLContext getSSLContext(\n", 
            "-            TransportInDescription transportIn) throws AxisFault {\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Create the SSL IO Session handler to be used by this listener\n", 
            "-     * @param transportIn transport in descritption\n", 
            "-     * @return always null\n", 
            "-     * @throws AxisFault never thrown\n", 
            "-     */\n", 
            "-    protected SSLIOSessionHandler getSSLIOSessionHandler(\n", 
            "-            TransportInDescription transportIn) throws AxisFault {\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpListener.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpListener.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,260 +0,0", 
          "lines": [
            "-/*\n", 
            "-*  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "-*  or more contributor license agreements.  See the NOTICE file\n", 
            "-*  distributed with this work for additional information\n", 
            "-*  regarding copyright ownership.  The ASF licenses this file\n", 
            "-*  to you under the Apache License, Version 2.0 (the\n", 
            "-*  \"License\"); you may not use this file except in compliance\n", 
            "-*  with the License.  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-*  Unless required by applicable law or agreed to in writing,\n", 
            "-*  software distributed under the License is distributed on an\n", 
            "-*   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-*  KIND, either express or implied.  See the License for the\n", 
            "-*  specific language governing permissions and limitations\n", 
            "-*  under the License.\n", 
            "-*/\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.jmx;\n", 
            "-\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-\n", 
            "-import java.util.Calendar;\n", 
            "-import java.util.Date;\n", 
            "-import java.util.LinkedList;\n", 
            "-import java.util.Queue;\n", 
            "-import java.util.concurrent.ConcurrentLinkedQueue;\n", 
            "-import java.util.concurrent.Executors;\n", 
            "-import java.util.concurrent.ScheduledExecutorService;\n", 
            "-import java.util.concurrent.TimeUnit;\n", 
            "-import java.util.concurrent.atomic.AtomicLong;\n", 
            "-\n", 
            "-/**\n", 
            "- * <p>LatencyView provides statistical information related to the latency (overhead) incurred by\n", 
            "- * the Synapse NHTTP transport, when mediating messages back and forth. Statistics are available\n", 
            "- * under two main categories, namely short term data and long term data. Short term data is\n", 
            "- * statistical information related to the last 15 minutes of execution and these metrics are\n", 
            "- * updated every 5 seconds. Long term data is related to the last 24 hours of execution and\n", 
            "- * they are updated every 5 minutes. Two timer tasks and a single threaded scheduled executor\n", 
            "- * is used to perform these periodic calculations.</p>\n", 
            "- *\n", 
            "- * <p>Latency calculation for a single invocation is carried out by taking timestamps on\n", 
            "- * following events:</p>\n", 
            "- *\n", 
            "- * <ul>\n", 
            "- *  <li>t1 - Receiving a new request (ServerHandler#requestReceived)</li>\n", 
            "- *  <li>t2 - Obtaining a connection to forward the request (Clienthandler#processConnection)</li>\n", 
            "- *  <li>t3 - Reading the complete response from the backend server (ClientHandler#inputReady)</li>\n", 
            "- *  <li>t4 - Writing the complete response to the client (ServerHandler#outputReady)</li>\n", 
            "- * <ul>\n", 
            "- *\n", 
            "- * <p>Having taken these timestamps, the latency for the invocation is calculated as follows:<br/>\n", 
            "- *    Latency = (t4 - t1) - (t3 - t2)\n", 
            "- * </p>\n", 
            "- *\n", 
            "- */\n", 
            "-public class LatencyView implements LatencyViewMBean {\n", 
            "-\n", 
            "-    private static final String NHTTP_LATENCY_VIEW = \"NhttpTransportLatency\";\n", 
            "-\n", 
            "-    private static final int SMALL_DATA_COLLECTION_PERIOD = 5;\n", 
            "-    private static final int LARGE_DATA_COLLECTION_PERIOD = 5 * 60;\n", 
            "-    private static final int SAMPLES_PER_MINUTE = 60/ SMALL_DATA_COLLECTION_PERIOD;\n", 
            "-    private static final int SAMPLES_PER_HOUR = (60 * 60)/LARGE_DATA_COLLECTION_PERIOD;\n", 
            "-\n", 
            "-    /** Keeps track of th last reported latency value */\n", 
            "-    private AtomicLong lastLatency = new AtomicLong(0);\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Queue of all latency values reported. The short term data collector clears this queue up\n", 
            "-     * time to time thus ensuring it doesn't grow indefinitely.\n", 
            "-     */\n", 
            "-    private Queue<Long> latencyDataQueue = new ConcurrentLinkedQueue<Long>();\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Queue of samples collected by the short term data collector. This is maintained\n", 
            "-     * as a fixed length queue\n", 
            "-     */\n", 
            "-    private Queue<Long> shortTermLatencyDataQueue = new LinkedList<Long>();\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Queue of samples collected by the long term data collector. This is maintained\n", 
            "-     * as a fixed length queue\n", 
            "-     */\n", 
            "-    private Queue<Long> longTermLatencyDataQueue = new LinkedList<Long>();\n", 
            "-\n", 
            "-    /** Scheduled executor on which data collectors are executed */\n", 
            "-    private ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n", 
            "-\n", 
            "-    private double allTimeAvgLatency = 0.0;\n", 
            "-    private int count = 0;\n", 
            "-    private Date resetTime = Calendar.getInstance().getTime();\n", 
            "-\n", 
            "-    private String name;\n", 
            "-\n", 
            "-    public LatencyView(boolean isHttps) throws AxisFault {\n", 
            "-        name = \"nio-http\" + (isHttps ? \"s\" : \"\");\n", 
            "-        scheduler.scheduleAtFixedRate(new ShortTermDataCollector(), SMALL_DATA_COLLECTION_PERIOD,\n", 
            "-                SMALL_DATA_COLLECTION_PERIOD, TimeUnit.SECONDS);\n", 
            "-        scheduler.scheduleAtFixedRate(new LongTermDataCollector(), LARGE_DATA_COLLECTION_PERIOD,\n", 
            "-                LARGE_DATA_COLLECTION_PERIOD, TimeUnit.SECONDS);\n", 
            "-\n", 
            "-        MBeanRegistrar.getInstance().registerMBean(this, NHTTP_LATENCY_VIEW, name);\n", 
            "-\n", 
            "-    }\n", 
            "-\n", 
            "-    public void destroy() {\n", 
            "-        MBeanRegistrar.getInstance().unRegisterMBean(NHTTP_LATENCY_VIEW, name);\n", 
            "-        scheduler.shutdownNow();\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Report the timestamp values captured during mediating messages back and forth\n", 
            "-     *\n", 
            "-     * @param reqArrival The request arrival time\n", 
            "-     * @param reqDeparture The request departure time (backend connection establishment)\n", 
            "-     * @param resArrival The resoponse arrival time\n", 
            "-     * @param resDeparture The response departure time\n", 
            "-     */\n", 
            "-    public void notifyTimes(long reqArrival, long reqDeparture,\n", 
            "-                            long resArrival, long resDeparture) {\n", 
            "-\n", 
            "-        long latency = (resDeparture - reqArrival) - (resArrival - reqDeparture);\n", 
            "-        lastLatency.set(latency);\n", 
            "-        latencyDataQueue.offer(latency);\n", 
            "-    }\n", 
            "-\n", 
            "-    public double getAllTimeAvgLatency() {\n", 
            "-        return allTimeAvgLatency;\n", 
            "-    }\n", 
            "-\n", 
            "-    public double getLastMinuteAvgLatency() {\n", 
            "-        return getAverageLatencyByMinute(1);\n", 
            "-    }\n", 
            "-\n", 
            "-    public double getLast5MinuteAvgLatency() {\n", 
            "-        return getAverageLatencyByMinute(5);\n", 
            "-    }\n", 
            "-\n", 
            "-    public double getLast15MinuteAvgLatency() {\n", 
            "-        return getAverageLatencyByMinute(15);\n", 
            "-    }\n", 
            "-\n", 
            "-    public double getLastHourAvgLatency() {\n", 
            "-        return getAverageLatencyByHour(1);\n", 
            "-    }\n", 
            "-\n", 
            "-    public double getLast8HourAvgLatency() {\n", 
            "-        return getAverageLatencyByHour(8);\n", 
            "-    }\n", 
            "-\n", 
            "-    public double getLast24HourAvgLatency() {\n", 
            "-        return getAverageLatencyByHour(24);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void reset() {\n", 
            "-        lastLatency.set(0);\n", 
            "-        allTimeAvgLatency = 0.0;\n", 
            "-        latencyDataQueue.clear();\n", 
            "-        shortTermLatencyDataQueue.clear();\n", 
            "-        longTermLatencyDataQueue.clear();\n", 
            "-        count = 0;\n", 
            "-        resetTime = Calendar.getInstance().getTime();\n", 
            "-    }\n", 
            "-\n", 
            "-    public Date getLastResetTime() {\n", 
            "-        return resetTime;\n", 
            "-    }\n", 
            "-\n", 
            "-    private double getAverageLatencyByMinute(int n) {\n", 
            "-        int samples = n * SAMPLES_PER_MINUTE;\n", 
            "-        double sum = 0.0;\n", 
            "-        Long[] array = shortTermLatencyDataQueue.toArray(new Long[shortTermLatencyDataQueue.size()]);\n", 
            "-\n", 
            "-        if (samples > array.length) {\n", 
            "-            // If we don't have enough samples collected yet\n", 
            "-            // add up everything we have\n", 
            "-            samples = array.length;\n", 
            "-            for (Long anArray : array) {\n", 
            "-                sum += anArray;\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            // We have enough samples to make the right calculation\n", 
            "-            // Add up starting from the end of the queue (to give the most recent values)\n", 
            "-            for (int i = 0; i < samples; i++) {\n", 
            "-                sum += array[array.length - 1 - i];\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        if (samples == 0) {\n", 
            "-            return 0.0;\n", 
            "-        }\n", 
            "-        return sum/samples;\n", 
            "-    }\n", 
            "-\n", 
            "-    private double getAverageLatencyByHour(int n) {\n", 
            "-        int samples = n * SAMPLES_PER_HOUR;\n", 
            "-        double sum = 0.0;\n", 
            "-        Long[] array = longTermLatencyDataQueue.toArray(new Long[longTermLatencyDataQueue.size()]);\n", 
            "-\n", 
            "-        if (samples > array.length) {\n", 
            "-            samples = array.length;\n", 
            "-            for (Long anArray : array) {\n", 
            "-                sum += anArray;\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            for (int i = 0; i < samples; i++) {\n", 
            "-                sum += array[array.length - 1 - i];\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        if (samples == 0) {\n", 
            "-            return 0.0;\n", 
            "-        }\n", 
            "-        return sum/samples;\n", 
            "-    }\n", 
            "-\n", 
            "-    private class ShortTermDataCollector implements Runnable {\n", 
            "-        public void run() {\n", 
            "-            long latency = lastLatency.get();\n", 
            "-\n", 
            "-            // calculate all time average latency\n", 
            "-            int size = latencyDataQueue.size();\n", 
            "-            if (size > 0) {\n", 
            "-                long sum = 0;\n", 
            "-                for (int i = 0; i < size; i++) {\n", 
            "-                    sum += latencyDataQueue.poll();\n", 
            "-                }\n", 
            "-                allTimeAvgLatency = (allTimeAvgLatency * count + sum)/(count + size);\n", 
            "-                count = count + size;\n", 
            "-            }\n", 
            "-\n", 
            "-            if (shortTermLatencyDataQueue.size() == 0 && latency == 0) {\n", 
            "-                // we haven't started collecting data yet - skip ahead...\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            // take a sample for the short term latency calculation\n", 
            "-            if (shortTermLatencyDataQueue.size() == SAMPLES_PER_MINUTE * 15) {\n", 
            "-                shortTermLatencyDataQueue.remove();\n", 
            "-            }\n", 
            "-            shortTermLatencyDataQueue.offer(latency);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private class LongTermDataCollector implements Runnable {\n", 
            "-        public void run() {\n", 
            "-            long latency = lastLatency.get();\n", 
            "-            if (longTermLatencyDataQueue.size() == 0 && latency == 0) {\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            if (longTermLatencyDataQueue.size() == SAMPLES_PER_HOUR * 24) {\n", 
            "-                longTermLatencyDataQueue.remove();\n", 
            "-            }\n", 
            "-            longTermLatencyDataQueue.offer(latency);\n", 
            "-        }\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/LatencyView.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/LatencyView.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,55 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "- *  or more contributor license agreements.  See the NOTICE file\n", 
            "- *  distributed with this work for additional information\n", 
            "- *  regarding copyright ownership.  The ASF licenses this file\n", 
            "- *  to you under the Apache License, Version 2.0 (the\n", 
            "- *  \"License\"); you may not use this file except in compliance\n", 
            "- *  with the License.  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing,\n", 
            "- *  software distributed under the License is distributed on an\n", 
            "- *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "- *  KIND, either express or implied.  See the License for the\n", 
            "- *  specific language governing permissions and limitations\n", 
            "- *  under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.jmx;\n", 
            "-\n", 
            "-import java.util.Map;\n", 
            "-\n", 
            "-public interface TransportViewMBean {\n", 
            "-\n", 
            "-    // JMX Attributes\n", 
            "-    public long getMessagesReceived();\n", 
            "-    public long getFaultsReceiving();\n", 
            "-    public long getTimeoutsReceiving();\n", 
            "-    public long getMessagesSent();\n", 
            "-    public long getFaultsSending();\n", 
            "-    public long getTimeoutsSending();\n", 
            "-    public long getBytesReceived();\n", 
            "-    public long getBytesSent();\n", 
            "-    public long getMinSizeReceived();\n", 
            "-    public long getMaxSizeReceived();\n", 
            "-    public double getAvgSizeReceived();\n", 
            "-    public long getMinSizeSent();\n", 
            "-    public long getMaxSizeSent();\n", 
            "-    public double getAvgSizeSent();\n", 
            "-    public int  getActiveThreadCount();\n", 
            "-    public int getQueueSize();\n", 
            "-    public Map getResponseCodeTable();\n", 
            "-\n", 
            "-    // JMX Operations\n", 
            "-    public void start() throws Exception;\n", 
            "-    public void stop() throws Exception;\n", 
            "-    public void pause() throws Exception;\n", 
            "-    public void resume() throws Exception;\n", 
            "-    public void maintenenceShutdown(long seconds) throws Exception;\n", 
            "-\n", 
            "-    public void resetStatistics();\n", 
            "-    public long getLastResetTime();\n", 
            "-    public long getMetricsWindow();\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/TransportViewMBean.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/TransportViewMBean.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,268 +0,0", 
          "lines": [
            "-/*\n", 
            "-*  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "-*  or more contributor license agreements.  See the NOTICE file\n", 
            "-*  distributed with this work for additional information\n", 
            "-*  regarding copyright ownership.  The ASF licenses this file\n", 
            "-*  to you under the Apache License, Version 2.0 (the\n", 
            "-*  \"License\"); you may not use this file except in compliance\n", 
            "-*  with the License.  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-*  Unless required by applicable law or agreed to in writing,\n", 
            "-*  software distributed under the License is distributed on an\n", 
            "-*   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-*  KIND, either express or implied.  See the License for the\n", 
            "-*  specific language governing permissions and limitations\n", 
            "-*  under the License.\n", 
            "-*/\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.jmx;\n", 
            "-\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-\n", 
            "-import java.util.*;\n", 
            "-import java.util.concurrent.Executors;\n", 
            "-import java.util.concurrent.ScheduledExecutorService;\n", 
            "-import java.util.concurrent.TimeUnit;\n", 
            "-import java.util.concurrent.atomic.AtomicInteger;\n", 
            "-\n", 
            "-/**\n", 
            "- * ConnectionsView MBean can be used to collect and monitor statistics on HTTP connections\n", 
            "- * created by the NHTTP transport. Connection statistics can be divided into two categories,\n", 
            "- * namely short term data and long term data. Short term data is related to the last 15\n", 
            "- * minutes of execution and they are updated every minute. Long term data is related to\n", 
            "- * the last 24 hours of execution and they get updated every 5 minutes.  In addition to the\n", 
            "- * connection statistics this MBean also provides information on the request and response\n", 
            "- * sizes received over the HTTP connections. All messages are divided into six categories\n", 
            "- * based on their sizes and the resulting counts are made available as a table.\n", 
            "- */\n", 
            "-public class ConnectionsView implements ConnectionsViewMBean {\n", 
            "-\n", 
            "-    private static final String PASS_THROUGH_CONNECTIONS = \"PassThroughConnections\";\n", 
            "-\n", 
            "-    // Bucket definitions\n", 
            "-    private static final int LESS_THAN_1K       = 0;\n", 
            "-    private static final int LESS_THAN_10K      = 1;\n", 
            "-    private static final int LESS_THAN_100K     = 2;\n", 
            "-    private static final int LESS_THAN_1M       = 3;\n", 
            "-    private static final int LESS_THAN_10M      = 4;\n", 
            "-    private static final int GREATER_THAN_10M   = 5;\n", 
            "-\n", 
            "-    private static final int SHORT_DATA_COLLECTION_PERIOD = 60;\n", 
            "-    private static final int LONG_DATA_COLLECTION_PERIOD = 60 * 5;\n", 
            "-\n", 
            "-    private static final int SAMPLES_PER_HOUR = (60 * 60)/LONG_DATA_COLLECTION_PERIOD;\n", 
            "-\n", 
            "-    private Queue<Integer> shortTermDataQueue = new LinkedList<Integer>();\n", 
            "-    private Queue<Integer> longTermDataQueue = new LinkedList<Integer>();\n", 
            "-\n", 
            "-    private AtomicInteger activeConnections = new AtomicInteger(0);\n", 
            "-    private AtomicInteger shortTermOpenedConnections = new AtomicInteger(0);\n", 
            "-    private AtomicInteger longTermOpenedConnections = new AtomicInteger(0);\n", 
            "-\n", 
            "-    // The array length must be equal to the number of buckets\n", 
            "-    private AtomicInteger[] requestSizeCounters = new AtomicInteger[6];\n", 
            "-    private AtomicInteger[] responseSizeCounters = new AtomicInteger[6];\n", 
            "-\n", 
            "-    private Date resetTime = Calendar.getInstance().getTime();\n", 
            "-\n", 
            "-    private ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();\n", 
            "-\n", 
            "-    private String name;\n", 
            "-\n", 
            "-    public ConnectionsView(String name) throws AxisFault {\n", 
            "-        this.name = name;\n", 
            "-\n", 
            "-        initCounters(requestSizeCounters);\n", 
            "-        initCounters(responseSizeCounters);\n", 
            "-\n", 
            "-        Runnable task = new Runnable() {\n", 
            "-            public void run() {\n", 
            "-                // We only need historical data for the last 15 minutes\n", 
            "-                // Therefore no need to keep data older than that...\n", 
            "-                if (shortTermDataQueue.size() == 15) {\n", 
            "-                    shortTermDataQueue.remove();\n", 
            "-                }\n", 
            "-                shortTermDataQueue.offer(shortTermOpenedConnections.getAndSet(0));\n", 
            "-            }\n", 
            "-        };\n", 
            "-        // Delay the timer by 1 minute to prevent the task from starting immediately\n", 
            "-        scheduler.scheduleAtFixedRate(task, SHORT_DATA_COLLECTION_PERIOD,\n", 
            "-                SHORT_DATA_COLLECTION_PERIOD, TimeUnit.SECONDS);\n", 
            "-\n", 
            "-        Runnable longTermCollector = new Runnable() {\n", 
            "-            public void run() {\n", 
            "-                // We only need historical data for the last 24 hours\n", 
            "-                // Therefore no need to keep data older than that...\n", 
            "-                if (longTermDataQueue.size() == 24 * SAMPLES_PER_HOUR) {\n", 
            "-                    longTermDataQueue.remove();\n", 
            "-                }\n", 
            "-                longTermDataQueue.offer(longTermOpenedConnections.getAndSet(0));\n", 
            "-            }\n", 
            "-        };\n", 
            "-        scheduler.scheduleAtFixedRate(longTermCollector, LONG_DATA_COLLECTION_PERIOD,\n", 
            "-                LONG_DATA_COLLECTION_PERIOD, TimeUnit.SECONDS);\n", 
            "-\n", 
            "-        MBeanRegistrar.getInstance().registerMBean(this, PASS_THROUGH_CONNECTIONS, name);\n", 
            "-\n", 
            "-    }\n", 
            "-\n", 
            "-    public void destroy() {\n", 
            "-        MBeanRegistrar.getInstance().unRegisterMBean(PASS_THROUGH_CONNECTIONS, name);\n", 
            "-        scheduler.shutdownNow();\n", 
            "-    }\n", 
            "-\n", 
            "-    private void initCounters(AtomicInteger[] counters) {\n", 
            "-        for (int i = 0; i < counters.length; i++) {\n", 
            "-            if (counters[i] == null) {\n", 
            "-                counters[i] = new AtomicInteger(0);\n", 
            "-            } else {\n", 
            "-                counters[i].set(0);\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    protected void connected() {\n", 
            "-        activeConnections.incrementAndGet();\n", 
            "-        shortTermOpenedConnections.incrementAndGet();\n", 
            "-        longTermOpenedConnections.incrementAndGet();\n", 
            "-    }\n", 
            "-\n", 
            "-    protected void disconnected() {\n", 
            "-        activeConnections.decrementAndGet();\n", 
            "-    }\n", 
            "-\n", 
            "-    protected void notifyMessageSize(long size, boolean isRequest) {\n", 
            "-        // This logic gets executed for each and every transaction. For a typical\n", 
            "-        // mediation scenario this method will be called 4 times. Therefore I'm using\n", 
            "-        // arrays of integers to keep the overhead down to a minimum. Since the number\n", 
            "-        // of buckets is 6, this can be easily managed without using a slow data structure\n", 
            "-        // like a HashMap. This approach guarantees O(1) complexity.\n", 
            "-\n", 
            "-        AtomicInteger[] counters = isRequest ? requestSizeCounters : responseSizeCounters;\n", 
            "-\n", 
            "-        if (size < 1024) {\n", 
            "-            counters[LESS_THAN_1K].incrementAndGet();\n", 
            "-        } else if (size < 10240) {\n", 
            "-            counters[LESS_THAN_10K].incrementAndGet();\n", 
            "-        } else if (size < 102400) {\n", 
            "-            counters[LESS_THAN_100K].incrementAndGet();\n", 
            "-        } else if (size < 1048576) {\n", 
            "-            counters[LESS_THAN_1M].incrementAndGet();\n", 
            "-        } else if (size < 10485760) {\n", 
            "-            counters[LESS_THAN_10M].incrementAndGet();\n", 
            "-        } else {\n", 
            "-            counters[GREATER_THAN_10M].incrementAndGet();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getActiveConnections() {\n", 
            "-        return activeConnections.get();\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getLastMinuteConnections() {\n", 
            "-        return getTotalConnections(1);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getLast5MinuteConnections() {\n", 
            "-        return getTotalConnections(5);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getLast15MinuteConnections() {\n", 
            "-        return getTotalConnections(15);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getLastHourConnections() {\n", 
            "-        return getTotalConnectionsByHour(1);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getLast8HourConnections() {\n", 
            "-        return getTotalConnectionsByHour(8);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getLast24HourConnections() {\n", 
            "-        return getTotalConnectionsByHour(24);\n", 
            "-    }\n", 
            "-\n", 
            "-    public Map getRequestSizesMap() {\n", 
            "-        return getCountersMap(requestSizeCounters);\n", 
            "-    }\n", 
            "-\n", 
            "-    public Map getResponseSizesMap() {\n", 
            "-        return getCountersMap(responseSizeCounters);\n", 
            "-    }\n", 
            "-\n", 
            "-    public Date getLastResetTime() {\n", 
            "-        return resetTime;\n", 
            "-    }\n", 
            "-\n", 
            "-    private Map<String,Integer> getCountersMap(AtomicInteger[] counters) {\n", 
            "-        // This ensures that keys are returned in the same order we insert them\n", 
            "-        // Provides better readability in the JMX consoles\n", 
            "-        Map<String,Integer> map = new LinkedHashMap<String,Integer>();\n", 
            "-        map.put(\"< 1 K\", counters[LESS_THAN_1K].get());\n", 
            "-        map.put(\"< 10 K\", counters[LESS_THAN_10K].get());\n", 
            "-        map.put(\"< 100 K\", counters[LESS_THAN_100K].get());\n", 
            "-        map.put(\"< 1 M\", counters[LESS_THAN_1M].get());\n", 
            "-        map.put(\"< 10 M\", counters[LESS_THAN_10M].get());\n", 
            "-        map.put(\"> 10 M\", counters[GREATER_THAN_10M].get());\n", 
            "-        return map;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void reset() {\n", 
            "-        initCounters(requestSizeCounters);\n", 
            "-        initCounters(responseSizeCounters);\n", 
            "-        shortTermDataQueue.clear();\n", 
            "-        longTermDataQueue.clear();\n", 
            "-        resetTime = Calendar.getInstance().getTime();\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Return the number of total connections opened during last 'n' munites\n", 
            "-     * of execution\n", 
            "-     *\n", 
            "-     * @param n Number of minutes in the execution history\n", 
            "-     * @return The number of connections opened\n", 
            "-     */\n", 
            "-    private int getTotalConnections(int n) {\n", 
            "-        int sum = 0;\n", 
            "-        Integer[] array = shortTermDataQueue.toArray(new Integer[shortTermDataQueue.size()]);\n", 
            "-\n", 
            "-        if (n > array.length) {\n", 
            "-            for (int i = 0; i < array.length; i++) {\n", 
            "-                sum += array[i];\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            for (int i = 0; i < n; i++) {\n", 
            "-                sum += array[array.length - 1 - i];\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return sum;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Return the number of total connections opened during last 'n' hours\n", 
            "-     * of execution\n", 
            "-     *\n", 
            "-     * @param n Number of hours in the execution history\n", 
            "-     * @return The number of connections opened\n", 
            "-     */\n", 
            "-    private int getTotalConnectionsByHour(int n) {\n", 
            "-        int samples = n * SAMPLES_PER_HOUR;\n", 
            "-        int sum = 0;\n", 
            "-        Integer[] array = longTermDataQueue.toArray(new Integer[longTermDataQueue.size()]);\n", 
            "-\n", 
            "-        if (samples > array.length) {\n", 
            "-            for (int i = 0; i < array.length; i++) {\n", 
            "-                sum += array[i];\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            for (int i = 0; i < samples; i++) {\n", 
            "-                sum += array[array.length - 1 - i];\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return sum;\n", 
            "-    }\n", 
            "-}\n", 
            "-\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/ConnectionsView.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/ConnectionsView.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,37 +0,0", 
          "lines": [
            "-/*\n", 
            "-*  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "-*  or more contributor license agreements.  See the NOTICE file\n", 
            "-*  distributed with this work for additional information\n", 
            "-*  regarding copyright ownership.  The ASF licenses this file\n", 
            "-*  to you under the Apache License, Version 2.0 (the\n", 
            "-*  \"License\"); you may not use this file except in compliance\n", 
            "-*  with the License.  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-*  Unless required by applicable law or agreed to in writing,\n", 
            "-*  software distributed under the License is distributed on an\n", 
            "-*   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-*  KIND, either express or implied.  See the License for the\n", 
            "-*  specific language governing permissions and limitations\n", 
            "-*  under the License.\n", 
            "-*/\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.jmx;\n", 
            "-\n", 
            "-import java.util.Date;\n", 
            "-\n", 
            "-public interface LatencyViewMBean {\n", 
            "-\n", 
            "-    public double getAllTimeAvgLatency();\n", 
            "-    public double getLastMinuteAvgLatency();\n", 
            "-    public double getLast5MinuteAvgLatency();\n", 
            "-    public double getLast15MinuteAvgLatency();\n", 
            "-    public double getLastHourAvgLatency();\n", 
            "-    public double getLast8HourAvgLatency();\n", 
            "-    public double getLast24HourAvgLatency();\n", 
            "-    public void reset();\n", 
            "-    public Date getLastResetTime();\n", 
            "-\n", 
            "-}\n", 
            "-\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/LatencyViewMBean.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/LatencyViewMBean.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,41 +0,0", 
          "lines": [
            "-/*\n", 
            "-*  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "-*  or more contributor license agreements.  See the NOTICE file\n", 
            "-*  distributed with this work for additional information\n", 
            "-*  regarding copyright ownership.  The ASF licenses this file\n", 
            "-*  to you under the Apache License, Version 2.0 (the\n", 
            "-*  \"License\"); you may not use this file except in compliance\n", 
            "-*  with the License.  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-*  Unless required by applicable law or agreed to in writing,\n", 
            "-*  software distributed under the License is distributed on an\n", 
            "-*   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-*  KIND, either express or implied.  See the License for the\n", 
            "-*  specific language governing permissions and limitations\n", 
            "-*  under the License.\n", 
            "-*/\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.jmx;\n", 
            "-\n", 
            "-import java.util.Date;\n", 
            "-import java.util.Map;\n", 
            "-\n", 
            "-public interface ConnectionsViewMBean {\n", 
            "-\n", 
            "-    public int getActiveConnections();\n", 
            "-    public int getLastMinuteConnections();\n", 
            "-    public int getLast5MinuteConnections();\n", 
            "-    public int getLast15MinuteConnections();\n", 
            "-    public int getLastHourConnections();\n", 
            "-    public int getLast8HourConnections();\n", 
            "-    public int getLast24HourConnections();\n", 
            "-    public Map getRequestSizesMap();\n", 
            "-    public Map getResponseSizesMap();\n", 
            "-    public Date getLastResetTime();\n", 
            "-\n", 
            "-    public void reset();\n", 
            "-\n", 
            "-}\n", 
            "-\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/ConnectionsViewMBean.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/ConnectionsViewMBean.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,76 +0,0", 
          "lines": [
            "-/*\n", 
            "-*  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "-*  or more contributor license agreements.  See the NOTICE file\n", 
            "-*  distributed with this work for additional information\n", 
            "-*  regarding copyright ownership.  The ASF licenses this file\n", 
            "-*  to you under the Apache License, Version 2.0 (the\n", 
            "-*  \"License\"); you may not use this file except in compliance\n", 
            "-*  with the License.  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-*  Unless required by applicable law or agreed to in writing,\n", 
            "-*  software distributed under the License is distributed on an\n", 
            "-*   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-*  KIND, either express or implied.  See the License for the\n", 
            "-*  specific language governing permissions and limitations\n", 
            "-*  under the License.\n", 
            "-*/\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.jmx;\n", 
            "-\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.transport.base.MetricsCollector;\n", 
            "-\n", 
            "-/**\n", 
            "- * <p>This simple extension of the Axis2 transport MetricsCollector implementation,\n", 
            "- * maintains a ConnectionsView instance, which is updated based on the events fired\n", 
            "- * by the pass-through transport implementation. In addition to the usual events handled\n", 
            "- * by the Axis2 MetricsCollector, this implementation handles two new events:</p>\n", 
            "- * <ul>\n", 
            "- *    <li>connected (this should get called whenever a new connection is created)</li>\n", 
            "- *    <li>disconnected (this should get called whenever an existing connection is closed)</li>\n", 
            "- * <ul>\n", 
            "- * <p>These new events are used to update the ConnectionsView at runtime.</p>\n", 
            "- */\n", 
            "-public class PassThroughTransportMetricsCollector extends MetricsCollector {\n", 
            "-\n", 
            "-    private ConnectionsView view;\n", 
            "-    private boolean listener;\n", 
            "-\n", 
            "-    public PassThroughTransportMetricsCollector(boolean listener, boolean isHttps)\n", 
            "-            throws AxisFault {\n", 
            "-        this.listener = listener;\n", 
            "-        String name = \"http\" + (isHttps ? \"s\" : \"\") + \"-\" + (listener ? \"listener\" : \"sender\");\n", 
            "-        this.view = new ConnectionsView(name);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void destroy() {\n", 
            "-        view.destroy();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void connected() {\n", 
            "-        view.connected();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void disconnected() {\n", 
            "-        view.disconnected();\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void notifyReceivedMessageSize(long l) {\n", 
            "-        super.notifyReceivedMessageSize(l);\n", 
            "-        if (l > 0) {\n", 
            "-            view.notifyMessageSize(l, listener);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void notifySentMessageSize(long l) {\n", 
            "-        super.notifySentMessageSize(l);\n", 
            "-        if (l > 0) {\n", 
            "-            view.notifyMessageSize(l, !listener);\n", 
            "-        }\n", 
            "-    }\n", 
            "-}\n", 
            "-\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/PassThroughTransportMetricsCollector.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/PassThroughTransportMetricsCollector.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,102 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "- *  or more contributor license agreements.  See the NOTICE file\n", 
            "- *  distributed with this work for additional information\n", 
            "- *  regarding copyright ownership.  The ASF licenses this file\n", 
            "- *  to you under the Apache License, Version 2.0 (the\n", 
            "- *  \"License\"); you may not use this file except in compliance\n", 
            "- *  with the License.  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing,\n", 
            "- *  software distributed under the License is distributed on an\n", 
            "- *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "- *  KIND, either express or implied.  See the License for the\n", 
            "- *  specific language governing permissions and limitations\n", 
            "- *  under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.jmx;\n", 
            "-\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-\n", 
            "-import javax.management.MBeanServer;\n", 
            "-import javax.management.ObjectName;\n", 
            "-import java.lang.management.ManagementFactory;\n", 
            "-import java.util.Set;\n", 
            "-\n", 
            "-public class MBeanRegistrar {\n", 
            "-\n", 
            "-    private static final MBeanRegistrar ourInstance = new MBeanRegistrar();\n", 
            "-    private static final Log log = LogFactory.getLog(MBeanRegistrar.class);\n", 
            "-\n", 
            "-    public static MBeanRegistrar getInstance() {\n", 
            "-        return ourInstance;\n", 
            "-    }\n", 
            "-\n", 
            "-    private MBeanRegistrar() {\n", 
            "-    }\n", 
            "-\n", 
            "-    public void registerMBean(Object mBeanInstance, String category, String id) throws AxisFault {\n", 
            "-        assertNull(mBeanInstance, \"MBean instance is null\");\n", 
            "-        assertNull(category, \"MBean instance category is null\");\n", 
            "-        assertNull(id, \"MBean instance name is null\");\n", 
            "-        try {\n", 
            "-            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n", 
            "-            ObjectName name = new ObjectName(getObjectName(category, id));\n", 
            "-            Set set = mbs.queryNames(name, null);\n", 
            "-            if (set != null && set.isEmpty()) {\n", 
            "-                mbs.registerMBean(mBeanInstance, name);\n", 
            "-            } else {\n", 
            "-                mbs.unregisterMBean(name);\n", 
            "-                mbs.registerMBean(mBeanInstance, name);\n", 
            "-            }\n", 
            "-        } catch (Exception e) {\n", 
            "-            log.warn(\"Error registering a MBean with name ' \" + id +\n", 
            "-                    \" ' and category name ' \" + category + \"' for JMX management\", e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void unRegisterMBean(String category, String id) {\n", 
            "-        try {\n", 
            "-            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n", 
            "-            ObjectName objName = new ObjectName(getObjectName(category, id));\n", 
            "-            if (mbs.isRegistered(objName)) {\n", 
            "-                mbs.unregisterMBean(objName);\n", 
            "-            }\n", 
            "-        } catch (Exception e) {\n", 
            "-            log.warn(\"Error un-registering a  MBean with name ' \" + id +\n", 
            "-                    \" ' and category name ' \" + category + \"' for JMX management\", e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private String getObjectName(String category, String id) {\n", 
            "-\n", 
            "-        String jmxAgentName = System.getProperty(\"jmx.agent.name\");\n", 
            "-        if (jmxAgentName == null || \"\".equals(jmxAgentName)) {\n", 
            "-            jmxAgentName = \"org.apache.synapse\";\n", 
            "-        }\n", 
            "-        return jmxAgentName + \":Type=\" + category + \",Name=\" + id;\n", 
            "-    }\n", 
            "-\n", 
            "-    private void assertNull(String name, String msg) throws AxisFault {\n", 
            "-        if (name == null || \"\".equals(name)) {\n", 
            "-            handleException(msg);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private void assertNull(Object object, String msg) throws AxisFault {\n", 
            "-        if (object == null) {\n", 
            "-            handleException(msg);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private static void handleException(String msg) throws AxisFault {\n", 
            "-        log.error(msg);\n", 
            "-        throw new AxisFault(msg);\n", 
            "-    }\n", 
            "-\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/MBeanRegistrar.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/MBeanRegistrar.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,223 +0,0", 
          "lines": [
            "-/*\n", 
            "-*  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "-*  or more contributor license agreements.  See the NOTICE file\n", 
            "-*  distributed with this work for additional information\n", 
            "-*  regarding copyright ownership.  The ASF licenses this file\n", 
            "-*  to you under the Apache License, Version 2.0 (the\n", 
            "-*  \"License\"); you may not use this file except in compliance\n", 
            "-*  with the License.  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-*  Unless required by applicable law or agreed to in writing,\n", 
            "-*  software distributed under the License is distributed on an\n", 
            "-*   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-*  KIND, either express or implied.  See the License for the\n", 
            "-*  specific language governing permissions and limitations\n", 
            "-*  under the License.\n", 
            "-*/\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.jmx;\n", 
            "-\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.synapse.transport.passthru.PassThroughHttpListener;\n", 
            "-import org.apache.synapse.transport.passthru.PassThroughHttpSender;\n", 
            "-\n", 
            "-import java.util.Map;\n", 
            "-import java.util.concurrent.ThreadPoolExecutor;\n", 
            "-\n", 
            "-public class TransportView implements TransportViewMBean {\n", 
            "-\n", 
            "-    private PassThroughHttpListener listener = null;\n", 
            "-\n", 
            "-    private PassThroughHttpSender sender = null;\n", 
            "-\n", 
            "-    private PassThroughTransportMetricsCollector metrics = null;\n", 
            "-\n", 
            "-    private ThreadPoolExecutor threadPool = null;\n", 
            "-\n", 
            "-    public TransportView(PassThroughHttpListener listener,\n", 
            "-                         PassThroughHttpSender sender,\n", 
            "-                         PassThroughTransportMetricsCollector metrics,\n", 
            "-                         ThreadPoolExecutor threadPool) throws AxisFault {\n", 
            "-        this.listener = listener;\n", 
            "-        this.metrics = metrics;\n", 
            "-        this.threadPool = threadPool;\n", 
            "-        this.sender = sender;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void pause() throws AxisFault {\n", 
            "-        if (listener != null) {\n", 
            "-            listener.pause();\n", 
            "-        } else if (sender != null) {\n", 
            "-            sender.pause();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void resume() throws AxisFault {\n", 
            "-        if (listener != null) {\n", 
            "-            listener.resume();\n", 
            "-        } else if (sender != null) {\n", 
            "-            sender.resume();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void maintenenceShutdown(long l) throws AxisFault {\n", 
            "-        if (listener != null) {\n", 
            "-            listener.maintenanceShutdown(l);\n", 
            "-        } else if (sender != null) {\n", 
            "-            sender.maintenanceShutdown(l);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getActiveThreadCount() {\n", 
            "-        if (threadPool != null) {\n", 
            "-            return threadPool.getActiveCount();\n", 
            "-        }\n", 
            "-        return 0;\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getQueueSize() {\n", 
            "-        if (threadPool != null && threadPool.getQueue() != null) {\n", 
            "-            return threadPool.getQueue().size();\n", 
            "-        }\n", 
            "-        return 0;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getMessagesReceived() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getMessagesReceived();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getFaultsReceiving() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getFaultsReceiving();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getBytesReceived() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getBytesReceived();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getMessagesSent() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getMessagesSent();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getFaultsSending() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getFaultsSending();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getBytesSent() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getBytesSent();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getTimeoutsReceiving() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getTimeoutsReceiving();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getTimeoutsSending() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getTimeoutsSending();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getMinSizeReceived() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getMinSizeReceived();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getMaxSizeReceived() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getMaxSizeReceived();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public double getAvgSizeReceived() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getAvgSizeReceived();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getMinSizeSent() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getMinSizeSent();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getMaxSizeSent() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getMaxSizeSent();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public double getAvgSizeSent() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getAvgSizeSent();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public Map getResponseCodeTable() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getResponseCodeTable();\n", 
            "-        }\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void start() throws Exception {\n", 
            "-        if (listener != null) {\n", 
            "-            listener.start();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void stop() throws Exception {\n", 
            "-        if (listener != null) {\n", 
            "-            listener.stop();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void resetStatistics() {\n", 
            "-        if (metrics != null) {\n", 
            "-            metrics.reset();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getLastResetTime() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return metrics.getLastResetTime();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-\n", 
            "-    public long getMetricsWindow() {\n", 
            "-        if (metrics != null) {\n", 
            "-            return System.currentTimeMillis() - metrics.getLastResetTime();\n", 
            "-        }\n", 
            "-        return -1;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/TransportView.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/TransportView.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,183 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.http.*;\n", 
            "-import org.apache.http.entity.BasicHttpEntity;\n", 
            "-import org.apache.http.impl.DefaultConnectionReuseStrategy;\n", 
            "-import org.apache.http.nio.ContentEncoder;\n", 
            "-import org.apache.http.nio.NHttpServerConnection;\n", 
            "-import org.apache.http.params.DefaultedHttpParams;\n", 
            "-import org.apache.http.protocol.ExecutionContext;\n", 
            "-import org.apache.http.protocol.HTTP;\n", 
            "-import org.apache.synapse.transport.passthru.config.SourceConfiguration;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-import java.util.HashMap;\n", 
            "-import java.util.Map;\n", 
            "-import java.util.Set;\n", 
            "-\n", 
            "-public class SourceResponse {\n", 
            "-    private Pipe pipe = null;\n", 
            "-    /** Transport headers */\n", 
            "-    private Map<String, String> headers = new HashMap<String, String>();\n", 
            "-    /** Status of the response */\n", 
            "-    private int status = HttpStatus.SC_OK;\n", 
            "-    /** Status line */\n", 
            "-    private String statusLine = null;\n", 
            "-    /** Actual response submitted */\n", 
            "-    private HttpResponse response = null;\n", 
            "-    /** Configuration of the receiver */\n", 
            "-    private SourceConfiguration sourceConfiguration;\n", 
            "-    /** Version of the response */\n", 
            "-    private ProtocolVersion version = HttpVersion.HTTP_1_1;\n", 
            "-    /** Connection strategy */\n", 
            "-    private ConnectionReuseStrategy connStrategy = new DefaultConnectionReuseStrategy();\n", 
            "-    /** Chunk response or not */\n", 
            "-    // private boolean chunk = true;\n", 
            "-\n", 
            "-    private SourceRequest request = null;\n", 
            "-\n", 
            "-    public SourceResponse(SourceConfiguration config, int status, SourceRequest request) {\n", 
            "-        this(config, status, null, request);\n", 
            "-    }\n", 
            "-\n", 
            "-    public SourceResponse(SourceConfiguration config, int status, String statusLine,\n", 
            "-                          SourceRequest request) {\n", 
            "-        this.status = status;\n", 
            "-        this.statusLine = statusLine;\n", 
            "-        this.sourceConfiguration = config;\n", 
            "-        this.request = request;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void connect(Pipe pipe) {\n", 
            "-        this.pipe = pipe;\n", 
            "-\n", 
            "-        if (request != null && pipe != null) {\n", 
            "-            SourceContext.get(request.getConnection()).setWriter(pipe);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Starts the response by writing the headers\n", 
            "-     * @param conn connection\n", 
            "-     * @throws java.io.IOException if an error occurs\n", 
            "-     * @throws org.apache.http.HttpException if an error occurs\n", 
            "-     */\n", 
            "-    public void start(NHttpServerConnection conn) throws IOException, HttpException {\n", 
            "-        // create the response\n", 
            "-        response = sourceConfiguration.getResponseFactory().newHttpResponse(\n", 
            "-                request.getVersion(), HttpStatus.SC_OK,\n", 
            "-                request.getConnection().getContext());\n", 
            "-\n", 
            "-        if (statusLine != null) {\n", 
            "-            response.setStatusLine(version, status, statusLine);\n", 
            "-        } else {\n", 
            "-            response.setStatusCode(status);\n", 
            "-        }\n", 
            "-\n", 
            "-        BasicHttpEntity entity = new BasicHttpEntity();\n", 
            "-\n", 
            "-        int contentLength = -1;\n", 
            "-        String contentLengthHeader = headers.get(HTTP.CONTENT_LEN);\n", 
            "-        if (contentLengthHeader != null) {\n", 
            "-            contentLength = Integer.parseInt(contentLengthHeader);\n", 
            "-\n", 
            "-            headers.remove(HTTP.CONTENT_LEN);\n", 
            "-        }\n", 
            "-\n", 
            "-        if (contentLength != -1) {\n", 
            "-            entity.setChunked(false);\n", 
            "-            entity.setContentLength(contentLength);\n", 
            "-        } else {\n", 
            "-            entity.setChunked(true);\n", 
            "-        }\n", 
            "-\n", 
            "-        response.setEntity(entity);\n", 
            "-\n", 
            "-        // set any transport headers\n", 
            "-        Set<Map.Entry<String, String>> entries = headers.entrySet();\n", 
            "-\n", 
            "-        for (Map.Entry<String, String> entry : entries) {\n", 
            "-            if (entry.getKey() != null) {\n", 
            "-                response.addHeader(entry.getKey(), entry.getValue());\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        response.setParams(new DefaultedHttpParams(response.getParams(),\n", 
            "-                sourceConfiguration.getHttpParameters()));\n", 
            "-\n", 
            "-        SourceContext.updateState(conn, ProtocolState.RESPONSE_HEAD);\n", 
            "-\n", 
            "-        // Pre-process HTTP response\n", 
            "-        conn.getContext().setAttribute(ExecutionContext.HTTP_CONNECTION, conn);\n", 
            "-        conn.getContext().setAttribute(ExecutionContext.HTTP_RESPONSE, response);\n", 
            "-        conn.getContext().setAttribute(ExecutionContext.HTTP_REQUEST,\n", 
            "-                SourceContext.getRequest(conn).getRequest());\n", 
            "-        \n", 
            "-        sourceConfiguration.getHttpProcessor().process(response, conn.getContext());\n", 
            "-        conn.submitResponse(response);        \n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Consume the content through the Pipe and write them to the wire\n", 
            "-     * @param conn connection\n", 
            "-     * @param encoder encoder\n", 
            "-     * @throws java.io.IOException if an error occurs\n", 
            "-     * @return number of bytes written\n", 
            "-     */\n", 
            "-    public int write(NHttpServerConnection conn, ContentEncoder encoder) throws IOException {        \n", 
            "-        int bytes = 0;\n", 
            "-        if (pipe != null) {\n", 
            "-            bytes = pipe.consume(encoder);\n", 
            "-        } else {\n", 
            "-            encoder.complete();\n", 
            "-        }\n", 
            "-        // Update connection state\n", 
            "-        if (encoder.isCompleted()) {\n", 
            "-            SourceContext.updateState(conn, ProtocolState.RESPONSE_DONE);\n", 
            "-\n", 
            "-            sourceConfiguration.getMetrics().\n", 
            "-                    notifySentMessageSize(conn.getMetrics().getSentBytesCount());\n", 
            "-\n", 
            "-            if (!this.connStrategy.keepAlive(response, conn.getContext())) {\n", 
            "-                SourceContext.updateState(conn, ProtocolState.CLOSING);\n", 
            "-\n", 
            "-                sourceConfiguration.getSourceConnections().closeConnection(conn);\n", 
            "-            } else if (SourceContext.get(conn).isShutDown()) {\n", 
            "-                // we need to shut down if the shutdown flag is set\n", 
            "-                SourceContext.updateState(conn, ProtocolState.CLOSING);\n", 
            "-\n", 
            "-                sourceConfiguration.getSourceConnections().closeConnection(conn);\n", 
            "-            } else {\n", 
            "-                // Reset connection state\n", 
            "-                sourceConfiguration.getSourceConnections().releaseConnection(conn);\n", 
            "-                // Ready to deal with a new request                \n", 
            "-                conn.requestInput();\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return bytes;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void addHeader(String name, String value) {\n", 
            "-        headers.put(name, value);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setStatus(int status) {\n", 
            "-        this.status = status;\n", 
            "-    }        \n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,78 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.http.impl.nio.reactor.SSLIOSession;\n", 
            "-import org.apache.http.impl.nio.reactor.SSLSetupHandler;\n", 
            "-import org.apache.http.nio.NHttpClientHandler;\n", 
            "-import org.apache.http.nio.NHttpClientIOTarget;\n", 
            "-import org.apache.http.nio.reactor.IOSession;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-import org.apache.synapse.transport.passthru.logging.LoggingUtils;\n", 
            "-\n", 
            "-import javax.net.ssl.SSLContext;\n", 
            "-import java.net.InetSocketAddress;\n", 
            "-import java.util.Map;\n", 
            "-\n", 
            "-public class SSLTargetIOEventDispatch extends org.apache.http.impl.nio.ssl.SSLClientIOEventDispatch {\n", 
            "-\n", 
            "-    private Map<String, SSLContext> contextMap;\n", 
            "-\n", 
            "-    private HttpParams params = null;\n", 
            "-\n", 
            "-    public SSLTargetIOEventDispatch(NHttpClientHandler handler,\n", 
            "-                                    SSLContext sslcontext,\n", 
            "-                                    SSLSetupHandler sslHandler,\n", 
            "-                                    HttpParams params) {\n", 
            "-        super(handler, sslcontext, sslHandler, params);\n", 
            "-        this.params = params;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setContextMap(Map<String,SSLContext> contextMap) {\n", 
            "-        this.contextMap = contextMap;\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    protected SSLIOSession createSSLIOSession(IOSession session,\n", 
            "-                                              SSLContext sslcontext,\n", 
            "-                                              SSLSetupHandler sslHandler) {\n", 
            "-\n", 
            "-        InetSocketAddress address = (InetSocketAddress) session.getRemoteAddress();\n", 
            "-        String host = address.getHostName() + \":\" + address.getPort();\n", 
            "-        SSLContext customContext = null;\n", 
            "-        if (contextMap != null) {\n", 
            "-            // See if there's a custom SSL profile configured for this server\n", 
            "-            customContext = contextMap.get(host);\n", 
            "-        }\n", 
            "-\n", 
            "-        if (customContext == null) {\n", 
            "-            customContext = sslcontext;\n", 
            "-        }\n", 
            "-\n", 
            "-        return super.createSSLIOSession(session, customContext, sslHandler);\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    protected NHttpClientIOTarget createConnection(IOSession session) {\n", 
            "-        session = LoggingUtils.decorate(session, \"sslclient\");\n", 
            "-        return LoggingUtils.createClientConnection(\n", 
            "-                session,\n", 
            "-                createHttpResponseFactory(),\n", 
            "-                createByteBufferAllocator(),\n", 
            "-                params);\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLTargetIOEventDispatch.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLTargetIOEventDispatch.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,497 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru;\n", 
            "-\n", 
            "-import org.apache.axiom.om.OMAbstractFactory;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.addressing.AddressingConstants;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.description.WSDL2Constants;\n", 
            "-import org.apache.axis2.engine.MessageReceiver;\n", 
            "-import org.apache.axis2.wsdl.WSDLConstants;\n", 
            "-import org.apache.http.impl.nio.DefaultNHttpClientConnection;\n", 
            "-import org.apache.http.nio.*;\n", 
            "-import org.apache.http.*;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            "-import org.apache.synapse.transport.passthru.config.TargetConfiguration;\n", 
            "-import org.apache.synapse.transport.passthru.connections.HostConnections;\n", 
            "-import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;\n", 
            "-\n", 
            "-import java.io.IOException;\n", 
            "-\n", 
            "-/**\n", 
            "- * This class is handling events from the transport -- > client.\n", 
            "- */\n", 
            "-public class TargetHandler implements NHttpClientHandler {\n", 
            "-    private static Log log = LogFactory.getLog(TargetHandler.class);\n", 
            "-\n", 
            "-    /** Delivery agent */\n", 
            "-    private final DeliveryAgent deliveryAgent;\n", 
            "-\n", 
            "-    /** Configuration used by the sender */\n", 
            "-    private final TargetConfiguration targetConfiguration;\n", 
            "-\n", 
            "-    /** Error handler for injecting faults */\n", 
            "-    private final TargetErrorHandler targetErrorHandler;\n", 
            "-\n", 
            "-    private PassThroughTransportMetricsCollector metrics = null;\n", 
            "-\n", 
            "-    public TargetHandler(DeliveryAgent deliveryAgent,\n", 
            "-                         TargetConfiguration configuration) {\n", 
            "-        this.targetConfiguration = configuration;\n", 
            "-        this.deliveryAgent = deliveryAgent;\n", 
            "-        this.targetErrorHandler = new TargetErrorHandler(targetConfiguration);\n", 
            "-        this.metrics = targetConfiguration.getMetrics();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void connected(NHttpClientConnection conn, Object o) {\n", 
            "-        assert o instanceof HostConnections : \"Attachment should be a HostConnections\";\n", 
            "-\n", 
            "-        HostConnections pool = (HostConnections) o;\n", 
            "-        conn.getContext().setAttribute(PassThroughConstants.CONNECTION_POOL, pool);\n", 
            "-\n", 
            "-        // create the connection information and set it to request ready\n", 
            "-        TargetContext.create(conn, ProtocolState.REQUEST_READY, targetConfiguration);\n", 
            "-\n", 
            "-        // notify the pool about the new connection\n", 
            "-        targetConfiguration.getConnections().addConnection(conn);\n", 
            "-\n", 
            "-        // notify about the new connection\n", 
            "-        deliveryAgent.connected(pool.getHost(), pool.getPort());\n", 
            "-\n", 
            "-        metrics.connected();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void requestReady(NHttpClientConnection conn) {\n", 
            "-        ProtocolState connState = null;\n", 
            "-        try {\n", 
            "-            connState = TargetContext.getState(conn);\n", 
            "-\n", 
            "-            if (connState == ProtocolState.REQUEST_DONE || connState == ProtocolState.RESPONSE_BODY) {\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            if (connState != ProtocolState.REQUEST_READY) {\n", 
            "-                handleInvalidState(conn, \"Request not started\");\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            TargetRequest request = TargetContext.getRequest(conn);\n", 
            "-            if (request != null) {\n", 
            "-                request.start(conn);\n", 
            "-                targetConfiguration.getMetrics().incrementMessagesSent();\n", 
            "-            }\n", 
            "-        } catch (IOException e) {\n", 
            "-            logIOException(conn, e);\n", 
            "-            TargetContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-\n", 
            "-            MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();\n", 
            "-            if (requestMsgCtx != null) {\n", 
            "-                targetErrorHandler.handleError(requestMsgCtx,\n", 
            "-                        ErrorCodes.SND_IO_ERROR,\n", 
            "-                        \"Error in Sender\",\n", 
            "-                        null,\n", 
            "-                        connState);\n", 
            "-            }\n", 
            "-        } catch (HttpException e) {\n", 
            "-            log.error(e.getMessage(), e);\n", 
            "-            TargetContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-\n", 
            "-            MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();\n", 
            "-            if (requestMsgCtx != null) {\n", 
            "-                targetErrorHandler.handleError(requestMsgCtx,\n", 
            "-                        ErrorCodes.SND_HTTP_ERROR,\n", 
            "-                        \"Error in Sender\",\n", 
            "-                        null,\n", 
            "-                        connState);\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void outputReady(NHttpClientConnection conn, ContentEncoder encoder) {\n", 
            "-        ProtocolState connState = null;\n", 
            "-        try {\n", 
            "-            connState = TargetContext.getState(conn);\n", 
            "-            if (connState != ProtocolState.REQUEST_HEAD &&\n", 
            "-                    connState != ProtocolState.REQUEST_DONE) {\n", 
            "-                handleInvalidState(conn, \"Writing message body\");\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            TargetRequest request = TargetContext.getRequest(conn);\n", 
            "-            if (request.hasEntityBody()) {\n", 
            "-                int bytesWritten = request.write(conn, encoder);\n", 
            "-                metrics.incrementBytesSent(bytesWritten);\n", 
            "-            }\n", 
            "-        } catch (IOException ex) {\n", 
            "-            logIOException(conn, ex);\n", 
            "-            TargetContext.updateState(conn, ProtocolState.CLOSING);\n", 
            "-            targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-\n", 
            "-            informWriterError(conn);\n", 
            "-\n", 
            "-            MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();\n", 
            "-            if (requestMsgCtx != null) {\n", 
            "-                targetErrorHandler.handleError(requestMsgCtx,\n", 
            "-                        ErrorCodes.SND_HTTP_ERROR,\n", 
            "-                        \"Error in Sender\",\n", 
            "-                        null,\n", 
            "-                        connState);\n", 
            "-            }\n", 
            "-        } catch (Exception e) {\n", 
            "-            log.error(\"Error occurred while writing data to the target\", e);\n", 
            "-            TargetContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-\n", 
            "-            informWriterError(conn);\n", 
            "-\n", 
            "-            MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();\n", 
            "-            if (requestMsgCtx != null) {\n", 
            "-                targetErrorHandler.handleError(requestMsgCtx,\n", 
            "-                        ErrorCodes.SND_HTTP_ERROR,\n", 
            "-                        \"Error in Sender\",\n", 
            "-                        null,\n", 
            "-                        connState);\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void responseReceived(NHttpClientConnection conn) {\n", 
            "-        ProtocolState connState;\n", 
            "-        try {\n", 
            "-            connState = TargetContext.getState(conn);\n", 
            "-            if (connState != ProtocolState.REQUEST_DONE) {\n", 
            "-                handleInvalidState(conn, \"Receiving response\");\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            HttpResponse response = conn.getHttpResponse();\n", 
            "-            TargetRequest targetRequest = TargetContext.getRequest(conn);\n", 
            "-\n", 
            "-            int statusCode = response.getStatusLine().getStatusCode();\n", 
            "-            if (statusCode < HttpStatus.SC_OK) {\n", 
            "-                if (log.isDebugEnabled()) {\n", 
            "-                    log.debug(\"Received a 100 Continue response\");\n", 
            "-                }\n", 
            "-                // Ignore 1xx response\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            String method = \"POST\";\n", 
            "-            if (targetRequest != null) {\n", 
            "-                method = targetRequest.getMethod();\n", 
            "-            }\n", 
            "-            boolean canResponseHaveBody =\n", 
            "-                    isResponseHaveBodyExpected(method, response);\n", 
            "-            TargetResponse targetResponse = new TargetResponse(\n", 
            "-                    targetConfiguration, response, conn, canResponseHaveBody);\n", 
            "-            TargetContext.setResponse(conn, targetResponse);\n", 
            "-            targetResponse.start(conn);\n", 
            "-\n", 
            "-            MessageContext requestMsgContext = TargetContext.get(conn).getRequestMsgCtx();\n", 
            "-            if (statusCode == HttpStatus.SC_ACCEPTED && handle202(requestMsgContext)) {\n", 
            "-                return;\n", 
            "-            }\n", 
            "-                       \n", 
            "-            targetConfiguration.getWorkerPool().execute(\n", 
            "-                    new ClientWorker(targetConfiguration.getConfigurationContext(),\n", 
            "-                            requestMsgContext, targetResponse));\n", 
            "-\n", 
            "-            targetConfiguration.getMetrics().incrementMessagesReceived();\n", 
            "-        } catch (Exception ex) {\n", 
            "-            log.error(ex.getMessage(), ex);\n", 
            "-\n", 
            "-            informReaderError(conn);\n", 
            "-\n", 
            "-            TargetContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private boolean handle202(MessageContext requestMsgContext) throws AxisFault {\n", 
            "-        if (requestMsgContext.isPropertyTrue(NhttpConstants.IGNORE_SC_ACCEPTED)) {\n", 
            "-            // We should not further process this 202 response - Ignore it\n", 
            "-            return true;\n", 
            "-        }\n", 
            "-\n", 
            "-        MessageReceiver mr = requestMsgContext.getAxisOperation().getMessageReceiver();\n", 
            "-        MessageContext responseMsgCtx = requestMsgContext.getOperationContext().\n", 
            "-                        getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);\n", 
            "-        if (responseMsgCtx == null || requestMsgContext.getOptions().isUseSeparateListener()) {\n", 
            "-            // Most probably a response from a dual channel invocation\n", 
            "-            // Inject directly into the SynapseCallbackReceiver\n", 
            "-            requestMsgContext.setProperty(NhttpConstants.HTTP_202_RECEIVED, \"true\");\n", 
            "-            mr.receive(requestMsgContext);\n", 
            "-            return true;\n", 
            "-        }\n", 
            "-\n", 
            "-        return false;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void inputReady(NHttpClientConnection conn, ContentDecoder decoder) {\n", 
            "-        ProtocolState connState;\n", 
            "-        try {\n", 
            "-            connState = TargetContext.getState(conn);\n", 
            "-            if (connState.compareTo(ProtocolState.RESPONSE_HEAD) < 0) {\n", 
            "-                return;\n", 
            "-            }\n", 
            "-            if (connState != ProtocolState.RESPONSE_HEAD &&\n", 
            "-                    connState != ProtocolState.RESPONSE_BODY) {\n", 
            "-                handleInvalidState(conn, \"Response received\");\n", 
            "-                return;\n", 
            "-            }\n", 
            "-\n", 
            "-            TargetContext.updateState(conn, ProtocolState.RESPONSE_BODY);\n", 
            "-\n", 
            "-            TargetResponse response = TargetContext.getResponse(conn);\n", 
            "-\n", 
            "-            int responseRead = response.read(conn, decoder);\n", 
            "-\n", 
            "-            metrics.incrementBytesReceived(responseRead);\n", 
            "-        } catch (IOException e) {\n", 
            "-            logIOException(conn, e);\n", 
            "-\n", 
            "-            informReaderError(conn);\n", 
            "-\n", 
            "-            TargetContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-        } catch (Exception ex) {\n", 
            "-            log.error(ex.getMessage(), ex);\n", 
            "-\n", 
            "-            informReaderError(conn);\n", 
            "-\n", 
            "-            TargetContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-            targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void closed(NHttpClientConnection conn) {\n", 
            "-        ProtocolState state = TargetContext.getState(conn);\n", 
            "-        \n", 
            "-        boolean sendFault = false;\n", 
            "-\n", 
            "-        if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"Keep-Alive Connection closed\");\n", 
            "-            }\n", 
            "-        } else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {\n", 
            "-            informWriterError(conn);\n", 
            "-            log.warn(\"Connection closed by target host while sending the request\");\n", 
            "-            sendFault = true;\n", 
            "-        } else if (state == ProtocolState.RESPONSE_HEAD || state == ProtocolState.RESPONSE_BODY) {\n", 
            "-            informReaderError(conn);\n", 
            "-            log.warn(\"Connection closed by target host while receiving the response\");\n", 
            "-            sendFault = false;\n", 
            "-        } else if (state == ProtocolState.REQUEST_DONE) {\n", 
            "-            informWriterError(conn);\n", 
            "-            log.warn(\"Connection closed by target host before receiving the request\");\n", 
            "-            sendFault = true;\n", 
            "-        }\n", 
            "-\n", 
            "-        if (sendFault) {\n", 
            "-            MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();\n", 
            "-            if (requestMsgCtx != null) {\n", 
            "-                targetErrorHandler.handleError(requestMsgCtx,\n", 
            "-                        ErrorCodes.CONNECTION_CLOSED,\n", 
            "-                        \"Error in Sender\",\n", 
            "-                        null,\n", 
            "-                        state);\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        metrics.disconnected();\n", 
            "-\n", 
            "-        TargetContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-        targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void exception(NHttpClientConnection conn, IOException e) {\n", 
            "-        ProtocolState state = TargetContext.getState(conn);\n", 
            "-\n", 
            "-        logIOException(conn, e);\n", 
            "-\n", 
            "-        MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();\n", 
            "-        if (requestMsgCtx != null) {\n", 
            "-            targetErrorHandler.handleError(requestMsgCtx,\n", 
            "-                    ErrorCodes.SND_IO_ERROR,\n", 
            "-                    \"Error in Sender\",\n", 
            "-                    null,\n", 
            "-                    state);\n", 
            "-        }\n", 
            "-\n", 
            "-        TargetContext.updateState(conn, ProtocolState.CLOSING);\n", 
            "-        targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    private void logIOException(NHttpClientConnection conn, IOException e) {\n", 
            "-        String message = getErrorMessage(\"I/O error : \" + e.getMessage(), conn);\n", 
            "-\n", 
            "-        if (e instanceof ConnectionClosedException || (e.getMessage() != null &&\n", 
            "-                e.getMessage().toLowerCase().contains(\"connection reset by peer\") ||\n", 
            "-                e.getMessage().toLowerCase().contains(\"forcibly closed\"))) {\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"I/O error (Probably the keep-alive connection \" +\n", 
            "-                        \"was closed):\" + e.getMessage());\n", 
            "-            }\n", 
            "-        } else if (e.getMessage() != null) {\n", 
            "-            String msg = e.getMessage().toLowerCase();\n", 
            "-            if (msg.indexOf(\"broken\") != -1) {\n", 
            "-                log.warn(\"I/O error (Probably the connection \" +\n", 
            "-                        \"was closed by the remote party):\" + e.getMessage());\n", 
            "-            } else {\n", 
            "-                log.error(\"I/O error: \" + e.getMessage(), e);\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            log.error(message, e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public void exception(NHttpClientConnection conn, HttpException e) {\n", 
            "-        ProtocolState state = TargetContext.getState(conn);\n", 
            "-\n", 
            "-        String message = getErrorMessage(\"HTTP protocol violation : \" + e.getMessage(), conn);\n", 
            "-        log.error(message, e);\n", 
            "-\n", 
            "-        MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();\n", 
            "-        if (requestMsgCtx != null) {\n", 
            "-            targetErrorHandler.handleError(requestMsgCtx,\n", 
            "-                    ErrorCodes.PROTOCOL_VIOLATION,\n", 
            "-                    \"Error in Sender\",\n", 
            "-                    null,\n", 
            "-                    state);\n", 
            "-        }\n", 
            "-\n", 
            "-        TargetContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-        targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void timeout(NHttpClientConnection conn) {\n", 
            "-        ProtocolState state = TargetContext.getState(conn);\n", 
            "-\n", 
            "-        String message = getErrorMessage(\"Connection timeout\", conn);\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            log.debug(message);\n", 
            "-        }\n", 
            "-\n", 
            "-        if (state != null &&\n", 
            "-                (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE)) {\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(getErrorMessage(\"Keep-alive connection timed out\", conn));\n", 
            "-            }\n", 
            "-        } else if (state != null ) {\n", 
            "-            if (state == ProtocolState.REQUEST_BODY) {\n", 
            "-                metrics.incrementTimeoutsSending();\n", 
            "-                informWriterError(conn);\n", 
            "-            }\n", 
            "-\n", 
            "-            if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.REQUEST_HEAD) {\n", 
            "-                metrics.incrementTimeoutsReceiving();\n", 
            "-                informReaderError(conn);\n", 
            "-            }\n", 
            "-\n", 
            "-            if (state.compareTo(ProtocolState.REQUEST_DONE) <= 0) {\n", 
            "-                MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();\n", 
            "-\n", 
            "-                log.warn(\"Connection time out while in state: \" + state);\n", 
            "-                if (requestMsgCtx != null) {\n", 
            "-                    targetErrorHandler.handleError(requestMsgCtx,\n", 
            "-                            ErrorCodes.CONNECTION_TIMEOUT,\n", 
            "-                            \"Error in Sender\",\n", 
            "-                            null,\n", 
            "-                            state);\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        TargetContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-        targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-    }\n", 
            "-\n", 
            "-    private boolean isResponseHaveBodyExpected(\n", 
            "-            final String method, final HttpResponse response) {\n", 
            "-\n", 
            "-        if (\"HEAD\".equalsIgnoreCase(method)) {\n", 
            "-            return false;\n", 
            "-        }\n", 
            "-\n", 
            "-        int status = response.getStatusLine().getStatusCode();\n", 
            "-        return status >= HttpStatus.SC_OK\n", 
            "-            && status != HttpStatus.SC_NO_CONTENT\n", 
            "-            && status != HttpStatus.SC_NOT_MODIFIED\n", 
            "-            && status != HttpStatus.SC_RESET_CONTENT;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Include remote host and port information to an error message\n", 
            "-     *\n", 
            "-     * @param message the initial message\n", 
            "-     * @param conn    the connection encountering the error\n", 
            "-     * @return the updated error message\n", 
            "-     */\n", 
            "-    private String getErrorMessage(String message, NHttpClientConnection conn) {\n", 
            "-        if (conn != null && conn instanceof DefaultNHttpClientConnection) {\n", 
            "-            DefaultNHttpClientConnection c = ((DefaultNHttpClientConnection) conn);\n", 
            "-\n", 
            "-            if (c.getRemoteAddress() != null) {\n", 
            "-                return message + \" For : \" + c.getRemoteAddress().getHostAddress() + \":\" +\n", 
            "-                        c.getRemotePort();\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return message;\n", 
            "-    }\n", 
            "-\n", 
            "-    private void handleInvalidState(NHttpClientConnection conn, String action) {\n", 
            "-        ProtocolState state = TargetContext.getState(conn);\n", 
            "-\n", 
            "-        log.warn(action + \" while the handler is in an inconsistent state \" +\n", 
            "-                TargetContext.getState(conn));\n", 
            "-        MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();\n", 
            "-        TargetContext.updateState(conn, ProtocolState.CLOSED);\n", 
            "-        targetConfiguration.getConnections().shutdownConnection(conn);\n", 
            "-        if (requestMsgCtx != null) {\n", 
            "-            targetErrorHandler.handleError(requestMsgCtx,\n", 
            "-                    ErrorCodes.SND_INVALID_STATE,\n", 
            "-                    \"Error in Sender\",\n", 
            "-                    null,\n", 
            "-                    state);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private void informReaderError(NHttpClientConnection conn) {\n", 
            "-        Pipe reader = TargetContext.get(conn).getReader();\n", 
            "-\n", 
            "-        metrics.incrementFaultsReceiving();\n", 
            "-\n", 
            "-        if (reader != null) {\n", 
            "-            reader.producerError();\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private void informWriterError(NHttpClientConnection conn) {\n", 
            "-        Pipe writer = TargetContext.get(conn).getWriter();\n", 
            "-\n", 
            "-        metrics.incrementFaultsReceiving();\n", 
            "-\n", 
            "-        if (writer != null) {\n", 
            "-            writer.consumerError();\n", 
            "-        }\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetHandler.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,169 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.config;\n", 
            "-\n", 
            "-import org.apache.axis2.context.ConfigurationContext;\n", 
            "-import org.apache.axis2.description.Parameter;\n", 
            "-import org.apache.axis2.description.TransportInDescription;\n", 
            "-import org.apache.axis2.transport.TransportListener;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.params.*;\n", 
            "-import org.apache.http.protocol.*;\n", 
            "-import org.apache.http.HttpResponseFactory;\n", 
            "-import org.apache.http.HttpResponseInterceptor;\n", 
            "-import org.apache.http.impl.DefaultHttpResponseFactory;\n", 
            "-import org.apache.axis2.transport.base.threads.WorkerPool;\n", 
            "-import org.apache.axis2.transport.base.ParamUtils;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.synapse.transport.passthru.PassThroughConstants;\n", 
            "-import org.apache.synapse.transport.passthru.connections.SourceConnections;\n", 
            "-\n", 
            "-import java.net.UnknownHostException;\n", 
            "-\n", 
            "-/**\n", 
            "- * This class stores configurations specific to the Listeners\n", 
            "- */\n", 
            "-public class SourceConfiguration extends BaseConfiguration {\n", 
            "-\n", 
            "-    private Log log = LogFactory.getLog(SourceConfiguration.class);\n", 
            "-\n", 
            "-    /** This is used to process HTTP responses */\n", 
            "-    private HttpProcessor httpProcessor = null;\n", 
            "-\n", 
            "-    /** Response factory used for creating HTTP Responses */\n", 
            "-    private HttpResponseFactory responseFactory = null;\n", 
            "-\n", 
            "-    /** port of the listener */\n", 
            "-    private int port = 8280;\n", 
            "-\n", 
            "-    /** Object to manage the source connections */\n", 
            "-    private SourceConnections sourceConnections = null;\n", 
            "-\n", 
            "-    private TransportInDescription inDescription;\n", 
            "-\n", 
            "-    private String host;\n", 
            "-\n", 
            "-    /** The EPR prefix for services available over this transport */\n", 
            "-    private String serviceEPRPrefix;\n", 
            "-    /** The EPR prefix for services with custom URI available over this transport */\n", 
            "-    private String customEPRPrefix;\n", 
            "-\n", 
            "-    public SourceConfiguration(ConfigurationContext configurationContext,\n", 
            "-                               TransportInDescription description,\n", 
            "-                               WorkerPool pool) {\n", 
            "-        super(configurationContext, description, pool);\n", 
            "-        this.inDescription = description;\n", 
            "-        httpProcessor = new ImmutableHttpProcessor(\n", 
            "-                new HttpResponseInterceptor[]{\n", 
            "-                        new ResponseDate(),\n", 
            "-                        new ResponseServer(),\n", 
            "-                        new ResponseContent(),\n", 
            "-                        new ResponseConnControl()});\n", 
            "-\n", 
            "-        responseFactory = new DefaultHttpResponseFactory();\n", 
            "-\n", 
            "-        sourceConnections = new SourceConnections();\n", 
            "-    }\n", 
            "-\n", 
            "-    public void build() throws AxisFault {\n", 
            "-        super.build();\n", 
            "-\n", 
            "-        port = ParamUtils.getRequiredParamInt(parameters, \"port\");\n", 
            "-\n", 
            "-        Parameter hostParameter = inDescription.getParameter(TransportListener.HOST_ADDRESS);\n", 
            "-        if (hostParameter != null) {\n", 
            "-            host = ((String) hostParameter.getValue()).trim();\n", 
            "-        } else {\n", 
            "-            try {\n", 
            "-                host = java.net.InetAddress.getLocalHost().getHostName();\n", 
            "-            } catch (UnknownHostException e) {\n", 
            "-                log.warn(\"Unable to lookup local host name, using 'localhost'\");\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        Parameter param = inDescription.getParameter(PassThroughConstants.WSDL_EPR_PREFIX);\n", 
            "-        if (param != null) {\n", 
            "-            serviceEPRPrefix = getServiceEPRPrefix(configurationContext, (String) param.getValue());\n", 
            "-            customEPRPrefix = (String) param.getValue();\n", 
            "-        } else {\n", 
            "-            serviceEPRPrefix = getServiceEPRPrefix(configurationContext, host, port);\n", 
            "-            customEPRPrefix = inDescription.getName() + \"://\" + host + \":\" +\n", 
            "-                    (port == 80 ? \"\" : port) + \"/\";\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public HttpParams getHttpParameters() {\n", 
            "-        return httpParameters;\n", 
            "-    }\n", 
            "-\n", 
            "-    public HttpProcessor getHttpProcessor() {\n", 
            "-        return httpProcessor;\n", 
            "-    }\n", 
            "-\n", 
            "-    public HttpResponseFactory getResponseFactory() {\n", 
            "-        return responseFactory;\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getPort() {\n", 
            "-        return port;\n", 
            "-    }\n", 
            "-\n", 
            "-    public SourceConnections getSourceConnections() {\n", 
            "-        return sourceConnections;\n", 
            "-    }\n", 
            "-\n", 
            "-    public TransportInDescription getInDescription() {\n", 
            "-        return inDescription;\n", 
            "-    }\n", 
            "-\n", 
            "-    public String getServiceEPRPrefix() {\n", 
            "-        return serviceEPRPrefix;\n", 
            "-    }\n", 
            "-\n", 
            "-    public String getCustomEPRPrefix() {\n", 
            "-        return customEPRPrefix;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Return the EPR prefix for services made available over this transport\n", 
            "-     * @param cfgCtx configuration context to retrieve the service context path\n", 
            "-     * @param wsdlEPRPrefix specified wsdlPrefix\n", 
            "-     *\n", 
            "-     * @return wsdlEPRPrefix for the listener\n", 
            "-     */\n", 
            "-    protected String getServiceEPRPrefix(ConfigurationContext cfgCtx, String wsdlEPRPrefix) {\n", 
            "-        return wsdlEPRPrefix +\n", 
            "-            (!cfgCtx.getServiceContextPath().startsWith(\"/\") ? \"/\" : \"\") +\n", 
            "-            cfgCtx.getServiceContextPath() +\n", 
            "-            (!cfgCtx.getServiceContextPath().endsWith(\"/\") ? \"/\" : \"\");\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Return the EPR prefix for services made available over this transport\n", 
            "-     * @param cfgCtx configuration context to retrieve the service context path\n", 
            "-     * @param host name of the host\n", 
            "-     * @param port listening port\n", 
            "-     * @return wsdlEPRPrefix for the listener\n", 
            "-     */\n", 
            "-    protected String getServiceEPRPrefix(ConfigurationContext cfgCtx, String host, int port) {\n", 
            "-        return \"http://\" + host + (port == 80 ? \"\" : \":\" + port) +\n", 
            "-            (!cfgCtx.getServiceContextPath().startsWith(\"/\") ? \"/\" : \"\") +\n", 
            "-            cfgCtx.getServiceContextPath() +\n", 
            "-            (!cfgCtx.getServiceContextPath().endsWith(\"/\") ? \"/\" : \"\");\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/SourceConfiguration.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/SourceConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,95 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.config;\n", 
            "-\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.context.ConfigurationContext;\n", 
            "-import org.apache.axis2.description.ParameterInclude;\n", 
            "-import org.apache.axis2.transport.base.threads.WorkerPool;\n", 
            "-import org.apache.http.HttpRequestInterceptor;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-import org.apache.http.protocol.*;\n", 
            "-import org.apache.synapse.transport.passthru.connections.TargetConnections;\n", 
            "-\n", 
            "-/**\n", 
            "- * This class stores configuration specific to HTTP Connectors (Senders)\n", 
            "- */\n", 
            "-public class TargetConfiguration extends BaseConfiguration {\n", 
            "-\n", 
            "-    private HttpProcessor httpProcessor = null;\n", 
            "-\n", 
            "-    private int maxConnections = Integer.MAX_VALUE;\n", 
            "-\n", 
            "-    /** Weather User-Agent header coming from client should be preserved */\n", 
            "-    private boolean preserveUserAgentHeader = false;\n", 
            "-    /** Weather Server header coming from server should be preserved */\n", 
            "-    private boolean preserveServerHeader = true;\n", 
            "-\n", 
            "-    private TargetConnections connections = null;\n", 
            "-\n", 
            "-    public TargetConfiguration(ConfigurationContext configurationContext,\n", 
            "-                               ParameterInclude parameters,\n", 
            "-                               WorkerPool pool) {\n", 
            "-        super(configurationContext, parameters, pool);\n", 
            "-\n", 
            "-        httpProcessor = new ImmutableHttpProcessor(\n", 
            "-                new HttpRequestInterceptor[] {\n", 
            "-                        new RequestContent(),\n", 
            "-                        new RequestTargetHost(),\n", 
            "-                        new RequestConnControl(),\n", 
            "-                        new RequestUserAgent(),\n", 
            "-                        new RequestExpectContinue()\n", 
            "-         });\n", 
            "-    }\n", 
            "-\n", 
            "-    public void build() throws AxisFault {\n", 
            "-        super.build();\n", 
            "-\n", 
            "-        maxConnections = conf.getIntProperty(PassThroughConfigPNames.MAX_CONNECTION_PER_HOST_PORT,\n", 
            "-                Integer.MAX_VALUE);\n", 
            "-        preserveUserAgentHeader = conf.isPreserveUserAgentHeader();\n", 
            "-        preserveServerHeader = conf.isPreserveServerHeader();\n", 
            "-    }\n", 
            "-\n", 
            "-    public HttpParams getHttpParameters() {\n", 
            "-        return httpParameters;\n", 
            "-    }\n", 
            "-\n", 
            "-    public HttpProcessor getHttpProcessor() {\n", 
            "-        return httpProcessor;\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getMaxConnections() {\n", 
            "-        return maxConnections;\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean isPreserveUserAgentHeader() {\n", 
            "-        return preserveUserAgentHeader;\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean isPreserveServerHeader() {\n", 
            "-        return preserveServerHeader;\n", 
            "-    }\n", 
            "-\n", 
            "-    public TargetConnections getConnections() {\n", 
            "-        return connections;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setConnections(TargetConnections connections) {\n", 
            "-        this.connections = connections;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/TargetConfiguration.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/TargetConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,236 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.config;\n", 
            "-\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-\n", 
            "-import java.io.File;\n", 
            "-import java.io.IOException;\n", 
            "-import java.io.InputStream;\n", 
            "-import java.util.Properties;\n", 
            "-\n", 
            "-/**\n", 
            "- * This class encapsulates pass-through http transport tuning configurations specified via a\n", 
            "- * configurations file or system properties.\n", 
            "- */\n", 
            "-public class PassThroughConfiguration {\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Default tuning parameter values\n", 
            "-     */\n", 
            "-    private static final int DEFAULT_WORKER_POOL_SIZE_CORE       = 40;\n", 
            "-    private static final int DEFAULT_WORKER_POOL_SIZE_MAX        = 200;\n", 
            "-    private static final int DEFAULT_WORKER_THREAD_KEEPALIVE_SEC = 60;\n", 
            "-    private static final int DEFAULT_WORKER_POOL_QUEUE_LENGTH    = -1;\n", 
            "-    private static final int DEFAULT_IO_BUFFER_SIZE              = 8 * 1024;\n", 
            "-    private static final int DEFAULT_IO_THREADS_PER_REACTOR      =\n", 
            "-                                                         Runtime.getRuntime().availableProcessors();\n", 
            "-\n", 
            "-    private static final Log log = LogFactory.getLog(PassThroughConfiguration.class);\n", 
            "-\n", 
            "-    private static PassThroughConfiguration _instance = new PassThroughConfiguration();\n", 
            "-\n", 
            "-    private Properties props;\n", 
            "-\n", 
            "-    private PassThroughConfiguration() {\n", 
            "-        try {\n", 
            "-            props = loadProperties(\"passthru-http.properties\");\n", 
            "-        } catch (Exception ignored) {}\n", 
            "-    }\n", 
            "-\n", 
            "-    public static PassThroughConfiguration getInstance() {\n", 
            "-        return _instance;\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getWorkerPoolCoreSize() {\n", 
            "-        return getIntProperty(PassThroughConfigPNames.WORKER_POOL_SIZE_CORE,\n", 
            "-                DEFAULT_WORKER_POOL_SIZE_CORE);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getWorkerPoolMaxSize() {\n", 
            "-        return getIntProperty(PassThroughConfigPNames.WORKER_POOL_SIZE_MAX,\n", 
            "-                DEFAULT_WORKER_POOL_SIZE_MAX);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getWorkerThreadKeepaliveSec() {\n", 
            "-        return getIntProperty(PassThroughConfigPNames.WORKER_THREAD_KEEP_ALIVE_SEC,\n", 
            "-                DEFAULT_WORKER_THREAD_KEEPALIVE_SEC);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getWorkerPoolQueueLen() {\n", 
            "-        return getIntProperty(PassThroughConfigPNames.WORKER_POOL_QUEUE_LENGTH,\n", 
            "-                DEFAULT_WORKER_POOL_QUEUE_LENGTH);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getIOThreadsPerReactor() {\n", 
            "-        return getIntProperty(PassThroughConfigPNames.IO_THREADS_PER_REACTOR,\n", 
            "-                DEFAULT_IO_THREADS_PER_REACTOR);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getIOBufferSize() {\n", 
            "-        return getIntProperty(PassThroughConfigPNames.IO_BUFFER_SIZE,\n", 
            "-                DEFAULT_IO_BUFFER_SIZE);\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean isKeepAliveDisabled() {\n", 
            "-        return getBooleanProperty(PassThroughConfigPNames.DISABLE_KEEPALIVE, false);\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean isPreserveUserAgentHeader() {\n", 
            "-        return getBooleanProperty(PassThroughConfigPNames.USER_AGENT_HEADER_PRESERVE, false);\n", 
            "-    }\n", 
            "-\n", 
            "-    public boolean isPreserveServerHeader() {\n", 
            "-        return getBooleanProperty(PassThroughConfigPNames.SERVER_HEADER_PRESERVE, true);\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Loads the properties from a given property file path\n", 
            "-     *\n", 
            "-     * @param filePath Path of the property file\n", 
            "-     * @return Properties loaded from given file\n", 
            "-     */\n", 
            "-    private static Properties loadProperties(String filePath) {\n", 
            "-\n", 
            "-        Properties properties = new Properties();\n", 
            "-        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n", 
            "-\n", 
            "-        if (log.isDebugEnabled()) {\n", 
            "-            log.debug(\"Loading the file '\" + filePath + \"' from classpath\");\n", 
            "-        }\n", 
            "-\n", 
            "-        InputStream in = cl.getResourceAsStream(filePath);\n", 
            "-        if (in == null) {\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"Unable to load file  '\" + filePath + \"'\");\n", 
            "-            }\n", 
            "-\n", 
            "-            filePath = \"conf\" + File.separatorChar + filePath;\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"Loading the file '\" + filePath + \"'\");\n", 
            "-            }\n", 
            "-\n", 
            "-            in = cl.getResourceAsStream(filePath);\n", 
            "-            if (in == null) {\n", 
            "-                if (log.isDebugEnabled()) {\n", 
            "-                    log.debug(\"Unable to load file  '\" + filePath + \"'\");\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-        if (in != null) {\n", 
            "-            try {\n", 
            "-                properties.load(in);\n", 
            "-            } catch (IOException e) {\n", 
            "-                String msg = \"Error loading properties from a file at : \" + filePath;\n", 
            "-                log.error(msg, e);\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return properties;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Get an int property that tunes pass-through http transport. Prefer system properties\n", 
            "-     *\n", 
            "-     * @param name name of the system/config property\n", 
            "-     * @param def  default value to return if the property is not set\n", 
            "-     * @return the value of the property to be used\n", 
            "-     */\n", 
            "-    public Integer getIntProperty(String name, Integer def) {\n", 
            "-        String val = System.getProperty(name);\n", 
            "-        if (val == null) {\n", 
            "-            val = props.getProperty(name);\n", 
            "-        }\n", 
            "-\n", 
            "-        if (val != null) {\n", 
            "-            int intVal;\n", 
            "-            try {\n", 
            "-                intVal = Integer.valueOf(val);\n", 
            "-            } catch (NumberFormatException e) {\n", 
            "-                log.warn(\"Invalid pass-through http tuning property value. \" + name +\n", 
            "-                        \" must be an integer\");\n", 
            "-                return def;\n", 
            "-            }\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"Using pass-through http tuning parameter : \" + name + \" = \" + val);\n", 
            "-            }\n", 
            "-            return intVal;\n", 
            "-        }\n", 
            "-\n", 
            "-        return def;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Get an int property that tunes pass-through http transport. Prefer system properties\n", 
            "-     *\n", 
            "-     * @param name name of the system/config property\n", 
            "-     * @return the value of the property, null if the property is not found\n", 
            "-     */\n", 
            "-    public Integer getIntProperty(String name) {\n", 
            "-        return getIntProperty(name, null);\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Get a boolean property that tunes pass-through http transport. Prefer system properties\n", 
            "-     *\n", 
            "-     * @param name name of the system/config property\n", 
            "-     * @param def  default value to return if the property is not set\n", 
            "-     * @return the value of the property to be used\n", 
            "-     */\n", 
            "-    public Boolean getBooleanProperty(String name, Boolean def) {\n", 
            "-        String val = System.getProperty(name);\n", 
            "-        if (val == null) {\n", 
            "-            val = props.getProperty(name);\n", 
            "-        }\n", 
            "-\n", 
            "-        if (val != null) {\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"Using pass-through http tuning parameter : \" + name + \" = \" + val);\n", 
            "-            }\n", 
            "-            return Boolean.valueOf(val);\n", 
            "-        }\n", 
            "-\n", 
            "-        return def;\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Get a Boolean property that tunes pass-through http transport. Prefer system properties\n", 
            "-     *\n", 
            "-     * @param name name of the system/config property\n", 
            "-     * @return the value of the property, null if the property is not found\n", 
            "-     */\n", 
            "-    public Boolean getBooleanProperty(String name) {\n", 
            "-        return getBooleanProperty(name, null);\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Get a String property that tunes pass-through http transport. Prefer system properties\n", 
            "-     *\n", 
            "-     * @param name name of the system/config property\n", 
            "-     * @param def  default value to return if the property is not set\n", 
            "-     * @return the value of the property to be used\n", 
            "-     */\n", 
            "-    public String getStringProperty(String name, String def) {\n", 
            "-        String val = System.getProperty(name);\n", 
            "-        if (val == null) {\n", 
            "-            val = props.getProperty(name);\n", 
            "-        }\n", 
            "-\n", 
            "-        return val == null ? def : val;\n", 
            "-    }\n", 
            "-\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfiguration.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,74 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.config;\n", 
            "-\n", 
            "-/**\n", 
            "- * Defines configuration parameter names for Pass-through HTTP Transport.\n", 
            "- */\n", 
            "-public interface PassThroughConfigPNames {\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Defines the core size (number of threads) of the worker thread pool.\n", 
            "-     */\n", 
            "-    public String WORKER_POOL_SIZE_CORE = \"worker_pool_size_core\";\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Defines the maximum size (number of threads) of the worker thread pool.\n", 
            "-     */\n", 
            "-    public String WORKER_POOL_SIZE_MAX = \"worker_pool_size_max\";\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Defines the keep-alive time for extra threads in the worker pool.\n", 
            "-     */\n", 
            "-    public String WORKER_THREAD_KEEP_ALIVE_SEC = \"worker_thread_keepalive_sec\";\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Defines the length of the queue that is used to hold Runnable tasks to be executed by the\n", 
            "-     * worker pool.\n", 
            "-     */\n", 
            "-    public String WORKER_POOL_QUEUE_LENGTH = \"worker_pool_queue_length\";\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Defines the number of IO dispatcher threads used per reactor\n", 
            "-     */\n", 
            "-    public String IO_THREADS_PER_REACTOR = \"io_threads_per_reactor\";\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Defines the IO buffer size\n", 
            "-     */\n", 
            "-    public String IO_BUFFER_SIZE = \"io_buffer_size\";\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Defines whether ESB needs to preserve the original User-Agent header.\n", 
            "-     */\n", 
            "-    public String USER_AGENT_HEADER_PRESERVE = \"http.user.agent.preserve\";\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Defines whether ESB needs to preserve the original Server header.\n", 
            "-     */\n", 
            "-    public String SERVER_HEADER_PRESERVE = \"http.server.preserve\";\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Defines whether HTTP keep-alive is disabled\n", 
            "-     */\n", 
            "-    public String DISABLE_KEEPALIVE = \"http.connection.disable.keepalive\";\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Defines the maximum number of connections per host port\n", 
            "-     */\n", 
            "-    public String MAX_CONNECTION_PER_HOST_PORT = \"http.max.connection.per.host.port\";\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfigPNames.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfigPNames.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,160 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.transport.passthru.config;\n", 
            "-\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.context.ConfigurationContext;\n", 
            "-import org.apache.axis2.description.ParameterInclude;\n", 
            "-import org.apache.axis2.transport.base.threads.WorkerPool;\n", 
            "-import org.apache.axis2.transport.base.threads.WorkerPoolFactory;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.http.nio.params.NIOReactorPNames;\n", 
            "-import org.apache.http.nio.params.NIOReactorParams;\n", 
            "-import org.apache.http.nio.util.HeapByteBufferAllocator;\n", 
            "-import org.apache.http.params.BasicHttpParams;\n", 
            "-import org.apache.http.params.HttpConnectionParams;\n", 
            "-import org.apache.http.params.HttpParams;\n", 
            "-import org.apache.http.params.HttpProtocolParams;\n", 
            "-import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;\n", 
            "-import org.apache.synapse.transport.passthru.util.BufferFactory;\n", 
            "-\n", 
            "-/**\n", 
            "- * This class has common configurations for both sender and receiver.\n", 
            "- */\n", 
            "-public abstract class BaseConfiguration {\n", 
            "-\n", 
            "-    private Log log = LogFactory.getLog(BaseConfiguration.class);\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Configurations given by axis2.xml\n", 
            "-     */\n", 
            "-    protected ParameterInclude parameters = null;\n", 
            "-\n", 
            "-    /** The thread pool for executing the messages passing through */\n", 
            "-    private WorkerPool workerPool = null;\n", 
            "-\n", 
            "-    /** The Axis2 ConfigurationContext */\n", 
            "-    protected ConfigurationContext configurationContext = null;\n", 
            "-\n", 
            "-    /** Default http parameters */\n", 
            "-    protected HttpParams httpParameters = null;\n", 
            "-\n", 
            "-    protected BufferFactory bufferFactory = null;\n", 
            "-\n", 
            "-    private PassThroughTransportMetricsCollector metrics = null;\n", 
            "-\n", 
            "-    private int iOThreadsPerReactor;\n", 
            "-\n", 
            "-    private int iOBufferSize;\n", 
            "-\n", 
            "-    protected PassThroughConfiguration conf = PassThroughConfiguration.getInstance();\n", 
            "-\n", 
            "-    public BaseConfiguration(ConfigurationContext configurationContext,\n", 
            "-                             ParameterInclude parameters,\n", 
            "-                             WorkerPool workerPool) {\n", 
            "-        this.parameters = parameters;\n", 
            "-        this.workerPool = workerPool;\n", 
            "-        this.configurationContext = configurationContext;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void build() throws AxisFault {\n", 
            "-        iOThreadsPerReactor = conf.getIOThreadsPerReactor();\n", 
            "-\n", 
            "-        iOBufferSize = conf.getIOBufferSize();\n", 
            "-\n", 
            "-        if (workerPool == null) {\n", 
            "-            workerPool = WorkerPoolFactory.getWorkerPool(\n", 
            "-                            conf.getWorkerPoolCoreSize(),\n", 
            "-                            conf.getWorkerPoolMaxSize(),\n", 
            "-                            conf.getWorkerThreadKeepaliveSec(),\n", 
            "-                            conf.getWorkerPoolQueueLen(),\n", 
            "-                            \"Pass-through Message Processing Thread Group\",\n", 
            "-                            \"PassThroughMessageProcessor\");\n", 
            "-        }\n", 
            "-\n", 
            "-        httpParameters = retrieveHttpParameters();\n", 
            "-\n", 
            "-        bufferFactory = new BufferFactory(iOBufferSize, new HeapByteBufferAllocator(), 512);\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getIOThreadsPerReactor() {\n", 
            "-        return iOThreadsPerReactor;\n", 
            "-    }\n", 
            "-\n", 
            "-    public int getIOBufferSize() {\n", 
            "-        return iOBufferSize;\n", 
            "-    }\n", 
            "-\n", 
            "-    public WorkerPool getWorkerPool() {\n", 
            "-        return workerPool;\n", 
            "-    }\n", 
            "-\n", 
            "-    public ConfigurationContext getConfigurationContext() {\n", 
            "-        return configurationContext;\n", 
            "-    }\n", 
            "-\n", 
            "-    protected HttpParams retrieveHttpParameters() throws AxisFault {\n", 
            "-        HttpParams params = new BasicHttpParams();\n", 
            "-        params.\n", 
            "-            setIntParameter(HttpConnectionParams.SO_TIMEOUT,\n", 
            "-                    conf.getIntProperty(HttpConnectionParams.SO_TIMEOUT, 60000)).\n", 
            "-            setIntParameter(HttpConnectionParams.CONNECTION_TIMEOUT,\n", 
            "-                    conf.getIntProperty(HttpConnectionParams.CONNECTION_TIMEOUT, 0)).\n", 
            "-            setIntParameter(HttpConnectionParams.SOCKET_BUFFER_SIZE,\n", 
            "-                    conf.getIntProperty(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024)).\n", 
            "-            setBooleanParameter(HttpConnectionParams.STALE_CONNECTION_CHECK,\n", 
            "-                    conf.getBooleanProperty(HttpConnectionParams.STALE_CONNECTION_CHECK, false)).\n", 
            "-            setBooleanParameter(HttpConnectionParams.TCP_NODELAY,\n", 
            "-                    conf.getBooleanProperty(HttpConnectionParams.TCP_NODELAY, true)).\n", 
            "-            setBooleanParameter(NIOReactorPNames.INTEREST_OPS_QUEUEING,\n", 
            "-                    conf.getBooleanProperty(NIOReactorParams.INTEREST_OPS_QUEUEING, false)).\n", 
            "-            setParameter(HttpProtocolParams.ORIGIN_SERVER,\n", 
            "-                    conf.getStringProperty(HttpProtocolParams.ORIGIN_SERVER, \"Synapse-PassThrough-HTTP\"));\n", 
            "-\n", 
            "-        /* Set advanced tuning params only if they are explicitly set so that we are not loosing\n", 
            "-           internal defaults of HttpCore-NIO */\n", 
            "-        if (conf.getIntProperty(HttpConnectionParams.SO_LINGER) != null) {\n", 
            "-            HttpConnectionParams.setLinger(params,\n", 
            "-                    conf.getIntProperty(HttpConnectionParams.SO_LINGER));\n", 
            "-        }\n", 
            "-\n", 
            "-        if (conf.getBooleanProperty(HttpConnectionParams.SO_REUSEADDR) != null) {\n", 
            "-            HttpConnectionParams.setSoReuseaddr(params,\n", 
            "-                    conf.getBooleanProperty(HttpConnectionParams.SO_REUSEADDR));\n", 
            "-        }\n", 
            "-\n", 
            "-        if (conf.getIntProperty(NIOReactorPNames.SELECT_INTERVAL) != null) {\n", 
            "-            NIOReactorParams.setSelectInterval(params,\n", 
            "-                    conf.getIntProperty(NIOReactorPNames.SELECT_INTERVAL));\n", 
            "-        }\n", 
            "-\n", 
            "-        return params;\n", 
            "-    }\n", 
            "-\n", 
            "-    public BufferFactory getBufferFactory() {\n", 
            "-        return bufferFactory;\n", 
            "-    }\n", 
            "-\n", 
            "-    public PassThroughTransportMetricsCollector getMetrics() {\n", 
            "-        return metrics;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void setMetrics(PassThroughTransportMetricsCollector metrics) {\n", 
            "-        this.metrics = metrics;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/BaseConfiguration.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/BaseConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,234 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.core.relay;\n", 
            "-\n", 
            "-import org.apache.axiom.om.*;\n", 
            "-import org.apache.axiom.soap.SOAPEnvelope;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.Constants;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.description.Parameter;\n", 
            "-import org.apache.axis2.transport.MessageFormatter;\n", 
            "-import org.apache.axis2.transport.http.HTTPConstants;\n", 
            "-import org.apache.axis2.transport.http.SOAPMessageFormatter;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-\n", 
            "-import javax.activation.DataHandler;\n", 
            "-import javax.activation.DataSource;\n", 
            "-import javax.xml.stream.XMLStreamException;\n", 
            "-import java.io.ByteArrayOutputStream;\n", 
            "-import java.io.IOException;\n", 
            "-import java.io.OutputStream;\n", 
            "-import java.net.URL;\n", 
            "-import java.util.Map;\n", 
            "-\n", 
            "-\n", 
            "-public class ExpandingMessageFormatter extends SOAPMessageFormatter {\n", 
            "-\n", 
            "-    private Log log = LogFactory.getLog(ExpandingMessageFormatter.class);\n", 
            "-\n", 
            "-    private static final String MESSAGE_AS_BYTES = \"MESSAGE_AS_BYTES\";\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public byte[] getBytes(MessageContext messageContext, OMOutputFormat format)\n", 
            "-            throws AxisFault {\n", 
            "-        SOAPEnvelope envelope = messageContext.getEnvelope();\n", 
            "-        if (hasASoapMessageEmbedded(envelope)) {\n", 
            "-            ByteArrayOutputStream out = new ByteArrayOutputStream();\n", 
            "-            findAndWrite2OutputStream(messageContext, out, false);\n", 
            "-            return out.toByteArray();\n", 
            "-        } else {\n", 
            "-            return super.getBytes(messageContext, format);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public String getContentType(MessageContext msgCtx, OMOutputFormat format,\n", 
            "-                                 String soapActionString) {\n", 
            "-        String contentType = (String) msgCtx.getProperty(Constants.Configuration.CONTENT_TYPE);\n", 
            "-        if (contentType == null) {\n", 
            "-            MessageFormatter formatter = getMessageFormatter(msgCtx);\n", 
            "-            if (formatter != null) {\n", 
            "-                contentType = formatter.getContentType(msgCtx, format, soapActionString);\n", 
            "-            } else {\n", 
            "-                String messageType = getMessageFormatterProperty(msgCtx);\n", 
            "-                if (messageType.equals(HTTPConstants.MEDIA_TYPE_X_WWW_FORM)) {\n", 
            "-                    contentType = messageType;\n", 
            "-                    String encoding = format.getCharSetEncoding();\n", 
            "-                    if (encoding != null) {\n", 
            "-                        contentType = \"; charset=\" + encoding;\n", 
            "-                    }\n", 
            "-                } else {\n", 
            "-                    contentType = super.getContentType(msgCtx, format, soapActionString);\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return contentType;\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public void writeTo(MessageContext messageContext, OMOutputFormat format,\n", 
            "-                        OutputStream outputStream, boolean preserve) throws AxisFault {\n", 
            "-\n", 
            "-        try {\n", 
            "-            byte[] messageAsBytes = (byte[]) messageContext.getOperationContext().\n", 
            "-                    getProperty(MESSAGE_AS_BYTES);\n", 
            "-            if (messageAsBytes != null) {\n", 
            "-                outputStream.write(messageAsBytes);\n", 
            "-            } else {\n", 
            "-                SOAPEnvelope envelope = messageContext.getEnvelope();\n", 
            "-                Object forcedFormatter;\n", 
            "-                if (hasASoapMessageEmbedded(envelope)) {\n", 
            "-                    findAndWrite2OutputStream(messageContext, outputStream, preserve);\n", 
            "-                } else if ((forcedFormatter = messageContext.\n", 
            "-                        getProperty(DeferredMessageBuilder.FORCED_RELAY_FORMATTER)) != null) {\n", 
            "-                    /** If a formatter is forced by the builder mediator or some other means,\n", 
            "-                     *  it gets preference */\n", 
            "-                    if (forcedFormatter instanceof MessageFormatter) {\n", 
            "-                        ((MessageFormatter) forcedFormatter).writeTo(messageContext, format, outputStream, preserve);\n", 
            "-                    } else {\n", 
            "-                        String msg = \"Invalid formatter is forced by \" +\n", 
            "-                                DeferredMessageBuilder.FORCED_RELAY_FORMATTER + \" property.\";\n", 
            "-                        log.error(msg);\n", 
            "-                        throw new AxisFault(msg);\n", 
            "-                    }\n", 
            "-                } else {\n", 
            "-                    if (messageContext.isDoingREST()) {\n", 
            "-                        writeAsREST(messageContext, format, outputStream, preserve);\n", 
            "-                    } else {\n", 
            "-                        // try to get the formatters from the map set by the builder mediator or\n", 
            "-                        // SkipAdminHandler\n", 
            "-                        MessageFormatter formatter = getMessageFormatter(messageContext);\n", 
            "-                        if (formatter != null) {\n", 
            "-                            formatter.writeTo(messageContext, format,\n", 
            "-                                    outputStream, preserve);\n", 
            "-                        } else {\n", 
            "-                            super.writeTo(messageContext, format, outputStream, preserve);\n", 
            "-                        }\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            }\n", 
            "-        } catch (IOException e) {\n", 
            "-            throw AxisFault.makeFault(e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    @Override\n", 
            "-    public URL getTargetAddress(MessageContext msgCtx, OMOutputFormat format, URL targetURL) throws AxisFault {\n", 
            "-        if (!msgCtx.isDoingREST()) {\n", 
            "-            return super.getTargetAddress(msgCtx, format, targetURL);\n", 
            "-        }\n", 
            "-\n", 
            "-        return targetURL;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void writeAsREST(MessageContext messageContext, OMOutputFormat format,\n", 
            "-                            OutputStream outputStream, boolean preserve) throws AxisFault {\n", 
            "-        OMElement element = messageContext.getEnvelope().getBody().getFirstElement();\n", 
            "-        try {\n", 
            "-            if (element != null) {\n", 
            "-                if (preserve) {\n", 
            "-                    element.serialize(outputStream, format);\n", 
            "-                } else {\n", 
            "-                    element.serializeAndConsume(outputStream, format);\n", 
            "-                }\n", 
            "-            }\n", 
            "-            outputStream.flush();\n", 
            "-        } catch (XMLStreamException e) {\n", 
            "-            String msg = \"Error writing Rest message\";\n", 
            "-            log.error(msg, e);\n", 
            "-            throw new AxisFault(msg, e);\n", 
            "-        } catch (IOException e) {\n", 
            "-            String msg = \"Error writing text message to stream\";\n", 
            "-            log.error(msg);\n", 
            "-            throw new AxisFault(msg, e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private boolean hasASoapMessageEmbedded(SOAPEnvelope envelope) {\n", 
            "-        OMElement contentEle = envelope.getBody().getFirstElement();\n", 
            "-        return contentEle != null && contentEle.getQName().equals(RelayConstants.BINARY_CONTENT_QNAME);\n", 
            "-    }\n", 
            "-\n", 
            "-    private void findAndWrite2OutputStream(MessageContext messageContext,\n", 
            "-                                           OutputStream out,\n", 
            "-                                           boolean preserve) throws AxisFault {\n", 
            "-        try {\n", 
            "-            SOAPEnvelope envelope = messageContext.getEnvelope();\n", 
            "-            OMElement contentEle = envelope.getBody().getFirstElement();\n", 
            "-            if (contentEle != null) {\n", 
            "-                OMNode node = contentEle.getFirstOMChild();\n", 
            "-                if (!(node instanceof OMText)) {\n", 
            "-                    String msg = \"Wrong Input for the Validator, \" +\n", 
            "-                            \"the content of the first child element of the Body \" +\n", 
            "-                            \"should have the zip file\";\n", 
            "-                    log.error(msg);\n", 
            "-                    throw new AxisFault(msg);\n", 
            "-                }\n", 
            "-                OMText binaryDataNode = (OMText) node;\n", 
            "-                DataHandler dh = (DataHandler) binaryDataNode.getDataHandler();\n", 
            "-\n", 
            "-                DataSource dataSource = dh.getDataSource();\n", 
            "-                //Ask the data source to stream, if it has not already cached the request\n", 
            "-                if (!preserve && dataSource instanceof StreamingOnRequestDataSource) {\n", 
            "-                    ((StreamingOnRequestDataSource) dataSource).setLastUse(true);\n", 
            "-                }\n", 
            "-                dh.writeTo(out);\n", 
            "-            }\n", 
            "-        } catch (OMException e) {\n", 
            "-            log.error(e);\n", 
            "-            throw AxisFault.makeFault(e);\n", 
            "-        } catch (IOException e) {\n", 
            "-            log.error(e);\n", 
            "-            throw AxisFault.makeFault(e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private static String getMessageFormatterProperty(MessageContext msgContext) {\n", 
            "-        String messageFormatterProperty = null;\n", 
            "-        Object property = msgContext\n", 
            "-                .getProperty(Constants.Configuration.MESSAGE_TYPE);\n", 
            "-        if (property != null) {\n", 
            "-            messageFormatterProperty = (String) property;\n", 
            "-        }\n", 
            "-        if (messageFormatterProperty == null) {\n", 
            "-            Parameter parameter = msgContext\n", 
            "-                    .getParameter(Constants.Configuration.MESSAGE_TYPE);\n", 
            "-            if (parameter != null) {\n", 
            "-                messageFormatterProperty = (String) parameter.getValue();\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return messageFormatterProperty;\n", 
            "-    }\n", 
            "-\n", 
            "-    private static MessageFormatter getMessageFormatter(MessageContext messageContext) {\n", 
            "-\n", 
            "-        Object o = messageContext.getProperty(DeferredMessageBuilder.RELAY_FORMATTERS_MAP);\n", 
            "-        if (o != null && o instanceof Map) {\n", 
            "-            Map map = (Map) o;\n", 
            "-            String messageFormatString =\n", 
            "-                    getMessageFormatterProperty(messageContext);\n", 
            "-            if (messageFormatString != null) {\n", 
            "-                return (MessageFormatter)\n", 
            "-                        map.get(messageFormatString);\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/core/relay/ExpandingMessageFormatter.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/core/relay/ExpandingMessageFormatter.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,81 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.core.relay;\n", 
            "-\n", 
            "-import org.apache.axiom.om.*;\n", 
            "-import org.apache.axiom.soap.SOAPEnvelope;\n", 
            "-import org.apache.axiom.soap.SOAPFactory;\n", 
            "-import org.apache.axiom.soap.SOAPProcessingException;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.Constants;\n", 
            "-import org.apache.axis2.builder.Builder;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-\n", 
            "-import javax.activation.DataHandler;\n", 
            "-import java.io.ByteArrayOutputStream;\n", 
            "-import java.io.IOException;\n", 
            "-import java.io.InputStream;\n", 
            "-\n", 
            "-\n", 
            "-public class BinaryRelayBuilder implements Builder {\n", 
            "-\n", 
            "-    public static byte[] readAllFromInputSteam(InputStream in) throws IOException {\n", 
            "-        ByteArrayOutputStream out = new ByteArrayOutputStream();\n", 
            "-        byte[] buf = new byte[1024];\n", 
            "-        int read = in.read(buf);\n", 
            "-\n", 
            "-        while (read != -1) {\n", 
            "-            out.write(buf, 0, read);\n", 
            "-            read = in.read(buf);\n", 
            "-        }\n", 
            "-        return out.toByteArray();\n", 
            "-    }\n", 
            "-\n", 
            "-\n", 
            "-    public OMElement processDocument(InputStream inputStream,\n", 
            "-                                     String contentType, MessageContext messageContext) throws AxisFault {\n", 
            "-        try {\n", 
            "-            //Fix for https://wso2.org/jira/browse/CARBON-7256\n", 
            "-            messageContext.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);\n", 
            "-\n", 
            "-            //We will create a SOAP message, which holds the input message as a blob\n", 
            "-            SOAPFactory factory = OMAbstractFactory.getSOAP12Factory();\n", 
            "-            SOAPEnvelope env = factory.getDefaultEnvelope();\n", 
            "-            if (inputStream != null) {\n", 
            "-                OMNamespace ns = factory.createOMNamespace(\n", 
            "-                        RelayConstants.BINARY_CONTENT_QNAME.getNamespaceURI(), \"ns\");\n", 
            "-                OMElement omEle = factory.createOMElement(\n", 
            "-                        RelayConstants.BINARY_CONTENT_QNAME.getLocalPart(), ns);\n", 
            "-\n", 
            "-                StreamingOnRequestDataSource ds = new StreamingOnRequestDataSource(inputStream);\n", 
            "-                DataHandler dataHandler = new DataHandler(ds);\n", 
            "-\n", 
            "-                //create an OMText node with the above DataHandler and set optimized to true\n", 
            "-                OMText textData = factory.createOMText(dataHandler, true);\n", 
            "-                omEle.addChild(textData);\n", 
            "-                env.getBody().addChild(omEle);\n", 
            "-            }\n", 
            "-\n", 
            "-            return env;\n", 
            "-        } catch (SOAPProcessingException e) {\n", 
            "-            throw AxisFault.makeFault(e);\n", 
            "-        } catch (OMException e) {\n", 
            "-            throw AxisFault.makeFault(e);\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/core/relay/BinaryRelayBuilder.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/core/relay/BinaryRelayBuilder.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,49 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.core.relay;\n", 
            "-\n", 
            "-import javax.xml.namespace.QName;\n", 
            "-\n", 
            "-public final class RelayConstants {\n", 
            "-\n", 
            "-    public static final String RELAY_POLICY_NS =\n", 
            "-            \"http://synapse.apache.org/ns/2013/07/message-relay\";\n", 
            "-\n", 
            "-    public static final String INCLUDE_HIDDEN_SERVICES = \"includeHiddenServices\";\n", 
            "-\n", 
            "-    public static final QName RELAY_ASSERTION_QNAME = new QName(RELAY_POLICY_NS, \"RelayAssertion\");\n", 
            "-\n", 
            "-    public static final QName INCLUDE_HIDDEN_SERVICES_QNAME =\n", 
            "-            new QName(RELAY_POLICY_NS, INCLUDE_HIDDEN_SERVICES);\n", 
            "-\n", 
            "-    public static final QName SERVICES_QNAME = new QName(RELAY_POLICY_NS, \"services\");\n", 
            "-    public static final QName SERVICE_QNAME = new QName(RELAY_POLICY_NS, \"service\");\n", 
            "-\n", 
            "-    public static final QName BUILDERS_QNAME = new QName(RELAY_POLICY_NS, \"builders\");\n", 
            "-    public static final QName MESSAGE_BUILDER_QNAME = new QName(RELAY_POLICY_NS, \"messageBuilder\");\n", 
            "-    public static final QName CONTENT_TYPE_QNAME = new QName(\"contentType\");\n", 
            "-    public static final QName CLASS_NAME_QNAME = new QName(\"class\");\n", 
            "-\n", 
            "-    public static final QName FORMATTER_CLASS_NAME_QNAME = new QName(\"class\");\n", 
            "-\n", 
            "-    public static final String RELAY_CONFIG_PARAM = \"__relay_configuration__\";\n", 
            "-\n", 
            "-    public static final QName BINARY_CONTENT_QNAME =\n", 
            "-            new QName(\"http://ws.apache.org/commons/ns/payload\", \"binary\");\n", 
            "-\n", 
            "-    public static final String FORCE_RESPONSE_EARLY_BUILD = \"FORCE_RESPONSE_EARLY_BUILD\";\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/core/relay/RelayConstants.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/core/relay/RelayConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,82 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.core.relay;\n", 
            "-\n", 
            "-import org.apache.axiom.attachments.ByteArrayDataSource;\n", 
            "-\n", 
            "-import javax.activation.DataSource;\n", 
            "-import java.io.IOException;\n", 
            "-import java.io.InputStream;\n", 
            "-import java.io.OutputStream;\n", 
            "-\n", 
            "-/**\n", 
            "- * This class has a special flag, which says this is it's last use and not to cache data\n", 
            "- * if it did not have done so already.\n", 
            "- */\n", 
            "-public class StreamingOnRequestDataSource implements DataSource {\n", 
            "-    private InputStream in;\n", 
            "-\n", 
            "-    public StreamingOnRequestDataSource(InputStream in) {\n", 
            "-        super();\n", 
            "-        this.in = in;\n", 
            "-    }\n", 
            "-\n", 
            "-    private boolean lastUse = false;\n", 
            "-\n", 
            "-    private ByteArrayDataSource cachedData = null;\n", 
            "-\n", 
            "-    public String getContentType() {\n", 
            "-        return \"application/octet-stream\";\n", 
            "-    }\n", 
            "-\n", 
            "-    public InputStream getInputStream() throws IOException {\n", 
            "-        if (cachedData != null) {\n", 
            "-            return cachedData.getInputStream();\n", 
            "-        } else {\n", 
            "-            if (lastUse && in != null) {\n", 
            "-                InputStream returnStream = in;\n", 
            "-                this.in = null;\n", 
            "-                return returnStream;\n", 
            "-            } else if (in != null) {\n", 
            "-                byte[] data = BinaryRelayBuilder.readAllFromInputSteam(in);\n", 
            "-                cachedData = new ByteArrayDataSource(data);\n", 
            "-                return cachedData.getInputStream();\n", 
            "-            } else {\n", 
            "-                throw new IOException(\"Input stream has being already consumed\");\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    public String getName() {\n", 
            "-        return \"StreamingOnRequestDataSource\";\n", 
            "-    }\n", 
            "-\n", 
            "-    public OutputStream getOutputStream() throws IOException {\n", 
            "-        throw new UnsupportedOperationException();\n", 
            "-    }\n", 
            "-\n", 
            "-    /**\n", 
            "-     * This flag says that this is the last use of the stream, hence do not\n", 
            "-     * need to cache it if it has not\n", 
            "-     * already cached.\n", 
            "-     *\n", 
            "-     * @param lastUse\n", 
            "-     */\n", 
            "-    public void setLastUse(boolean lastUse) {\n", 
            "-        this.lastUse = lastUse;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/core/relay/StreamingOnRequestDataSource.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/core/relay/StreamingOnRequestDataSource.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,205 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.core.relay;\n", 
            "-\n", 
            "-import org.apache.axiom.om.OMElement;\n", 
            "-import org.apache.axiom.soap.SOAPEnvelope;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.builder.*;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.transport.MessageFormatter;\n", 
            "-import org.apache.axis2.transport.http.ApplicationXMLFormatter;\n", 
            "-import org.apache.axis2.transport.http.MultipartFormDataFormatter;\n", 
            "-import org.apache.axis2.transport.http.SOAPMessageFormatter;\n", 
            "-import org.apache.axis2.transport.http.XFormURLEncodedFormatter;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            "-\n", 
            "-import javax.xml.stream.XMLStreamException;\n", 
            "-import java.io.InputStream;\n", 
            "-import java.util.HashMap;\n", 
            "-import java.util.Iterator;\n", 
            "-import java.util.Map;\n", 
            "-\n", 
            "-public class DeferredMessageBuilder {\n", 
            "-\n", 
            "-    private static Log log = LogFactory.getLog(DeferredMessageBuilder.class);\n", 
            "-\n", 
            "-    private Map<String, Builder> builders = new HashMap<String, Builder>();\n", 
            "-    private Map<String, MessageFormatter> formatters = new HashMap<String, MessageFormatter>();\n", 
            "-\n", 
            "-    public final static String RELAY_FORMATTERS_MAP = \"__RELAY_FORMATTERS_MAP\";\n", 
            "-    public final static String FORCED_RELAY_FORMATTER = \"__FORCED_RELAY_FORMATTER\";\n", 
            "-\n", 
            "-    public DeferredMessageBuilder() {\n", 
            "-        // first initialize with the default builders\n", 
            "-        builders.put(\"multipart/related\", new MIMEBuilder());\n", 
            "-        builders.put(\"application/soapxml\", new SOAPBuilder());\n", 
            "-        builders.put(\"text/xml\", new SOAPBuilder());\n", 
            "-        builders.put(\"application/xopxml\", new MTOMBuilder());\n", 
            "-        builders.put(\"application/xml\", new ApplicationXMLBuilder());\n", 
            "-        builders.put(\"application/x-www-form-urlencoded\",\n", 
            "-                new XFormURLEncodedBuilder());\n", 
            "-\n", 
            "-        // initialize the default formatters\n", 
            "-        formatters.put(\"application/x-www-form-urlencoded\", new XFormURLEncodedFormatter());\n", 
            "-        formatters.put(\"multipart/form-data\", new MultipartFormDataFormatter());\n", 
            "-        formatters.put(\"application/xml\", new ApplicationXMLFormatter());\n", 
            "-        formatters.put(\"text/xml\", new SOAPMessageFormatter());\n", 
            "-        formatters.put(\"application/soapxml\", new SOAPMessageFormatter());\n", 
            "-    }\n", 
            "-\n", 
            "-    public Map<String, Builder> getBuilders() {\n", 
            "-        return builders;\n", 
            "-    }\n", 
            "-\n", 
            "-    public void addBuilder(String contentType, Builder builder) {\n", 
            "-        builders.put(contentType, builder);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void addFormatter(String contentType, MessageFormatter messageFormatter) {\n", 
            "-        formatters.put(contentType, messageFormatter);\n", 
            "-    }\n", 
            "-\n", 
            "-    public Map<String, MessageFormatter> getFormatters() {\n", 
            "-        return formatters;\n", 
            "-    }\n", 
            "-\n", 
            "-    public OMElement getDocument(String contentType, MessageContext msgCtx, InputStream in) throws\n", 
            "-            XMLStreamException, AxisFault {\n", 
            "-        OMElement element = null;\n", 
            "-        Builder builder;\n", 
            "-        if (contentType != null) {\n", 
            "-            // try to get a builder from existing builders\n", 
            "-            builder = getBuilderForContentType(contentType);\n", 
            "-            if (builder != null) {\n", 
            "-                try {\n", 
            "-                    /*try {\n", 
            "-                        throw new Exception(\"Building message\");\n", 
            "-                    } catch (Exception e) {\n", 
            "-                        e.printStackTrace();\n", 
            "-                    }*/\n", 
            "-                    element = builder.processDocument(in, contentType, msgCtx);\n", 
            "-                } catch (AxisFault axisFault) {\n", 
            "-                    log.error(\"Error building message\", axisFault);\n", 
            "-                    throw axisFault;\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        if (element == null) {\n", 
            "-            if (msgCtx.isDoingREST()) {\n", 
            "-                try {\n", 
            "-                    element = BuilderUtil.getPOXBuilder(in, null).getDocumentElement();\n", 
            "-                } catch (XMLStreamException e) {\n", 
            "-                    log.error(\"Error building message using POX Builder\", e);\n", 
            "-                    throw e;\n", 
            "-                }\n", 
            "-            } else {\n", 
            "-                // switch to default\n", 
            "-                builder = new SOAPBuilder();\n", 
            "-                try {\n", 
            "-                    element = builder.processDocument(in, contentType, msgCtx);\n", 
            "-                } catch (AxisFault axisFault) {\n", 
            "-                    log.error(\"Error building message using SOAP builder\");\n", 
            "-                    throw axisFault;\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        // build the soap headers and body\n", 
            "-        if (element instanceof SOAPEnvelope) {\n", 
            "-            SOAPEnvelope env = (SOAPEnvelope) element;\n", 
            "-            env.hasFault();\n", 
            "-        }\n", 
            "-\n", 
            "-        return element;\n", 
            "-    }\n", 
            "-\n", 
            "-    private Builder getBuilderForContentType(String contentType) {\n", 
            "-        String type;\n", 
            "-        int index = contentType.indexOf(';');\n", 
            "-        if (index > 0) {\n", 
            "-            type = contentType.substring(0, index);\n", 
            "-        } else {\n", 
            "-            type = contentType;\n", 
            "-        }\n", 
            "-\n", 
            "-        Builder builder = builders.get(type);\n", 
            "-\n", 
            "-        if (builder == null) {\n", 
            "-            builder = builders.get(type.toLowerCase());\n", 
            "-        }\n", 
            "-\n", 
            "-        if (builder == null) {\n", 
            "-            Iterator<Map.Entry<String, Builder>> iterator = builders.entrySet().iterator();\n", 
            "-            while (iterator.hasNext() && builder == null) {\n", 
            "-                Map.Entry<String, Builder> entry = iterator.next();\n", 
            "-                String key = entry.getKey();\n", 
            "-                if (contentType.matches(key)) {\n", 
            "-                    builder = entry.getValue();\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return builder;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static Builder createBuilder(String className) throws AxisFault {\n", 
            "-        try {\n", 
            "-            Class c = Class.forName(className);\n", 
            "-            Object o = c.newInstance();\n", 
            "-            if (o instanceof Builder) {\n", 
            "-                return (Builder) o;\n", 
            "-            }\n", 
            "-        } catch (ClassNotFoundException e) {\n", 
            "-            handleException(\"Builder class not found :\" +\n", 
            "-                    className, e);\n", 
            "-        } catch (IllegalAccessException e) {\n", 
            "-            handleException(\"Cannot initiate Builder class :\" +\n", 
            "-                    className, e);\n", 
            "-        } catch (InstantiationException e) {\n", 
            "-            handleException(\"Cannot initiate Builder class :\" +\n", 
            "-                    className, e);\n", 
            "-        }\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static MessageFormatter createFormatter(String className) throws AxisFault {\n", 
            "-        try {\n", 
            "-            Class c = Class.forName(className);\n", 
            "-            Object o = c.newInstance();\n", 
            "-            if (o instanceof MessageFormatter) {\n", 
            "-                return (MessageFormatter) o;\n", 
            "-            }\n", 
            "-        } catch (ClassNotFoundException e) {\n", 
            "-            handleException(\"MessageFormatter class not found :\" +\n", 
            "-                    className, e);\n", 
            "-        } catch (IllegalAccessException e) {\n", 
            "-            handleException(\"Cannot initiate MessageFormatter class :\" +\n", 
            "-                    className, e);\n", 
            "-        } catch (InstantiationException e) {\n", 
            "-            handleException(\"Cannot initiate MessageFormatter class :\" +\n", 
            "-                    className, e);\n", 
            "-        }\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    private static void handleException(String message, Exception e) throws AxisFault {\n", 
            "-        log.error(message, e);\n", 
            "-        throw new AxisFault(message, e);\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/core/relay/DeferredMessageBuilder.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/core/relay/DeferredMessageBuilder.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,209 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.core.relay;\n", 
            "-\n", 
            "-import org.apache.axiom.om.OMElement;\n", 
            "-import org.apache.axiom.om.OMNode;\n", 
            "-import org.apache.axiom.om.OMText;\n", 
            "-import org.apache.axiom.soap.SOAPEnvelope;\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.Constants;\n", 
            "-import org.apache.axis2.addressing.AddressingConstants;\n", 
            "-import org.apache.axis2.addressing.AddressingHelper;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.description.WSDL2Constants;\n", 
            "-import org.apache.axis2.engine.AxisConfiguration;\n", 
            "-import org.apache.axis2.engine.Handler;\n", 
            "-import org.apache.axis2.engine.Phase;\n", 
            "-import org.apache.axis2.transport.RequestResponseTransport;\n", 
            "-import org.apache.axis2.transport.TransportUtils;\n", 
            "-import org.apache.axis2.wsdl.WSDLConstants;\n", 
            "-import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            "-import org.apache.synapse.transport.passthru.PassThroughConstants;\n", 
            "-import org.apache.synapse.transport.passthru.Pipe;\n", 
            "-\n", 
            "-import javax.activation.DataHandler;\n", 
            "-import javax.activation.DataSource;\n", 
            "-import javax.xml.stream.XMLStreamException;\n", 
            "-import java.io.IOException;\n", 
            "-import java.io.InputStream;\n", 
            "-import java.util.List;\n", 
            "-\n", 
            "-public class RelayUtils {\n", 
            "-\n", 
            "-    private static final DeferredMessageBuilder messageBuilder = new DeferredMessageBuilder();\n", 
            "-\n", 
            "-    private static volatile Handler addressingInHandler = null;\n", 
            "-    private static boolean noAddressingHandler = false;\n", 
            "-\n", 
            "-    public static void buildMessage(org.apache.synapse.MessageContext msgCtx) throws IOException,\n", 
            "-            XMLStreamException {\n", 
            "-\n", 
            "-        org.apache.axis2.context.MessageContext messageContext =\n", 
            "-                ((Axis2MessageContext) msgCtx).getAxis2MessageContext();\n", 
            "-        buildMessage(messageContext, false);\n", 
            "-    }\n", 
            "-\n", 
            "-    public static void buildMessage(MessageContext messageContext, boolean earlyBuild) throws IOException,\n", 
            "-            XMLStreamException {\n", 
            "-\n", 
            "-        final Pipe pipe = (Pipe) messageContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE);\n", 
            "-        if (pipe != null && !Boolean.TRUE.equals(messageContext.getProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED))) {\n", 
            "-            InputStream in = pipe.getInputStream();\n", 
            "-            String contentType = (String) messageContext.getProperty(\n", 
            "-                    Constants.Configuration.CONTENT_TYPE);\n", 
            "-            OMElement element = messageBuilder.getDocument(contentType, messageContext, in);\n", 
            "-            if (element != null) {\n", 
            "-                messageContext.setEnvelope(TransportUtils.createSOAPEnvelope(element));\n", 
            "-                messageContext.setProperty(DeferredMessageBuilder.RELAY_FORMATTERS_MAP,\n", 
            "-                        messageBuilder.getFormatters());\n", 
            "-                messageContext.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED,\n", 
            "-                        Boolean.TRUE);\n", 
            "-\n", 
            "-                if (!earlyBuild) {\n", 
            "-                    processAddressing(messageContext);\n", 
            "-                }\n", 
            "-            }\n", 
            "-            return;\n", 
            "-        }\n", 
            "-\n", 
            "-        SOAPEnvelope envelope = messageContext.getEnvelope();\n", 
            "-        OMElement contentEle = envelope.getBody().getFirstChildWithName(\n", 
            "-                RelayConstants.BINARY_CONTENT_QNAME);\n", 
            "-\n", 
            "-        if (contentEle != null) {\n", 
            "-            OMNode node = contentEle.getFirstOMChild();\n", 
            "-\n", 
            "-            if (node != null && (node instanceof OMText)) {\n", 
            "-                OMText binaryDataNode = (OMText) node;\n", 
            "-                DataHandler dh = (DataHandler) binaryDataNode.getDataHandler();\n", 
            "-                if (dh == null) {\n", 
            "-                    throw new AxisFault(\"Error while building message\");\n", 
            "-                }\n", 
            "-\n", 
            "-                DataSource dataSource = dh.getDataSource();\n", 
            "-                //Ask the data source to stream, if it has not already cached the request\n", 
            "-                if (dataSource instanceof StreamingOnRequestDataSource) {\n", 
            "-                    ((StreamingOnRequestDataSource) dataSource).setLastUse(true);\n", 
            "-                }\n", 
            "-\n", 
            "-                InputStream in = dh.getInputStream();\n", 
            "-                String contentType = (String) messageContext.getProperty(\n", 
            "-                        Constants.Configuration.CONTENT_TYPE);\n", 
            "-\n", 
            "-                OMElement element = messageBuilder.getDocument(contentType, messageContext, in);\n", 
            "-                if (element != null) {\n", 
            "-                    messageContext.setEnvelope(TransportUtils.createSOAPEnvelope(element));\n", 
            "-                    messageContext.setProperty(DeferredMessageBuilder.RELAY_FORMATTERS_MAP,\n", 
            "-                            messageBuilder.getFormatters());\n", 
            "-\n", 
            "-                    if (!earlyBuild) {\n", 
            "-                        processAddressing(messageContext);\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private static void processAddressing(MessageContext messageContext) throws AxisFault {\n", 
            "-        if (noAddressingHandler) {\n", 
            "-            return;\n", 
            "-        } else if (addressingInHandler == null) {\n", 
            "-            synchronized (messageBuilder) {\n", 
            "-                if (addressingInHandler == null) {\n", 
            "-                    AxisConfiguration axisConfig = messageContext.getConfigurationContext().\n", 
            "-                            getAxisConfiguration();\n", 
            "-                    List<Phase> phases = axisConfig.getInFlowPhases();\n", 
            "-                    boolean handlerFound = false;\n", 
            "-                    for (Phase phase : phases) {\n", 
            "-                        if (\"Addressing\".equals(phase.getName())) {\n", 
            "-                            List<Handler> handlers = phase.getHandlers();\n", 
            "-                            for (Handler handler : handlers) {\n", 
            "-                                if (\"AddressingInHandler\".equals(handler.getName())) {\n", 
            "-                                    addressingInHandler = handler;\n", 
            "-                                    handlerFound = true;\n", 
            "-                                    break;\n", 
            "-                                }\n", 
            "-                            }\n", 
            "-                            break;\n", 
            "-                        }\n", 
            "-                    }\n", 
            "-\n", 
            "-                    if (!handlerFound) {\n", 
            "-                        noAddressingHandler = true;\n", 
            "-                        return;\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        messageContext.setProperty(AddressingConstants.DISABLE_ADDRESSING_FOR_IN_MESSAGES, \"false\");\n", 
            "-        addressingInHandler.invoke(messageContext);\n", 
            "-\n", 
            "-        if (messageContext.getAxisOperation() == null) {\n", 
            "-            return;\n", 
            "-        }\n", 
            "-\n", 
            "-        String mepString = messageContext.getAxisOperation().getMessageExchangePattern();\n", 
            "-\n", 
            "-        if (isOneWay(mepString)) {\n", 
            "-            Object requestResponseTransport = messageContext.getProperty(RequestResponseTransport.TRANSPORT_CONTROL);\n", 
            "-            if (requestResponseTransport != null) {\n", 
            "-\n", 
            "-                Boolean disableAck = getDisableAck(messageContext);\n", 
            "-                if (disableAck == null || disableAck.booleanValue() == false) {\n", 
            "-                    ((RequestResponseTransport) requestResponseTransport).acknowledgeMessage(messageContext);\n", 
            "-                }\n", 
            "-            }\n", 
            "-        } else if (AddressingHelper.isReplyRedirected(messageContext) && AddressingHelper.isFaultRedirected(messageContext)) {\n", 
            "-            if (mepString.equals(WSDL2Constants.MEP_URI_IN_OUT)\n", 
            "-                    || mepString.equals(WSDL2Constants.MEP_URI_IN_OUT)) {\n", 
            "-                // OR, if 2 way operation but the response is intended to not use the response channel of a 2-way transport\n", 
            "-                // then we don't need to keep the transport waiting.\n", 
            "-\n", 
            "-                Object requestResponseTransport = messageContext.getProperty(RequestResponseTransport.TRANSPORT_CONTROL);\n", 
            "-                if (requestResponseTransport != null) {\n", 
            "-\n", 
            "-                    // We should send an early ack to the transport whenever possible, but some modules need\n", 
            "-                    // to use the back channel, so we need to check if they have disabled this code.\n", 
            "-                    Boolean disableAck = getDisableAck(messageContext);\n", 
            "-\n", 
            "-                    if (disableAck == null || disableAck.booleanValue() == false) {\n", 
            "-                        ((RequestResponseTransport) requestResponseTransport).acknowledgeMessage(messageContext);\n", 
            "-                    }\n", 
            "-\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-    }\n", 
            "-\n", 
            "-    private static Boolean getDisableAck(MessageContext msgContext) throws AxisFault {\n", 
            "-        // We should send an early ack to the transport whenever possible, but some modules need\n", 
            "-        // to use the back channel, so we need to check if they have disabled this code.\n", 
            "-        Boolean disableAck = (Boolean) msgContext.getProperty(Constants.Configuration.DISABLE_RESPONSE_ACK);\n", 
            "-        if (disableAck == null) {\n", 
            "-            disableAck = (Boolean) (msgContext.getAxisService() != null ? msgContext.getAxisService().getParameterValue(Constants.Configuration.DISABLE_RESPONSE_ACK) : null);\n", 
            "-        }\n", 
            "-\n", 
            "-        return disableAck;\n", 
            "-    }\n", 
            "-\n", 
            "-    private static boolean isOneWay(String mepString) {\n", 
            "-        return mepString.equals(WSDL2Constants.MEP_URI_IN_ONLY)\n", 
            "-                || mepString.equals(WSDL2Constants.MEP_URI_IN_ONLY);\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/core/relay/RelayUtils.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/core/relay/RelayUtils.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,115 +0,0", 
          "lines": [
            "-/*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "-\n", 
            "-package org.apache.synapse.core.relay;\n", 
            "-\n", 
            "-import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.context.OperationContext;\n", 
            "-import org.apache.axis2.description.AxisOperation;\n", 
            "-import org.apache.axis2.description.AxisService;\n", 
            "-import org.apache.axis2.engine.AxisConfiguration;\n", 
            "-import org.apache.axis2.handlers.AbstractHandler;\n", 
            "-import org.apache.axis2.wsdl.WSDLConstants;\n", 
            "-import org.apache.sandesha2.Sandesha2Constants;\n", 
            "-import org.apache.synapse.SynapseConstants;\n", 
            "-import org.apache.synapse.config.SynapseConfiguration;\n", 
            "-import org.apache.synapse.core.axis2.ProxyService;\n", 
            "-\n", 
            "-import javax.xml.stream.XMLStreamException;\n", 
            "-import java.io.IOException;\n", 
            "-\n", 
            "-public class ServiceRequestEarlyBuilder extends AbstractHandler {\n", 
            "-\n", 
            "-    public InvocationResponse invoke(MessageContext messageContext) throws AxisFault {\n", 
            "-        OperationContext operationContext = messageContext.getOperationContext();\n", 
            "-        if (operationContext == null) {\n", 
            "-            AxisService service = messageContext.getAxisService();\n", 
            "-            if (service != null) {\n", 
            "-                if (\"__ADDR_ONLY__\".equals(service.getName())) {\n", 
            "-                    // handling dual channel invocations\n", 
            "-                    return buildMessage(messageContext);\n", 
            "-                }\n", 
            "-\n", 
            "-                // Possible service mediation mode\n", 
            "-                AxisConfiguration axisConfiguration = messageContext.getConfigurationContext().\n", 
            "-                        getAxisConfiguration();\n", 
            "-                SynapseConfiguration synapseConfig = (SynapseConfiguration) axisConfiguration.getParameterValue(\n", 
            "-                        SynapseConstants.SYNAPSE_CONFIG);\n", 
            "-                ProxyService proxy = synapseConfig.getProxyService(service.getName());\n", 
            "-                if (proxy != null) {\n", 
            "-                    AxisOperation operation = messageContext.getAxisOperation();\n", 
            "-                    if (proxy.isModuleEngaged() || (operation == null && proxy.isWsdlPublished())) {\n", 
            "-                        // We have some Axis2 level processing to do (security, RM, addressing etc)\n", 
            "-                        // or we have more dispatching left to do\n", 
            "-                        return buildMessage(messageContext);\n", 
            "-                    } else if (operation == null && !proxy.isWsdlPublished()) {\n", 
            "-                        operation = service.getOperation(SynapseConstants.SYNAPSE_OPERATION_NAME);\n", 
            "-                    }\n", 
            "-\n", 
            "-                    if (operation != null) {\n", 
            "-                        return invokeMessageReceiver(messageContext, operation);\n", 
            "-                    }\n", 
            "-                }\n", 
            "-            } else {\n", 
            "-                // Message mediation mode\n", 
            "-                service = messageContext.getConfigurationContext().\n", 
            "-                        getAxisConfiguration().getService(SynapseConstants.SYNAPSE_SERVICE_NAME);\n", 
            "-                messageContext.setAxisService(service);\n", 
            "-                AxisOperation operation = service.getOperation(SynapseConstants.SYNAPSE_OPERATION_NAME);\n", 
            "-                messageContext.setAxisOperation(operation);\n", 
            "-                return invokeMessageReceiver(messageContext, operation);\n", 
            "-            }\n", 
            "-        } else {\n", 
            "-            MessageContext outMessage = operationContext.getMessageContext(\n", 
            "-                    WSDLConstants.MESSAGE_LABEL_OUT_VALUE);\n", 
            "-            if (outMessage != null && Boolean.TRUE.equals(\n", 
            "-                    outMessage.getProperty(RelayConstants.FORCE_RESPONSE_EARLY_BUILD))) {\n", 
            "-                return buildMessage(messageContext);\n", 
            "-            }\n", 
            "-\n", 
            "-            AxisOperation operation = messageContext.getAxisOperation();\n", 
            "-            if (operation != null && operation.getName().getLocalPart().\n", 
            "-                    startsWith(Sandesha2Constants.SANDESHA_OP_PREFIX)) {\n", 
            "-                return buildMessage(messageContext);\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        return InvocationResponse.CONTINUE;\n", 
            "-    }\n", 
            "-\n", 
            "-    private InvocationResponse invokeMessageReceiver(MessageContext messageContext,\n", 
            "-                                                     AxisOperation operation) throws AxisFault {\n", 
            "-        messageContext.getConfigurationContext().\n", 
            "-                fillServiceContextAndServiceGroupContext(messageContext);\n", 
            "-        OperationContext opContext = operation.findOperationContext(messageContext,\n", 
            "-                messageContext.getServiceContext());\n", 
            "-        messageContext.setOperationContext(opContext);\n", 
            "-        operation.getMessageReceiver().receive(messageContext);\n", 
            "-        return InvocationResponse.ABORT;\n", 
            "-    }\n", 
            "-\n", 
            "-    private InvocationResponse buildMessage(MessageContext messageContext) throws AxisFault {\n", 
            "-        try {\n", 
            "-            RelayUtils.buildMessage(messageContext, true);\n", 
            "-        } catch (IOException e) {\n", 
            "-            throw new AxisFault(\"I/O error while reading from the input stream\");\n", 
            "-        } catch (XMLStreamException e) {\n", 
            "-            throw new AxisFault(\"Unexpected error while parsing the XML content\");\n", 
            "-        }\n", 
            "-        return InvocationResponse.CONTINUE;\n", 
            "-    }\n", 
            "-}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/core/relay/ServiceRequestEarlyBuilder.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/core/relay/ServiceRequestEarlyBuilder.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,596 +0,0", 
          "lines": [
            "-<!--\n", 
            "-  ~  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "-  ~  or more contributor license agreements.  See the NOTICE file\n", 
            "-  ~  distributed with this work for additional information\n", 
            "-  ~  regarding copyright ownership.  The ASF licenses this file\n", 
            "-  ~  to you under the Apache License, Version 2.0 (the\n", 
            "-  ~  \"License\"); you may not use this file except in compliance\n", 
            "-  ~  with the License.  You may obtain a copy of the License at\n", 
            "-  ~\n", 
            "-  ~   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-  ~\n", 
            "-  ~  Unless required by applicable law or agreed to in writing,\n", 
            "-  ~  software distributed under the License is distributed on an\n", 
            "-  ~ \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-  ~  KIND, either express or implied.  See the License for the\n", 
            "-  ~  specific language governing permissions and limitations\n", 
            "-  ~  under the License.\n", 
            "-  -->\n", 
            "-\n", 
            "-<axisconfig name=\"AxisJava2.0\">\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!-- Parameters -->\n", 
            "-    <!-- ================================================= -->\n", 
            "-\n", 
            "-    <!-- WARNING: Hot deployment is turned on by default, but it is highly recommended to set this to false\n", 
            "-on production environments, unless you really want to use hot deployment in production -->\n", 
            "-    <parameter name=\"hotdeployment\">true</parameter>\n", 
            "-    <parameter name=\"hotupdate\">true</parameter>\n", 
            "-    <parameter name=\"enableMTOM\">false</parameter>\n", 
            "-    <parameter name=\"enableSwA\">false</parameter>\n", 
            "-\n", 
            "-    <!--Uncomment if you want to enable file caching for attachments -->\n", 
            "-    <!--parameter name=\"cacheAttachments\">true</parameter>\n", 
            "-   <parameter name=\"attachmentDIR\"></parameter>\n", 
            "-   <parameter name=\"sizeThreshold\">4000</parameter-->\n", 
            "-\n", 
            "-    <!--This will give out the timout of the configuration contexts, in milliseconds-->\n", 
            "-    <parameter name=\"ConfigContextTimeoutInterval\">30000</parameter>\n", 
            "-\n", 
            "-    <!--During a fault, stacktrace can be sent with the fault message. The following flag will control -->\n", 
            "-    <!--that behavior.-->\n", 
            "-    <parameter name=\"sendStacktraceDetailsWithFaults\">false</parameter>\n", 
            "-\n", 
            "-    <!--If there aren't any information available to find out the fault reason, we set the message of the exception-->\n", 
            "-    <!--as the faultreason/Reason. But when a fault is thrown from a service or some where, it will be -->\n", 
            "-    <!--wrapped by different levels. Due to this the initial exception message can be lost. If this flag-->\n", 
            "-    <!--is set, then Axis2 tries to get the first exception and set its message as the faultreason/Reason.-->\n", 
            "-    <parameter name=\"DrillDownToRootCauseForFaultReason\">false</parameter>\n", 
            "-\n", 
            "-    <parameter name=\"userName\">admin</parameter>\n", 
            "-    <parameter name=\"password\">axis2</parameter>\n", 
            "-\n", 
            "-    <!--To override repository/services you need to uncomment following parameter and value SHOULD be absolute file path.-->\n", 
            "-    <!--ServicesDirectory only works on the following cases-->\n", 
            "-    <!---File based configurator and in that case the value should be a file URL (http:// not allowed)-->\n", 
            "-    <!---When creating URL Based configurator with URL \"file://\"  -->\n", 
            "-    <!--- War based configurator with expanded case , -->\n", 
            "-\n", 
            "-    <!--All the other scenarios it will be ignored.-->\n", 
            "-    <!--<parameter name=\"ServicesDirectory\">service</parameter>-->\n", 
            "-    <!--To override repository/modules you need to uncomment following parameter and value SHOULD be absolute file path-->\n", 
            "-    <!--<parameter name=\"ModulesDirectory\">modules</parameter>-->\n", 
            "-\n", 
            "-\n", 
            "-    <!--Following params will set the proper context paths for invocations. All the endpoints will have a commons context-->\n", 
            "-    <!--root which can configured using the following contextRoot parameter-->\n", 
            "-    <parameter name=\"contextRoot\">/</parameter>\n", 
            "-\n", 
            "-    <!--Our HTTP endpoints can handle both REST and SOAP. Following parameters can be used to distinguiush those endpoints-->\n", 
            "-    <!--In case of a servlet, if you change this you have to manually change the settings of your servlet container to map this -->\n", 
            "-    <!--context path to proper Axis2 servlets-->\n", 
            "-    <parameter name=\"servicePath\">services</parameter>\n", 
            "-    <parameter name=\"restPath\">rest</parameter>\n", 
            "-\n", 
            "-    <!-- Following parameter will completely disable REST handling in Axis2-->\n", 
            "-    <parameter name=\"disableREST\" locked=\"true\">false</parameter>\n", 
            "-\n", 
            "-    <!-- Extension deployer\n", 
            "-***** Uncomment the following line to enable (hot) deployment of Synapse extensions (mediators and startups) ***** -->\n", 
            "-    <!--<deployer extension=\"xar\" directory=\"extensions\" class=\"org.apache.synapse.deployers.ExtensionDeployer\"/>-->\n", 
            "-\n", 
            "-    <!-- WARNING: Synapse Artifact Deployers, it is highly recommended to comment out these deployers in production\n", 
            "-unless you really want to use hot deployment/update -->\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/sequences\"\n", 
            "-              class=\"org.apache.synapse.deployers.SequenceDeployer\"/>\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/endpoints\"\n", 
            "-              class=\"org.apache.synapse.deployers.EndpointDeployer\"/>\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/local-entries\"\n", 
            "-              class=\"org.apache.synapse.deployers.LocalEntryDeployer\"/>\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/proxy-services\"\n", 
            "-              class=\"org.apache.synapse.deployers.ProxyServiceDeployer\"/>\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/event-sources\"\n", 
            "-              class=\"org.apache.synapse.deployers.EventSourceDeployer\"/>\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/tasks\"\n", 
            "-              class=\"org.apache.synapse.deployers.TaskDeployer\"/>\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/priority-executors\"\n", 
            "-              class=\"org.apache.synapse.deployers.PriorityExecutorDeployer\"/>\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/templates\"\n", 
            "-              class=\"org.apache.synapse.deployers.TemplateDeployer\"/>\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/message-stores\"\n", 
            "-              class=\"org.apache.synapse.deployers.MessageStoreDeployer\"/>\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/message-processors\"\n", 
            "-              class=\"org.apache.synapse.deployers.MessageProcessorDeployer\"/>\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/api\"\n", 
            "-              class=\"org.apache.synapse.deployers.APIDeployer\"/>\n", 
            "-    <deployer extension=\"xml\" directory=\"conf/synapse-config/imports\"\n", 
            "-              class=\"org.apache.synapse.deployers.ImportDeployer\"/>\n", 
            "-    <deployer extension=\"zip\" directory=\"conf/synapse-libs\"\n", 
            "-              class=\"org.apache.synapse.deployers.LibraryArtifactDeployer\"/>\n", 
            "-\n", 
            "-    <!-- Following parameter will set the host name for the epr-->\n", 
            "-    <!--<parameter name=\"hostname\" locked=\"true\">myhost.com</parameter>-->\n", 
            "-\n", 
            "-    <!-- If you have a frontend host which exposes this webservice using a different public URL  -->\n", 
            "-    <!-- use this parameter to override autodetected url -->\n", 
            "-    <!--<parameter name=\"httpFrontendHostUrl\">https://someotherhost/context</parameter>-->\n", 
            "-\n", 
            "-\n", 
            "-    <!--    The way of adding listener to the system-->\n", 
            "-    <!--    <listener class=\"org.apache.axis2.ObserverIMPL\">-->\n", 
            "-    <!--        <parameter name=\"RSS_URL\">http://127.0.0.1/rss</parameter>-->\n", 
            "-    <!--    </listener>-->\n", 
            "-\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!-- Message Receivers -->\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!--This is the deafult MessageReceiver for the system , if you want to have MessageReceivers for -->\n", 
            "-    <!--all the other MEP implement it and add the correct entry to here , so that you can refer from-->\n", 
            "-    <!--any operation -->\n", 
            "-    <!--Note : You can ovrride this for a particular service by adding the same element with your requirement-->\n", 
            "-    <messageReceivers>\n", 
            "-        <messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-only\"\n", 
            "-                         class=\"org.apache.axis2.receivers.RawXMLINOnlyMessageReceiver\"/>\n", 
            "-        <messageReceiver mep=\"http://www.w3.org/2004/08/wsdl/in-out\"\n", 
            "-                         class=\"org.apache.axis2.receivers.RawXMLINOutMessageReceiver\"/>\n", 
            "-        <messageReceiver mep=\"http://www.w3.org/2006/01/wsdl/in-only\"\n", 
            "-                         class=\"org.apache.axis2.receivers.RawXMLINOnlyMessageReceiver\"/>\n", 
            "-        <messageReceiver mep=\"http://www.w3.org/2006/01/wsdl/in-out\"\n", 
            "-                         class=\"org.apache.axis2.receivers.RawXMLINOutMessageReceiver\"/>\n", 
            "-    </messageReceivers>\n", 
            "-\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!-- Message Formatter -->\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!--Following content type to message formatter mapping can be used to implement support for different message -->\n", 
            "-    <!--format  serialization in Axis2. These message formats are expected to be resolved based on the content type. -->\n", 
            "-    <messageFormatters>\n", 
            "-        <messageFormatter contentType=\"application/x-www-form-urlencoded\"\n", 
            "-                          class=\"org.apache.axis2.transport.http.XFormURLEncodedFormatter\"/>\n", 
            "-        <messageFormatter contentType=\"multipart/form-data\"\n", 
            "-                          class=\"org.apache.axis2.transport.http.MultipartFormDataFormatter\"/>\n", 
            "-        <messageFormatter contentType=\"application/xml\"\n", 
            "-                          class=\"org.apache.axis2.transport.http.ApplicationXMLFormatter\"/>\n", 
            "-        <!--<messageFormatter contentType=\"x-application/hessian\"\n", 
            "-        class=\"org.apache.synapse.format.hessian.HessianMessageFormatter\"/>-->\n", 
            "-        <!--<messageFormatter contentType=\"\"\n", 
            "-        class=\"org.apache.synapse.format.hessian.HessianMessageFormatter\"/>-->\n", 
            "-        <!--<messageFormatter contentType=\"application/json\"\n", 
            "-        class=\"org.apache.axis2.json.JSONMessageFormatter\"/>-->\n", 
            "-\n", 
            "-    </messageFormatters>\n", 
            "-\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!-- Message Builders -->\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!--Following content type to builder mapping can be used to implement support for different message -->\n", 
            "-    <!--formats in Axis2. These message formats are expected to be resolved based on the content type. -->\n", 
            "-    <messageBuilders>\n", 
            "-        <messageBuilder contentType=\"application/xml\"\n", 
            "-                        class=\"org.apache.axis2.builder.ApplicationXMLBuilder\"/>\n", 
            "-        <messageBuilder contentType=\"application/x-www-form-urlencoded\"\n", 
            "-                        class=\"org.apache.axis2.builder.XFormURLEncodedBuilder\"/>\n", 
            "-        <messageBuilder contentType=\"multipart/form-data\"\n", 
            "-                        class=\"org.apache.axis2.builder.MultipartFormDataBuilder\"/>\n", 
            "-        <!--<messageBuilder contentType=\"x-application/hessian\"\n", 
            "-        class=\"org.apache.synapse.format.hessian.HessianMessageBuilder\"/>-->\n", 
            "-        <!--<messageBuilder contentType=\"\"\n", 
            "-        class=\"org.apache.synapse.format.hessian.HessianMessageBuilder\"/>-->\n", 
            "-        <!--<messageBuilder contentType=\"application/json\"\n", 
            "-        class=\"org.apache.axis2.json.JSONOMBuilder\"/>-->\n", 
            "-    </messageBuilders>\n", 
            "-\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!-- Transport Ins -->\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!-- the non blocking http transport based on HttpCore  NIO extensions -->\n", 
            "-    <transportReceiver name=\"http\"\n", 
            "-                       class=\"org.apache.synapse.transport.nhttp.HttpCoreNIOListener\">\n", 
            "-        <parameter name=\"port\">8280</parameter>\n", 
            "-        <parameter name=\"non-blocking\">true</parameter>\n", 
            "-        <!--parameter name=\"bind-address\" locked=\"false\">hostname or IP address</parameter-->\n", 
            "-        <!--parameter name=\"WSDLEPRPrefix\" locked=\"false\">https://apachehost:port/somepath</parameter-->\n", 
            "-        <!-- paramter name=\"priorityConfigFile\" locked=\"false\">location of priority configuration file<parameter-->\n", 
            "-    </transportReceiver>\n", 
            "-\n", 
            "-    <!-- the non blocking https transport based on HttpCore  SSL-NIO extensions -->\n", 
            "-    <transportReceiver name=\"https\"\n", 
            "-                       class=\"org.apache.synapse.transport.nhttp.HttpCoreNIOSSLListener\">\n", 
            "-        <parameter name=\"port\" locked=\"false\">8243</parameter>\n", 
            "-        <!--parameter name=\"bind-address\" locked=\"false\">hostname or IP address</parameter-->\n", 
            "-        <!--parameter name=\"WSDLEPRPrefix\" locked=\"false\">http://apachehost:port/somepath</parameter-->\n", 
            "-        <parameter name=\"non-blocking\" locked=\"false\">true</parameter>\n", 
            "-        <parameter name=\"keystore\" locked=\"false\">\n", 
            "-            <KeyStore>\n", 
            "-                <Location>lib/identity.jks</Location>\n", 
            "-                <Type>JKS</Type>\n", 
            "-                <Password>password</Password>\n", 
            "-                <KeyPassword>password</KeyPassword>\n", 
            "-            </KeyStore>\n", 
            "-        </parameter>\n", 
            "-        <parameter name=\"truststore\" locked=\"false\">\n", 
            "-            <TrustStore>\n", 
            "-                <Location>lib/trust.jks</Location>\n", 
            "-                <Type>JKS</Type>\n", 
            "-                <Password>password</Password>\n", 
            "-            </TrustStore>\n", 
            "-        </parameter>\n", 
            "-        <!--<parameter name=\"SSLVerifyClient\">require</parameter>\n", 
            "-  supports optional|require or defaults to none -->\n", 
            "-    </transportReceiver>\n", 
            "-\n", 
            "-    <!--Uncomment this and configure as appropriate for JMS transport support, after setting up your JMS environment (e.g. ActiveMQ)\n", 
            "-    <transportReceiver name=\"jms\" class=\"org.apache.axis2.transport.jms.JMSListener\">\n", 
            "-        <parameter name=\"myTopicConnectionFactory\">\n", 
            "-            <parameter name=\"java.naming.factory.initial\">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>\n", 
            "-            <parameter name=\"java.naming.provider.url\">tcp://localhost:61616</parameter>\n", 
            "-            <parameter name=\"transport.jms.ConnectionFactoryJNDIName\">TopicConnectionFactory</parameter>\n", 
            "-        <parameter name=\"transport.jms.ConnectionFactoryType\" locked=\"false\">topic</parameter>\n", 
            "-        </parameter>\n", 
            "-\n", 
            "-        <parameter name=\"myQueueConnectionFactory\">\n", 
            "-            <parameter name=\"java.naming.factory.initial\">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>\n", 
            "-            <parameter name=\"java.naming.provider.url\">tcp://localhost:61616</parameter>\n", 
            "-            <parameter name=\"transport.jms.ConnectionFactoryJNDIName\">QueueConnectionFactory</parameter>\n", 
            "-        <parameter name=\"transport.jms.ConnectionFactoryType\" locked=\"false\">queue</parameter>\n", 
            "-        </parameter>\n", 
            "-\n", 
            "-        <parameter name=\"default\">\n", 
            "-            <parameter name=\"java.naming.factory.initial\">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>\n", 
            "-            <parameter name=\"java.naming.provider.url\">tcp://localhost:61616</parameter>\n", 
            "-            <parameter name=\"transport.jms.ConnectionFactoryJNDIName\">QueueConnectionFactory</parameter>\n", 
            "-        <parameter name=\"transport.jms.ConnectionFactoryType\" locked=\"false\">queue</parameter>\n", 
            "-        </parameter>\n", 
            "-    </transportReceiver>-->\n", 
            "-\n", 
            "-    <transportReceiver name=\"vfs\"\n", 
            "-                       class=\"org.apache.synapse.transport.vfs.VFSTransportListener\"/>\n", 
            "-\n", 
            "-    <transportReceiver name=\"mailto\"\n", 
            "-                       class=\"org.apache.axis2.transport.mail.MailTransportListener\">\n", 
            "-        <!-- configure any optional POP3/IMAP properties\n", 
            "-check com.sun.mail.pop3 and com.sun.mail.imap package documentation for more details-->\n", 
            "-    </transportReceiver>\n", 
            "-\n", 
            "-    <!--Uncomment this for FIX transport support\n", 
            "-    <transportReceiver name=\"fix\" class=\"org.apache.synapse.transport.fix.FIXTransportListener\">\n", 
            "-        <parameter name=\"non-blocking\">true</parameter>\n", 
            "-    </transportReceiver>-->\n", 
            "-\n", 
            "-    <!--Uncomment this for TCP transport support\n", 
            "-    <transportReceiver name=\"tcp\" class=\"org.apache.axis2.transport.tcp.TCPServer\">\n", 
            "-        <parameter name=\"port\">6060</parameter>\n", 
            "-    </transportReceiver>-->\n", 
            "-\n", 
            "-    <!--Uncomment this for UDP transport support\n", 
            "-  <transportReceiver name=\"udp\" class=\"org.apache.axis2.transport.udp.UDPListener\"/>-->\n", 
            "-\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!-- Transport Outs -->\n", 
            "-    <!-- ================================================= -->\n", 
            "-\n", 
            "-    <transportSender name=\"http\"\n", 
            "-                     class=\"org.apache.synapse.transport.nhttp.HttpCoreNIOSender\">\n", 
            "-        <parameter name=\"non-blocking\" locked=\"false\">true</parameter>\n", 
            "-        <parameter name=\"warnOnHTTP500\" locked=\"false\">*</parameter>\n", 
            "-        <!--parameter name=\"http.proxyHost\" locked=\"false\">localhost</parameter>\n", 
            "-      <parameter name=\"http.proxyPort\" locked=\"false\">3128</parameter>\n", 
            "-      <parameter name=\"http.nonProxyHosts\" locked=\"false\">localhost|moon|sun</parameter-->\n", 
            "-    </transportSender>\n", 
            "-    <transportSender name=\"https\"\n", 
            "-                     class=\"org.apache.synapse.transport.nhttp.HttpCoreNIOSSLSender\">\n", 
            "-        <parameter name=\"non-blocking\" locked=\"false\">true</parameter>\n", 
            "-        <parameter name=\"warnOnHTTP500\" locked=\"false\">*</parameter>\n", 
            "-        <parameter name=\"keystore\" locked=\"false\">\n", 
            "-            <KeyStore>\n", 
            "-                <Location>lib/identity.jks</Location>\n", 
            "-                <Type>JKS</Type>\n", 
            "-                <Password>password</Password>\n", 
            "-                <KeyPassword>password</KeyPassword>\n", 
            "-            </KeyStore>\n", 
            "-        </parameter>\n", 
            "-        <parameter name=\"truststore\" locked=\"false\">\n", 
            "-            <TrustStore>\n", 
            "-                <Location>lib/trust.jks</Location>\n", 
            "-                <Type>JKS</Type>\n", 
            "-                <Password>password</Password>\n", 
            "-            </TrustStore>\n", 
            "-        </parameter>\n", 
            "-        <!--<parameter name=\"HostnameVerifier\">DefaultAndLocalhost</parameter>\n", 
            "-supports Strict|AllowAll|DefaultAndLocalhost or the default if none specified -->\n", 
            "-    </transportSender>\n", 
            "-\n", 
            "-    <!-- Uncomment Transport sender for the non blocking local transport-->\n", 
            "-    <!--transportSender name=\"local\" class=\"org.apache.axis2.transport.local.NonBlockingLocalTransportSender\"/-->\n", 
            "-\n", 
            "-    <transportSender name=\"jms\"\n", 
            "-                     class=\"org.apache.axis2.transport.jms.JMSSender\">\n", 
            "-        <!-- uncomment this and configure to use connection pools for sending messages\n", 
            "-       <parameter name=\"myTopicConnectionFactory\">\n", 
            "-           <parameter name=\"java.naming.factory.initial\">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>\n", 
            "-           <parameter name=\"java.naming.provider.url\">tcp://localhost:61616</parameter>\n", 
            "-           <parameter name=\"transport.jms.ConnectionFactoryJNDIName\">TopicConnectionFactory</parameter>\n", 
            "-       </parameter>\n", 
            "-\n", 
            "-       <parameter name=\"myQueueConnectionFactory\">\n", 
            "-           <parameter name=\"java.naming.factory.initial\">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>\n", 
            "-           <parameter name=\"java.naming.provider.url\">tcp://localhost:61616</parameter>\n", 
            "-           <parameter name=\"transport.jms.ConnectionFactoryJNDIName\">QueueConnectionFactory</parameter>\n", 
            "-       </parameter>\n", 
            "-\n", 
            "-       <parameter name=\"default\">\n", 
            "-           <parameter name=\"java.naming.factory.initial\">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>\n", 
            "-           <parameter name=\"java.naming.provider.url\">tcp://localhost:61616</parameter>\n", 
            "-           <parameter name=\"transport.jms.ConnectionFactoryJNDIName\">QueueConnectionFactory</parameter>\n", 
            "-       </parameter> -->\n", 
            "-    </transportSender>\n", 
            "-\n", 
            "-    <transportSender name=\"vfs\"\n", 
            "-                     class=\"org.apache.synapse.transport.vfs.VFSTransportSender\"/>\n", 
            "-\n", 
            "-    <!-- Uncomment and configure the SMTP server information\n", 
            "-    check com.sun.mail.smtp package documentation for descriptions of properties\n", 
            "-    <transportSender name=\"mailto\" class=\"org.apache.axis2.transport.mail.MailTransportSender\">\n", 
            "-        <parameter name=\"mail.smtp.host\">smtp.gmail.com</parameter>\n", 
            "-        <parameter name=\"mail.smtp.port\">587</parameter>\n", 
            "-        <parameter name=\"mail.smtp.starttls.enable\">true</parameter>\n", 
            "-        <parameter name=\"mail.smtp.auth\">true</parameter>\n", 
            "-        <parameter name=\"mail.smtp.user\">synapse.demo.0</parameter>\n", 
            "-        <parameter name=\"mail.smtp.password\">mailpassword</parameter>\n", 
            "-        <parameter name=\"mail.smtp.from\">synapse.demo.0@gmail.com</parameter>\n", 
            "-    </transportSender>-->\n", 
            "-\n", 
            "-    <!--Uncomment this for FIX transport support\n", 
            "-    <transportSender name=\"fix\" class=\"org.apache.synapse.transport.fix.FIXTransportSender\">\n", 
            "-        <parameter name=\"non-blocking\">true</parameter>\n", 
            "-    </transportSender>-->\n", 
            "-\n", 
            "-    <!--Uncomment this for TCP transport support\n", 
            "-  <transportSender name=\"tcp\" class=\"org.apache.axis2.transport.tcp.TCPTransportSender\"/>-->\n", 
            "-\n", 
            "-    <!--Uncomment this for UDP transport support\n", 
            "-  <transportSender name=\"udp\" class=\"org.apache.axis2.transport.udp.UDPSender\"/>-->\n", 
            "-\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!-- Global Modules  -->\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!-- Comment this to disable Addressing -->\n", 
            "-    <module ref=\"addressing\"/>\n", 
            "-\n", 
            "-    <!--Configuring module , providing parameters for modules whether they refer or not-->\n", 
            "-    <!--<moduleConfig name=\"addressing\">-->\n", 
            "-    <!--<parameter name=\"addressingPara\">N/A</parameter>-->\n", 
            "-    <!--</moduleConfig>-->\n", 
            "-\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!--                  Clustering                       -->\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!-- Configure the following for preparing Synapse to a clustered environment -->\n", 
            "-    <clustering class=\"org.apache.axis2.clustering.tribes.TribesClusteringAgent\"\n", 
            "-                enable=\"false\">\n", 
            "-\n", 
            "-        <!--\n", 
            "-           This parameter indicates whther the cluster has to be automatically initalized\n", 
            "-           when the AxisConfiguration is built. If set to \"true\" the initialization will not be\n", 
            "-           done at that stage, and some other party will have to explictly initialize the cluster.\n", 
            "-        -->\n", 
            "-        <parameter name=\"AvoidInitiation\">false</parameter>\n", 
            "-\n", 
            "-        <!--\n", 
            "-           The membership scheme used in this setup. The only values supported at the moment are\n", 
            "-           \"multicast\" and \"wka\"\n", 
            "-\n", 
            "-           1. multicast - membership is automatically discovered using multicasting\n", 
            "-           2. wka - Well-Known Address based multicasting. Membership is discovered with the help\n", 
            "-                    of one or more nodes running at a Well-Known Address. New members joining a\n", 
            "-                    cluster will first connect to a well-known node, register with the well-known node\n", 
            "-                    and get the membership list from it. When new members join, one of the well-known\n", 
            "-                    nodes will notify the others in the group. When a member leaves the cluster or\n", 
            "-                    is deemed to have left the cluster, it will be detected by the Group Membership\n", 
            "-                    Service (GMS) using a TCP ping mechanism.\n", 
            "-        -->\n", 
            "-        <parameter name=\"membershipScheme\">multicast</parameter>\n", 
            "-\n", 
            "-        <!--\n", 
            "-         The clustering domain/group. Nodes in the same group will belong to the same multicast\n", 
            "-         domain. There will not be interference between nodes in different groups.\n", 
            "-        -->\n", 
            "-        <parameter name=\"domain\">apache.synapse.domain</parameter>\n", 
            "-\n", 
            "-        <!--\n", 
            "-           When a Web service request is received, and processed, before the response is sent to the\n", 
            "-           client, should we update the states of all members in the cluster? If the value of\n", 
            "-           this parameter is set to \"true\", the response to the client will be sent only after\n", 
            "-           all the members have been updated. Obviously, this can be time consuming. In some cases,\n", 
            "-           such this overhead may not be acceptable, in which case the value of this parameter\n", 
            "-           should be set to \"false\"\n", 
            "-        -->\n", 
            "-        <parameter name=\"synchronizeAll\">true</parameter>\n", 
            "-\n", 
            "-        <!--\n", 
            "-          The maximum number of times we need to retry to send a message to a particular node\n", 
            "-          before giving up and considering that node to be faulty\n", 
            "-        -->\n", 
            "-        <parameter name=\"maxRetries\">10</parameter>\n", 
            "-\n", 
            "-        <!-- The multicast address to be used -->\n", 
            "-        <parameter name=\"mcastAddress\">228.0.0.4</parameter>\n", 
            "-\n", 
            "-        <!-- The multicast port to be used -->\n", 
            "-        <parameter name=\"mcastPort\">45564</parameter>\n", 
            "-\n", 
            "-        <!-- The frequency of sending membership multicast messages (in ms) -->\n", 
            "-        <parameter name=\"mcastFrequency\">500</parameter>\n", 
            "-\n", 
            "-        <!-- The time interval within which if a member does not respond, the member will be\n", 
            "-        deemed to have left the group (in ms)\n", 
            "-        -->\n", 
            "-        <parameter name=\"memberDropTime\">3000</parameter>\n", 
            "-\n", 
            "-        <!--\n", 
            "-           The IP address of the network interface to which the multicasting has to be bound to.\n", 
            "-           Multicasting would be done using this interface.\n", 
            "-        -->\n", 
            "-        <parameter name=\"mcastBindAddress\">127.0.0.1</parameter>\n", 
            "-\n", 
            "-        <!-- The host name or IP address of this member -->\n", 
            "-        <parameter name=\"localMemberHost\">127.0.0.1</parameter>\n", 
            "-\n", 
            "-        <!--\n", 
            "-       The TCP port used by this member. This is the port through which other nodes will\n", 
            "-       contact this member\n", 
            "-        -->\n", 
            "-        <parameter name=\"localMemberPort\">4000</parameter>\n", 
            "-\n", 
            "-        <!--\n", 
            "-           The list of static or well-known members. These entries will only be valid if the\n", 
            "-           \"membershipScheme\" above is set to \"wka\"\n", 
            "-        -->\n", 
            "-        <members>\n", 
            "-            <member>\n", 
            "-                <hostName>127.0.0.1</hostName>\n", 
            "-                <port>4000</port>\n", 
            "-            </member>\n", 
            "-            <member>\n", 
            "-                <hostName>127.0.0.1</hostName>\n", 
            "-                <port>4001</port>\n", 
            "-            </member>\n", 
            "-        </members>\n", 
            "-\n", 
            "-        <!--\n", 
            "-        Enable the groupManagement entry if you need to run this node as a cluster manager.\n", 
            "-        Multiple application domains with different GroupManagementAgent implementations\n", 
            "-        can be defined in this section.\n", 
            "-        -->\n", 
            "-        <groupManagement enable=\"false\">\n", 
            "-            <applicationDomain name=\"apache.axis2.app.domain\"\n", 
            "-                               description=\"Axis2 group\"\n", 
            "-                               agent=\"org.apache.axis2.clustering.management.DefaultGroupManagementAgent\"/>\n", 
            "-        </groupManagement>\n", 
            "-\n", 
            "-        <!--\n", 
            "-           This interface is responsible for handling context replication. The property changes in\n", 
            "-           the Axis2 context hierarchy in this node, are propagated to all other nodes in the cluster.\n", 
            "-\n", 
            "-           The \"excludes\" patterns can be used to specify the prefixes (e.g. local_*) or\n", 
            "-           suffixes (e.g. *_local) of the properties to be excluded from replication. The pattern\n", 
            "-           \"*\" indicates that all properties in a particular context should not be replicated.\n", 
            "-\n", 
            "-            The \"enable\" attribute indicates whether context replication has been enabled\n", 
            "-        -->\n", 
            "-        <contextManager\n", 
            "-                class=\"org.apache.axis2.clustering.context.DefaultContextManager\"\n", 
            "-                enable=\"false\">\n", 
            "-            <listener\n", 
            "-                    class=\"org.apache.axis2.clustering.context.DefaultContextManagerListener\"/>\n", 
            "-            <replication>\n", 
            "-                <defaults>\n", 
            "-                    <exclude name=\"local_*\"/>\n", 
            "-                    <exclude name=\"LOCAL_*\"/>\n", 
            "-                </defaults>\n", 
            "-                <context class=\"org.apache.axis2.context.ConfigurationContext\">\n", 
            "-                    <exclude name=\"UseAsyncOperations\"/>\n", 
            "-                    <exclude name=\"SequencePropertyBeanMap\"/>\n", 
            "-                </context>\n", 
            "-                <context class=\"org.apache.axis2.context.ServiceGroupContext\">\n", 
            "-                    <exclude name=\"my.sandesha.*\"/>\n", 
            "-                </context>\n", 
            "-                <context class=\"org.apache.axis2.context.ServiceContext\">\n", 
            "-                    <exclude name=\"my.sandesha.*\"/>\n", 
            "-                </context>\n", 
            "-            </replication>\n", 
            "-        </contextManager>\n", 
            "-    </clustering>\n", 
            "-\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <!-- Phases  -->\n", 
            "-    <!-- ================================================= -->\n", 
            "-    <phaseOrder type=\"InFlow\">\n", 
            "-        <!--  System pre defined phases       -->\n", 
            "-        <phase name=\"Transport\">\n", 
            "-            <handler name=\"RequestURIBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.RequestURIBasedDispatcher\">\n", 
            "-                <order phase=\"Transport\"/>\n", 
            "-            </handler>\n", 
            "-            <handler name=\"SOAPActionBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.SOAPActionBasedDispatcher\">\n", 
            "-                <order phase=\"Transport\"/>\n", 
            "-            </handler>\n", 
            "-        </phase>\n", 
            "-        <phase name=\"Addressing\">\n", 
            "-            <handler name=\"AddressingBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.AddressingBasedDispatcher\">\n", 
            "-                <order phase=\"Addressing\"/>\n", 
            "-            </handler>\n", 
            "-        </phase>\n", 
            "-        <phase name=\"Security\"/>\n", 
            "-        <phase name=\"PreDispatch\"/>\n", 
            "-        <phase name=\"Dispatch\" class=\"org.apache.axis2.engine.DispatchPhase\">\n", 
            "-            <handler name=\"CustomURIBasedDispatcher\"\n", 
            "-                     class=\"org.apache.synapse.core.axis2.CustomURIBasedDispatcher\"/>\n", 
            "-            <handler name=\"RequestURIBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.RequestURIBasedDispatcher\"/>\n", 
            "-            <handler name=\"SOAPActionBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.SOAPActionBasedDispatcher\"/>\n", 
            "-            <handler name=\"RequestURIOperationDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.RequestURIOperationDispatcher\"/>\n", 
            "-            <handler name=\"SOAPMessageBodyBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.SOAPMessageBodyBasedDispatcher\"/>\n", 
            "-\n", 
            "-            <handler name=\"HTTPLocationBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.HTTPLocationBasedDispatcher\"/>\n", 
            "-        </phase>\n", 
            "-        <phase name=\"RMPhase\"/>\n", 
            "-        <!--  System predefined phases       -->\n", 
            "-        <!--   After Postdispatch phase module author or service author can add any phase he want      -->\n", 
            "-        <phase name=\"OperationInPhase\"/>\n", 
            "-        <phase name=\"soapmonitorPhase\"/>\n", 
            "-    </phaseOrder>\n", 
            "-    <phaseOrder type=\"OutFlow\">\n", 
            "-        <!--      user can add his own phases to this area  -->\n", 
            "-        <phase name=\"soapmonitorPhase\"/>\n", 
            "-        <phase name=\"OperationOutPhase\"/>\n", 
            "-        <!--system predefined phase-->\n", 
            "-        <!--these phase will run irrespective of the service-->\n", 
            "-        <phase name=\"RMPhase\"/>\n", 
            "-        <phase name=\"PolicyDetermination\"/>\n", 
            "-        <phase name=\"MessageOut\"/>\n", 
            "-        <phase name=\"Security\"/>\n", 
            "-    </phaseOrder>\n", 
            "-    <phaseOrder type=\"InFaultFlow\">\n", 
            "-        <phase name=\"Addressing\">\n", 
            "-            <handler name=\"AddressingBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.AddressingBasedDispatcher\">\n", 
            "-                <order phase=\"Addressing\"/>\n", 
            "-            </handler>\n", 
            "-        </phase>\n", 
            "-        <phase name=\"Security\"/>\n", 
            "-        <phase name=\"PreDispatch\"/>\n", 
            "-        <phase name=\"Dispatch\" class=\"org.apache.axis2.engine.DispatchPhase\">\n", 
            "-            <handler name=\"RequestURIBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.RequestURIBasedDispatcher\"/>\n", 
            "-            <handler name=\"SOAPActionBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.SOAPActionBasedDispatcher\"/>\n", 
            "-            <handler name=\"RequestURIOperationDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.RequestURIOperationDispatcher\"/>\n", 
            "-            <handler name=\"SOAPMessageBodyBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.SOAPMessageBodyBasedDispatcher\"/>\n", 
            "-\n", 
            "-            <handler name=\"HTTPLocationBasedDispatcher\"\n", 
            "-                     class=\"org.apache.axis2.dispatchers.HTTPLocationBasedDispatcher\"/>\n", 
            "-        </phase>\n", 
            "-        <phase name=\"RMPhase\"/>\n", 
            "-        <!--      user can add his own phases to this area  -->\n", 
            "-        <phase name=\"OperationInFaultPhase\"/>\n", 
            "-        <phase name=\"soapmonitorPhase\"/>\n", 
            "-    </phaseOrder>\n", 
            "-    <phaseOrder type=\"OutFaultFlow\">\n", 
            "-        <!--      user can add his own phases to this area  -->\n", 
            "-        <phase name=\"soapmonitorPhase\"/>\n", 
            "-        <phase name=\"OperationOutFaultPhase\"/>\n", 
            "-        <phase name=\"RMPhase\"/>\n", 
            "-        <phase name=\"PolicyDetermination\"/>\n", 
            "-        <phase name=\"MessageOut\"/>\n", 
            "-        <phase name=\"Security\"/>\n", 
            "-    </phaseOrder>\n", 
            "-</axisconfig>\n"
          ]
        }
      ], 
      "to": "java/repository/conf/axis2_server.xml", 
      "from": "java/repository/conf/axis2_server.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-22,13 +22,19", 
          "lines": [
            " import org.apache.axiom.om.OMAbstractFactory;\n", 
            " import org.apache.axiom.om.OMElement;\n", 
            " import org.apache.axis2.AxisFault;\n", 
            "+import org.apache.axis2.Constants;\n", 
            " import org.apache.axis2.addressing.EndpointReference;\n", 
            " import org.apache.axis2.builder.Builder;\n", 
            " import org.apache.axis2.context.MessageContext;\n", 
            "+import org.apache.axis2.description.AxisBindingOperation;\n", 
            "+import org.apache.axis2.description.AxisEndpoint;\n", 
            "+import org.apache.axis2.description.AxisOperation;\n", 
            " import org.apache.axis2.description.AxisService;\n", 
            " import org.apache.axis2.description.WSDL20DefaultValueHolder;\n", 
            " import org.apache.axis2.description.WSDL2Constants;\n", 
            "+import org.apache.axis2.dispatchers.HTTPLocationBasedDispatcher;\n", 
            " import org.apache.axis2.dispatchers.RequestURIBasedDispatcher;\n", 
            "+import org.apache.axis2.dispatchers.RequestURIOperationDispatcher;\n", 
            " import org.apache.axis2.engine.AxisEngine;\n", 
            " import org.apache.axis2.transport.http.HTTPConstants;\n", 
            " import org.apache.axis2.transport.http.util.URIEncoderDecoder;\n"
          ]
        }, 
        {
          "locn": "-287,4 +293,32", 
          "lines": [
            "             msgContext.setAxisService(axisService);\n", 
            "         }\n", 
            "     }\n", 
            "+    \n", 
            "+    public static void dispatchAndVerify(MessageContext msgContext) throws AxisFault {\n", 
            "+        RequestURIBasedDispatcher requestDispatcher = new RequestURIBasedDispatcher();\n", 
            "+        requestDispatcher.invoke(msgContext);\n", 
            "+        AxisService axisService = msgContext.getAxisService();\n", 
            "+        if (axisService != null) {\n", 
            "+            HTTPLocationBasedDispatcher httpLocationBasedDispatcher =\n", 
            "+                    new HTTPLocationBasedDispatcher();\n", 
            "+            httpLocationBasedDispatcher.invoke(msgContext);\n", 
            "+            if (msgContext.getAxisOperation() == null) {\n", 
            "+                RequestURIOperationDispatcher requestURIOperationDispatcher =\n", 
            "+                        new RequestURIOperationDispatcher();\n", 
            "+                requestURIOperationDispatcher.invoke(msgContext);\n", 
            "+            }\n", 
            "+\n", 
            "+            AxisOperation axisOperation;\n", 
            "+            if ((axisOperation = msgContext.getAxisOperation()) != null) {\n", 
            "+                AxisEndpoint axisEndpoint =\n", 
            "+                        (AxisEndpoint) msgContext.getProperty(WSDL2Constants.ENDPOINT_LOCAL_NAME);\n", 
            "+                if (axisEndpoint != null) {\n", 
            "+                    AxisBindingOperation axisBindingOperation = (AxisBindingOperation) axisEndpoint\n", 
            "+                            .getBinding().getChild(axisOperation.getName());\n", 
            "+                    msgContext.setProperty(Constants.AXIS_BINDING_OPERATION, axisBindingOperation);\n", 
            "+                }\n", 
            "+                msgContext.setAxisOperation(axisOperation);\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/util/RESTUtil.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/util/RESTUtil.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-153,4 +153,14", 
          "lines": [
            "      */\n", 
            "     public static final String SO_TIMEOUT_RECEIVER = \"http.socket.timeout.receiver\";\n", 
            "     public static final String SO_TIMEOUT_SENDER = \"http.socket.timeout.sender\";\n", 
            "+    \n", 
            "+    /** This property can be used to set the HOST header sent from the client to synapse */\n", 
            "+    public static final String REQUEST_HOST_HEADER = \"REQUEST_HOST_HEADER\";\n", 
            "+    \n", 
            "+\n", 
            "+    /** The name of the system property used to specify/override the nhttp properties location */\n", 
            "+    public static final String NHTTP_PROPERTIES = \"nhttp.properties\";\n", 
            "+\n", 
            "+    //property name of nhttp log directory\n", 
            "+    public static final String NHTTP_LOG_DIRECTORY = \"nhttp.log.directory\";\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-188,8 +188,8", 
          "lines": [
            "         sampleClassRepo.put(\"59\", Sample59.class);\n", 
            " \n", 
            "         //QoS\n", 
            "-        sampleClassRepo.put(\"100\", Sample100.class);\n", 
            "-        //sampleClassRepo.put(\"101\", Sample101.class);\n", 
            "+        //sampleClassRepo.put(\"100\", Sample100.class);\n", 
            "+        sampleClassRepo.put(\"101\", Sample101.class);\n", 
            " \n", 
            "         //Proxy Service\n", 
            "         sampleClassRepo.put(\"150\", Sample150.class);\n"
          ]
        }, 
        {
          "locn": "-198,7 +198,7", 
          "lines": [
            "         //sampleClassRepo.put(\"153\", Sample153.class); // unable to load the JKS files\n", 
            "         sampleClassRepo.put(\"154\", Sample154.class);\n", 
            "         sampleClassRepo.put(\"155\", Sample155.class);\n", 
            "-        sampleClassRepo.put(\"156\", Sample156.class);\n", 
            "+        //sampleClassRepo.put(\"156\", Sample156.class);\n", 
            "         sampleClassRepo.put(\"157\", Sample157.class);\n", 
            " \n", 
            "         //Advanced\n"
          ]
        }
      ], 
      "to": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/TestSamplesHandlerSuite.java", 
      "from": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/TestSamplesHandlerSuite.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-170,8 +170,6", 
          "lines": [
            "             payload = StockQuoteHandler.createStandardQuoteRequest(\n", 
            "                     symbol, 1);\n", 
            "             serviceClient.getOptions().setAction(\"urn:getQuote\");\n", 
            "-            serviceClient.getOptions().setUseSeparateListener(true);\n", 
            "-            serviceClient.engageModule(\"addressing\");\n", 
            "             setCompleted(false);\n", 
            "             serviceClient.sendReceiveNonBlocking(payload, new StockQuoteCallback(this));\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/clients/StockQuoteSampleClient.java", 
      "from": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/clients/StockQuoteSampleClient.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-42,7 +42,7", 
          "lines": [
            "         log.info(\"Running test: Dual channel invocation on both client side and server \" +\n", 
            "                 \"side of Synapse with Proxy Services\");\n", 
            "         SampleClientResult result = client.requestDualQuote(addUrl, null, null, \"IBM\");\n", 
            "-        assertTrue(\"Client did not run successfully \", result.responseReceived());\n", 
            "+        assertTrue(\"Client did not get run successfully \", result.responseReceived());\n", 
            "     }\n", 
            " \n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/tests/proxy/Sample155.java", 
      "from": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/tests/proxy/Sample155.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-24,7 +24,8", 
          "lines": [
            " import org.apache.synapse.MessageContext;\n", 
            " import org.apache.synapse.SynapseLog;\n", 
            " import org.apache.synapse.core.SynapseEnvironment;\n", 
            "-import org.apache.synapse.core.relay.RelayUtils;\n", 
            "+import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            "+import org.apache.synapse.transport.passthru.util.RelayUtils;\n", 
            " \n", 
            " import java.util.ArrayList;\n", 
            " import java.util.List;\n"
          ]
        }, 
        {
          "locn": "-58,7 +59,7", 
          "lines": [
            " \n", 
            "             if (contentAware) {\n", 
            "                 try {\n", 
            "-                    RelayUtils.buildMessage(synCtx);\n", 
            "+                    RelayUtils.buildMessage(((Axis2MessageContext) synCtx).getAxis2MessageContext(),false);\n", 
            "                 } catch (Exception e) {\n", 
            "                     handleException(\"Error while building message\", e, synCtx);\n", 
            "                 }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/mediators/AbstractListMediator.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/mediators/AbstractListMediator.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,18 +1,20", 
          "lines": [
            " /*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            " package org.apache.synapse.config.xml;\n", 
            " \n", 
            " import org.apache.axiom.om.OMAttribute;\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseImportFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseImportFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,18 +1,20", 
          "lines": [
            " /*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "+*  Copyright (c) 2005-2011, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            " package org.apache.synapse.config.xml.endpoints;\n", 
            " \n", 
            " import org.apache.axiom.om.OMElement;\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/ClassEndpointFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/ClassEndpointFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,18 +1,20", 
          "lines": [
            " /*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            " package org.apache.synapse.config.xml.rest;\n", 
            " \n", 
            " import org.apache.axiom.om.OMAttribute;\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/VersionStrategyFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/VersionStrategyFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,18 +1,20", 
          "lines": [
            " /*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            " package org.apache.synapse.config.xml.rest;\n", 
            " \n", 
            " import org.apache.axiom.om.OMAbstractFactory;\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/VersionStrategySerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/VersionStrategySerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,18 +1,20", 
          "lines": [
            " /*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            " package org.apache.synapse.config.xml;\n", 
            " \n", 
            " import org.apache.axiom.om.OMAbstractFactory;\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseImportSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseImportSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,18 +1,20", 
          "lines": [
            " /*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            " package org.apache.synapse.deployers;\n", 
            " \n", 
            " import org.apache.axiom.om.OMElement;\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/deployers/ImportDeployer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/deployers/ImportDeployer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,18 +1,20", 
          "lines": [
            " /*\n", 
            "- *  Copyright 2013 Apache Software Foundation\n", 
            "- *\n", 
            "- *  Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "- *  you may not use this file except in compliance with the License.\n", 
            "- *  You may obtain a copy of the License at\n", 
            "- *\n", 
            "- *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "- *\n", 
            "- *  Unless required by applicable law or agreed to in writing, software\n", 
            "- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "- *  See the License for the specific language governing permissions and\n", 
            "- *  limitations under the License.\n", 
            "- */\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            " package org.apache.synapse.deployers;\n", 
            " \n", 
            " import org.apache.axiom.om.OMElement;\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/deployers/LibraryArtifactDeployer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/deployers/LibraryArtifactDeployer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-30,9 +30,9", 
          "lines": [
            " import org.apache.commons.logging.Log;\n", 
            " import org.apache.commons.logging.LogFactory;\n", 
            " import org.apache.synapse.*;\n", 
            "-import org.apache.synapse.core.relay.RelayUtils;\n", 
            " import org.apache.synapse.rest.RESTRequestHandler;\n", 
            " import org.apache.synapse.task.SynapseTaskManager;\n", 
            "+import org.apache.synapse.transport.passthru.util.RelayUtils;\n", 
            " import org.apache.synapse.aspects.statistics.StatisticsCollector;\n", 
            " import org.apache.synapse.config.SynapseConfiguration;\n", 
            " import org.apache.synapse.core.SynapseEnvironment;\n"
          ]
        }, 
        {
          "locn": "-265,7 +265,7", 
          "lines": [
            "                     ProxyService proxyService = synapseConfig.getProxyService(proxyName);\n", 
            "                     if (proxyService.isModuleEngaged()) {\n", 
            "                         try {\n", 
            "-                            RelayUtils.buildMessage(synCtx);\n", 
            "+                        \t RelayUtils.buildMessage(((Axis2MessageContext) synCtx).getAxis2MessageContext(),false);\n", 
            "                         } catch (Exception e) {\n", 
            "                             handleException(\"Error building message\", e);\n", 
            "                         }\n"
          ]
        }, 
        {
          "locn": "-288,7 +288,7", 
          "lines": [
            "             synCtx.setProperty(SynapseConstants.SENDING_REQUEST, true);\n", 
            "             if (endpoint == null) {\n", 
            "                 try {\n", 
            "-                    RelayUtils.buildMessage(synCtx);\n", 
            "+                \tRelayUtils.buildMessage(((Axis2MessageContext) synCtx).getAxis2MessageContext(),false);\n", 
            "                 } catch (Exception e) {\n", 
            "                     handleException(\"Error while building message\", e);\n", 
            "                 }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-34,10 +34,10", 
          "lines": [
            " import org.apache.synapse.core.SynapseEnvironment;\n", 
            " import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            " import org.apache.synapse.core.axis2.Axis2SynapseEnvironment;\n", 
            "-import org.apache.synapse.core.relay.RelayConstants;\n", 
            "-import org.apache.synapse.core.relay.RelayUtils;\n", 
            " import org.apache.synapse.mediators.MediatorFaultHandler;\n", 
            " import org.apache.synapse.mediators.MediatorProperty;\n", 
            "+import org.apache.synapse.transport.passthru.util.RelayConstants;\n", 
            "+import org.apache.synapse.transport.passthru.util.RelayUtils;\n", 
            " \n", 
            " import java.util.*;\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-289,7 +289,7", 
          "lines": [
            " \n", 
            "         if (contentAware) {\n", 
            "             try {\n", 
            "-                RelayUtils.buildMessage(synCtx);\n", 
            "+            \tRelayUtils.buildMessage(((Axis2MessageContext) synCtx).getAxis2MessageContext(),false);\n", 
            "                 axis2Ctx.setProperty(RelayConstants.FORCE_RESPONSE_EARLY_BUILD, Boolean.TRUE);\n", 
            "             } catch (Exception e) {\n", 
            "                 handleException(\"Error while building message\", e);\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/AbstractEndpoint.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/AbstractEndpoint.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-23,13 +23,14", 
          "lines": [
            " import org.apache.synapse.MessageContext;\n", 
            " import org.apache.synapse.SynapseConstants;\n", 
            " import org.apache.synapse.core.SynapseEnvironment;\n", 
            "+import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            " import org.apache.synapse.core.axis2.Axis2SynapseEnvironment;\n", 
            "-import org.apache.synapse.core.relay.RelayUtils;\n", 
            " import org.apache.synapse.endpoints.dispatch.Dispatcher;\n", 
            " import org.apache.synapse.endpoints.dispatch.HttpSessionDispatcher;\n", 
            " import org.apache.synapse.endpoints.dispatch.SALSessions;\n", 
            " import org.apache.synapse.endpoints.dispatch.SessionInformation;\n", 
            " import org.apache.synapse.mediators.MediatorProperty;\n", 
            "+import org.apache.synapse.transport.passthru.util.RelayUtils;\n", 
            " \n", 
            " import javax.xml.stream.XMLStreamException;\n", 
            " import java.io.IOException;\n"
          ]
        }, 
        {
          "locn": "-108,7 +109,7", 
          "lines": [
            " \n", 
            "         if (!(dispatcher instanceof HttpSessionDispatcher)) {\n", 
            "             try {\n", 
            "-                RelayUtils.buildMessage(synCtx);\n", 
            "+            \tRelayUtils.buildMessage(((Axis2MessageContext) synCtx).getAxis2MessageContext(),false);\n", 
            "             } catch (Exception e) {\n", 
            "                 handleException(\"Error while building message\", e);\n", 
            "             }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/SALoadbalanceEndpoint.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/SALoadbalanceEndpoint.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-22,6 +22,9", 
          "lines": [
            " <definitions xmlns=\"http://ws.apache.org/ns/synapse\">\n", 
            " \n", 
            "     <sequence name=\"myFaultHandler\">\n", 
            "+        <log level=\"custom\">\n", 
            "+            <property name=\"******ERROR\" expression=\"get-property('ERROR_MESSAGE')\"/>\n", 
            "+        </log>\n", 
            "         <makefault response=\"true\">\n", 
            "             <code xmlns:tns=\"http://www.w3.org/2003/05/soap-envelope\" value=\"tns:Receiver\"/>\n", 
            "             <reason expression=\"get-property('ERROR_MESSAGE')\"/>\n"
          ]
        }
      ], 
      "to": "java/repository/conf/sample/synapse_sample_5.xml", 
      "from": "java/repository/conf/sample/synapse_sample_5.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-59,7 +59,6", 
          "lines": [
            "             <source type=\"property\" property=\"REQUEST\"/>\n", 
            "             <target type=\"body\"/>\n", 
            "         </enrich>\n", 
            "-        <header name=\"Action\" value=\"urn:getQuote\"/>\n", 
            "         <send receive=\"ClientOutSeq\">\n", 
            "             <endpoint name=\"SimpleStockQuoteService\">\n", 
            "                 <address uri=\"http://localhost:9000/services/SimpleStockQuoteService\"/>\n"
          ]
        }
      ], 
      "to": "java/repository/conf/sample/synapse_sample_156.xml", 
      "from": "java/repository/conf/sample/synapse_sample_156.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-507,7 +507,6", 
          "lines": [
            "                      class=\"org.apache.axis2.dispatchers.SOAPActionBasedDispatcher\">\n", 
            "                 <order phase=\"Transport\"/>\n", 
            "             </handler>\n", 
            "-            <handler name=\"EarlyBuilder\" class=\"org.apache.synapse.core.relay.ServiceRequestEarlyBuilder\"/>\n", 
            "         </phase>\n", 
            "         <phase name=\"Addressing\">\n", 
            "             <handler name=\"AddressingBasedDispatcher\"\n"
          ]
        }
      ], 
      "to": "java/repository/conf/axis2.xml", 
      "from": "java/repository/conf/axis2.xml"
    }
  ], 
  "id": "1502655"
}