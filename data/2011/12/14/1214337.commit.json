{
  "when": "2011-12-14T12:00:13-05:00", 
  "who": "kasun", 
  "changes": [
    {
      "chunks": [], 
      "to": "java/modules/patches/jars/httpcore-nio-4.0-patch-httpcore-193.jar", 
      "from": "java/modules/patches/jars/httpcore-nio-4.0-patch-httpcore-193.jar"
    }, 
    {
      "chunks": [], 
      "to": "java/modules/patches/jars/commons-vfs2-2.0-vfs-178.jar", 
      "from": "java/modules/patches/jars/commons-vfs2-2.0-vfs-178.jar"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,490", 
          "lines": [
            "+/*\n", 
            "+ * Licensed to the Apache Software Foundation (ASF) under one or more\n", 
            "+ * contributor license agreements.  See the NOTICE file distributed with\n", 
            "+ * this work for additional information regarding copyright ownership.\n", 
            "+ * The ASF licenses this file to You under the Apache License, Version 2.0\n", 
            "+ * (the \"License\"); you may not use this file except in compliance with\n", 
            "+ * the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.commons.vfs2.provider;\n", 
            "+\n", 
            "+import org.apache.commons.vfs2.FileName;\n", 
            "+import org.apache.commons.vfs2.FileSystemException;\n", 
            "+import org.apache.commons.vfs2.FileType;\n", 
            "+import org.apache.commons.vfs2.NameScope;\n", 
            "+import org.apache.commons.vfs2.VFS;\n", 
            "+\n", 
            "+/**\n", 
            "+ * A default file name implementation.\n", 
            "+ * PATCH for  : https://issues.apache.org/jira/browse/VFS-178\n", 
            "+ * @author <a href=\"http://commons.apache.org/vfs/team-list.html\">Commons VFS team</a>\n", 
            "+ */\n", 
            "+public abstract class AbstractFileName implements FileName {\n", 
            "+\n", 
            "+    private final String scheme;\n", 
            "+    private final String absPath;\n", 
            "+    private FileType type;\n", 
            "+\n", 
            "+    // Cached stuff\n", 
            "+    private String uri;\n", 
            "+    private String baseName;\n", 
            "+    private String rootUri;\n", 
            "+    private String extension;\n", 
            "+    private String decodedAbsPath;\n", 
            "+\n", 
            "+    private String key = null;\n", 
            "+\n", 
            "+    public AbstractFileName(final String scheme, final String absPath, FileType type) {\n", 
            "+        this.rootUri = null;\n", 
            "+        this.scheme = scheme;\n", 
            "+        this.type = type;\n", 
            "+\n", 
            "+        String actualPath = absPath;\n", 
            "+        int pos = absPath.indexOf(\"?\");\n", 
            "+        if (pos != -1) {\n", 
            "+            actualPath = absPath.substring(0, pos);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (actualPath != null && actualPath.length() > 0) {\n", 
            "+            if (actualPath.length() > 1 && actualPath.endsWith(\"/\")) {\n", 
            "+                this.absPath = actualPath.substring(0, actualPath.length() - 1);\n", 
            "+            } else {\n", 
            "+                this.absPath = actualPath;\n", 
            "+            }\n", 
            "+        } else {\n", 
            "+            this.absPath = ROOT_PATH;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public boolean equals(Object o) {\n", 
            "+        if (this == o) {\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+        if (o == null || getClass() != o.getClass()) {\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+\n", 
            "+        AbstractFileName that = (AbstractFileName) o;\n", 
            "+\n", 
            "+        return (getKey().equals(that.getKey()));\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public int hashCode() {\n", 
            "+        return getKey().hashCode();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Implement Comparable.\n", 
            "+     *\n", 
            "+     * @param obj another abstractfilename\n", 
            "+     * @return negative number if less than, 0 if equal, postive if greater than.\n", 
            "+     */\n", 
            "+    public int compareTo(FileName obj) {\n", 
            "+        final AbstractFileName name = (AbstractFileName) obj;\n", 
            "+        return getKey().compareTo(name.getKey());\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the URI of the file.\n", 
            "+     *\n", 
            "+     * @return the FileName as a URI.\n", 
            "+     */\n", 
            "+    @Override\n", 
            "+    public String toString() {\n", 
            "+        return getURI();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Factory method for creating name instances.\n", 
            "+     *\n", 
            "+     * @param absPath The absolute path.\n", 
            "+     * @param type    The FileType.\n", 
            "+     * @return The FileName.\n", 
            "+     */\n", 
            "+    public abstract FileName createName(String absPath, FileType type);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Builds the root URI for this file name.  Note that the root URI must not\n", 
            "+     * end with a separator character.\n", 
            "+     *\n", 
            "+     * @param buffer      A StringBuilder to use to construct the URI.\n", 
            "+     * @param addPassword true if the password should be added, false otherwise.\n", 
            "+     */\n", 
            "+    protected abstract void appendRootUri(StringBuilder buffer, boolean addPassword);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the base name of the file.\n", 
            "+     *\n", 
            "+     * @return The base name of the file.\n", 
            "+     */\n", 
            "+    public String getBaseName() {\n", 
            "+        if (baseName == null) {\n", 
            "+            final int idx = getPath().lastIndexOf(SEPARATOR_CHAR);\n", 
            "+            if (idx == -1) {\n", 
            "+                baseName = getPath();\n", 
            "+            } else {\n", 
            "+                baseName = getPath().substring(idx + 1);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        return baseName;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the absolute path of the file, relative to the root of the\n", 
            "+     * file system that the file belongs to.\n", 
            "+     *\n", 
            "+     * @return The path String.\n", 
            "+     */\n", 
            "+    public String getPath() {\n", 
            "+        if (VFS.isUriStyle()) {\n", 
            "+            return absPath + getUriTrailer();\n", 
            "+        }\n", 
            "+        return absPath;\n", 
            "+    }\n", 
            "+\n", 
            "+    protected String getUriTrailer() {\n", 
            "+        return getType().hasChildren() ? \"/\" : \"\";\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the decoded path.\n", 
            "+     *\n", 
            "+     * @return The decoded path String.\n", 
            "+     * @throws FileSystemException If an error occurs.\n", 
            "+     */\n", 
            "+    public String getPathDecoded() throws FileSystemException {\n", 
            "+        if (decodedAbsPath == null) {\n", 
            "+            decodedAbsPath = UriParser.decode(getPath());\n", 
            "+        }\n", 
            "+\n", 
            "+        return decodedAbsPath;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the name of the parent of the file.\n", 
            "+     *\n", 
            "+     * @return the FileName of the parent.\n", 
            "+     */\n", 
            "+    public FileName getParent() {\n", 
            "+        final String parentPath;\n", 
            "+        final int idx = getPath().lastIndexOf(SEPARATOR_CHAR);\n", 
            "+        if (idx == -1 || idx == getPath().length() - 1) {\n", 
            "+            // No parent\n", 
            "+            return null;\n", 
            "+        } else if (idx == 0) {\n", 
            "+            // Root is the parent\n", 
            "+            parentPath = SEPARATOR;\n", 
            "+        } else {\n", 
            "+            parentPath = getPath().substring(0, idx);\n", 
            "+        }\n", 
            "+        return createName(parentPath, FileType.FOLDER);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * find the root of the filesystem.\n", 
            "+     *\n", 
            "+     * @return The root FileName.\n", 
            "+     */\n", 
            "+    public FileName getRoot() {\n", 
            "+        FileName root = this;\n", 
            "+        while (root.getParent() != null) {\n", 
            "+            root = root.getParent();\n", 
            "+        }\n", 
            "+\n", 
            "+        return root;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the URI scheme of this file.\n", 
            "+     *\n", 
            "+     * @return The protocol used to access the file.\n", 
            "+     */\n", 
            "+    public String getScheme() {\n", 
            "+        return scheme;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the absolute URI of the file.\n", 
            "+     *\n", 
            "+     * @return The absolute URI of the file.\n", 
            "+     */\n", 
            "+    public String getURI() {\n", 
            "+        if (uri == null) {\n", 
            "+            uri = createURI();\n", 
            "+        }\n", 
            "+        return uri;\n", 
            "+    }\n", 
            "+\n", 
            "+    protected String createURI() {\n", 
            "+        return createURI(false, true);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Create a path that does not use the FileType since that field is not immutable.\n", 
            "+     *\n", 
            "+     * @return The key.\n", 
            "+     */\n", 
            "+    private String getKey() {\n", 
            "+        if (key == null) {\n", 
            "+            key = createURI(true, true);\n", 
            "+        }\n", 
            "+        return key;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * returns a \"friendly path\", this is a path without a password.\n", 
            "+     *\n", 
            "+     * @return The \"friendly\" URI.\n", 
            "+     */\n", 
            "+    public String getFriendlyURI() {\n", 
            "+        return createURI(false, false);\n", 
            "+    }\n", 
            "+\n", 
            "+    private String createURI(boolean useAbsolutePath, boolean usePassword) {\n", 
            "+        final StringBuilder buffer = new StringBuilder();\n", 
            "+        appendRootUri(buffer, usePassword);\n", 
            "+        buffer.append(useAbsolutePath ? absPath : getPath());\n", 
            "+        return buffer.toString();\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Converts a file name to a relative name, relative to this file name.\n", 
            "+     *\n", 
            "+     * @param name The FileName.\n", 
            "+     * @return The relative path to the file.\n", 
            "+     * @throws FileSystemException if an error occurs.\n", 
            "+     */\n", 
            "+    public String getRelativeName(final FileName name) throws FileSystemException {\n", 
            "+        final String path = name.getPath();\n", 
            "+\n", 
            "+        // Calculate the common prefix\n", 
            "+        final int basePathLen = getPath().length();\n", 
            "+        final int pathLen = path.length();\n", 
            "+\n", 
            "+        // Deal with root\n", 
            "+        if (basePathLen == 1 && pathLen == 1) {\n", 
            "+            return \".\";\n", 
            "+        } else if (basePathLen == 1) {\n", 
            "+            return path.substring(1);\n", 
            "+        }\n", 
            "+\n", 
            "+        final int maxlen = Math.min(basePathLen, pathLen);\n", 
            "+        int pos = 0;\n", 
            "+        for (; pos < maxlen && getPath().charAt(pos) == path.charAt(pos); pos++) {\n", 
            "+        }\n", 
            "+\n", 
            "+        if (pos == basePathLen && pos == pathLen) {\n", 
            "+            // Same names\n", 
            "+            return \".\";\n", 
            "+        } else if (pos == basePathLen && pos < pathLen && path.charAt(pos) == SEPARATOR_CHAR) {\n", 
            "+            // A descendent of the base path\n", 
            "+            return path.substring(pos + 1);\n", 
            "+        }\n", 
            "+\n", 
            "+        // Strip the common prefix off the path\n", 
            "+        final StringBuilder buffer = new StringBuilder();\n", 
            "+        if (pathLen > 1 && (pos < pathLen || getPath().charAt(pos) != SEPARATOR_CHAR)) {\n", 
            "+            // Not a direct ancestor, need to back up\n", 
            "+            pos = getPath().lastIndexOf(SEPARATOR_CHAR, pos);\n", 
            "+            buffer.append(path.substring(pos));\n", 
            "+        }\n", 
            "+\n", 
            "+        // Prepend a '../' for each element in the base path past the common\n", 
            "+        // prefix\n", 
            "+        buffer.insert(0, \"..\");\n", 
            "+        pos = getPath().indexOf(SEPARATOR_CHAR, pos + 1);\n", 
            "+        while (pos != -1) {\n", 
            "+            buffer.insert(0, \"../\");\n", 
            "+            pos = getPath().indexOf(SEPARATOR_CHAR, pos + 1);\n", 
            "+        }\n", 
            "+\n", 
            "+        return buffer.toString();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the root URI of the file system this file belongs to.\n", 
            "+     *\n", 
            "+     * @return The URI of the root.\n", 
            "+     */\n", 
            "+    public String getRootURI() {\n", 
            "+        if (rootUri == null) {\n", 
            "+            final StringBuilder buffer = new StringBuilder();\n", 
            "+            appendRootUri(buffer, true);\n", 
            "+            buffer.append(SEPARATOR_CHAR);\n", 
            "+            rootUri = buffer.toString().intern();\n", 
            "+        }\n", 
            "+        return rootUri;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the depth of this file name, within its file system.\n", 
            "+     *\n", 
            "+     * @return The depth of the file name.\n", 
            "+     */\n", 
            "+    public int getDepth() {\n", 
            "+        final int len = getPath().length();\n", 
            "+        if (len == 0 || (len == 1 && getPath().charAt(0) == SEPARATOR_CHAR)) {\n", 
            "+            return 0;\n", 
            "+        }\n", 
            "+        int depth = 1;\n", 
            "+        for (int pos = 0; pos > -1 && pos < len; depth++) {\n", 
            "+            pos = getPath().indexOf(SEPARATOR_CHAR, pos + 1);\n", 
            "+        }\n", 
            "+        return depth;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the extension of this file name.\n", 
            "+     *\n", 
            "+     * @return The file extension.\n", 
            "+     */\n", 
            "+    public String getExtension() {\n", 
            "+        if (extension == null) {\n", 
            "+            getBaseName();\n", 
            "+            final int pos = baseName.lastIndexOf('.');\n", 
            "+            // if ((pos == -1) || (pos == baseName.length() - 1))\n", 
            "+            // imario@ops.co.at: Review of patch from adagoubard@chello.nl\n", 
            "+            // do not treat filenames like\n", 
            "+            // .bashrc c:\\windows\\.java c:\\windows\\.javaws c:\\windows\\.jedit c:\\windows\\.appletviewer\n", 
            "+            // as extension\n", 
            "+            if ((pos < 1) || (pos == baseName.length() - 1)) {\n", 
            "+                // No extension\n", 
            "+                extension = \"\";\n", 
            "+            } else {\n", 
            "+                extension = baseName.substring(pos + 1).intern();\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return extension;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Determines if another file name is an ancestor of this file name.\n", 
            "+     *\n", 
            "+     * @param ancestor The FileName to check.\n", 
            "+     * @return true if the FileName is an ancestor, false otherwise.\n", 
            "+     */\n", 
            "+    public boolean isAncestor(final FileName ancestor) {\n", 
            "+        if (!ancestor.getRootURI().equals(getRootURI())) {\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+        return checkName(ancestor.getPath(), getPath(), NameScope.DESCENDENT);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Determines if another file name is a descendent of this file name.\n", 
            "+     *\n", 
            "+     * @param descendent The FileName to check.\n", 
            "+     * @return true if the FileName is a descendent, false otherwise.\n", 
            "+     */\n", 
            "+    public boolean isDescendent(final FileName descendent) {\n", 
            "+        return isDescendent(descendent, NameScope.DESCENDENT);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Determines if another file name is a descendent of this file name.\n", 
            "+     *\n", 
            "+     * @param descendent The FileName to check.\n", 
            "+     * @param scope      The NameScope.\n", 
            "+     * @return true if the FileName is a descendent, false otherwise.\n", 
            "+     */\n", 
            "+    public boolean isDescendent(final FileName descendent,\n", 
            "+                                final NameScope scope) {\n", 
            "+        if (!descendent.getRootURI().equals(getRootURI())) {\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+        return checkName(getPath(), descendent.getPath(), scope);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the requested or current type of this name. <br />\n", 
            "+     * <p>\n", 
            "+     * The \"requested\" type is the one determined during resolving the name. <br/>\n", 
            "+     * In this case the name is a {@link FileType#FOLDER} if it ends with an \"/\" else\n", 
            "+     * it will be a {@link FileType#FILE}<br/>\n", 
            "+     * </p>\n", 
            "+     * <p>\n", 
            "+     * Once attached it will be changed to reflect the real type of this resource.\n", 
            "+     * </p>\n", 
            "+     *\n", 
            "+     * @return {@link FileType#FOLDER} or {@link FileType#FILE}\n", 
            "+     */\n", 
            "+    public FileType getType() {\n", 
            "+        return type;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * sets the type of this file e.g. when it will be attached.\n", 
            "+     *\n", 
            "+     * @param type {@link FileType#FOLDER} or {@link FileType#FILE}\n", 
            "+     * @throws FileSystemException if an error occurs.\n", 
            "+     */\n", 
            "+    void setType(FileType type) throws FileSystemException {\n", 
            "+        if (type != FileType.FOLDER && type != FileType.FILE && type != FileType.FILE_OR_FOLDER) {\n", 
            "+            throw new FileSystemException(\"vfs.provider/filename-type.error\");\n", 
            "+        }\n", 
            "+\n", 
            "+        this.type = type;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Checks whether a path fits in a particular scope of another path.\n", 
            "+     *\n", 
            "+     * @param basePath An absolute, normalised path.\n", 
            "+     * @param path     An absolute, normalised path.\n", 
            "+     * @param scope    The NameScope.\n", 
            "+     * @return true if the path fits in the scope, false otherwise.\n", 
            "+     */\n", 
            "+    public static boolean checkName(final String basePath,\n", 
            "+                                    final String path,\n", 
            "+                                    final NameScope scope) {\n", 
            "+        if (scope == NameScope.FILE_SYSTEM) {\n", 
            "+            // All good\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+\n", 
            "+        if (!path.startsWith(basePath)) {\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+\n", 
            "+        int baseLen = basePath.length();\n", 
            "+        if (VFS.isUriStyle()) {\n", 
            "+            // strip the trailing \"/\"\n", 
            "+            baseLen--;\n", 
            "+        }\n", 
            "+\n", 
            "+        if (scope == NameScope.CHILD) {\n", 
            "+            if (path.length() == baseLen\n", 
            "+                    || (baseLen > 1 && path.charAt(baseLen) != SEPARATOR_CHAR)\n", 
            "+                    || path.indexOf(SEPARATOR_CHAR, baseLen + 1) != -1) {\n", 
            "+                return false;\n", 
            "+            }\n", 
            "+        } else if (scope == NameScope.DESCENDENT) {\n", 
            "+            if (path.length() == baseLen\n", 
            "+                    || (baseLen > 1 && path.charAt(baseLen) != SEPARATOR_CHAR)) {\n", 
            "+                return false;\n", 
            "+            }\n", 
            "+        } else if (scope == NameScope.DESCENDENT_OR_SELF) {\n", 
            "+            if (baseLen > 1\n", 
            "+                    && path.length() > baseLen\n", 
            "+                    && path.charAt(baseLen) != SEPARATOR_CHAR) {\n", 
            "+                return false;\n", 
            "+            }\n", 
            "+        } else if (scope != NameScope.FILE_SYSTEM) {\n", 
            "+            throw new IllegalArgumentException();\n", 
            "+        }\n", 
            "+\n", 
            "+        return true;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/patches/src/main/java/org/apache/commons/vfs2/provider/AbstractFileName.java", 
      "from": "java/modules/patches/src/main/java/org/apache/commons/vfs2/provider/AbstractFileName.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,75", 
          "lines": [
            "+/*\n", 
            "+ * Licensed to the Apache Software Foundation (ASF) under one or more\n", 
            "+ * contributor license agreements.  See the NOTICE file distributed with\n", 
            "+ * this work for additional information regarding copyright ownership.\n", 
            "+ * The ASF licenses this file to You under the Apache License, Version 2.0\n", 
            "+ * (the \"License\"); you may not use this file except in compliance with\n", 
            "+ * the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.commons.vfs2.provider.ftp;\n", 
            "+\n", 
            "+import org.apache.commons.vfs2.provider.*;\n", 
            "+import org.apache.commons.vfs2.FileName;\n", 
            "+import org.apache.commons.vfs2.FileSystemException;\n", 
            "+import org.apache.commons.vfs2.FileType;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Implementation for ftp. set default port to 21\n", 
            "+ * @author <a href=\"http://commons.apache.org/vfs/team-list.html\">Commons VFS team</a>\n", 
            "+ * PATCH for  : https://issues.apache.org/jira/browse/VFS-178\n", 
            "+ */\n", 
            "+public class FtpFileNameParser extends HostFileNameParser\n", 
            "+{\n", 
            "+    private static final FtpFileNameParser INSTANCE = new FtpFileNameParser();\n", 
            "+\n", 
            "+    private static final int PORT = 21;\n", 
            "+\n", 
            "+    public FtpFileNameParser()\n", 
            "+    {\n", 
            "+        super(PORT);\n", 
            "+    }\n", 
            "+\n", 
            "+    public static FileNameParser getInstance()\n", 
            "+    {\n", 
            "+        return INSTANCE;\n", 
            "+    }\n", 
            "+\n", 
            "+    public FileName parseUri(final VfsComponentContext context, FileName base, final String filename) throws FileSystemException {\n", 
            "+        // FTP URI are generic URI (as per RFC 2396)\n", 
            "+        final StringBuilder name = new StringBuilder();\n", 
            "+\n", 
            "+        // Extract the scheme and authority parts\n", 
            "+        final Authority auth = extractToPath(filename, name);\n", 
            "+\n", 
            "+        // Extract the queryString\n", 
            "+        String queryString = UriParser.extractQueryString(name);\n", 
            "+        if (queryString == null && base instanceof URLFileName) {\n", 
            "+            queryString = ((URLFileName) base).getQueryString();\n", 
            "+        }\n", 
            "+\n", 
            "+        // Decode and normalise the file name\n", 
            "+        UriParser.canonicalizePath(name, 0, name.length(), this);\n", 
            "+        UriParser.fixSeparators(name);\n", 
            "+        FileType fileType = UriParser.normalisePath(name);\n", 
            "+        final String path = name.toString();\n", 
            "+\n", 
            "+        return new URLFileName(\n", 
            "+            auth.getScheme(),\n", 
            "+            auth.getHostName(),\n", 
            "+            auth.getPort(),\n", 
            "+            getDefaultPort(),\n", 
            "+            auth.getUserName(),\n", 
            "+            auth.getPassword(),\n", 
            "+            path,\n", 
            "+            fileType,\n", 
            "+            queryString);\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/patches/src/main/java/org/apache/commons/vfs2/provider/ftp/FtpFileNameParser.java", 
      "from": "java/modules/patches/src/main/java/org/apache/commons/vfs2/provider/ftp/FtpFileNameParser.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,129", 
          "lines": [
            "+/*\n", 
            "+ * Licensed to the Apache Software Foundation (ASF) under one or more\n", 
            "+ * contributor license agreements.  See the NOTICE file distributed with\n", 
            "+ * this work for additional information regarding copyright ownership.\n", 
            "+ * The ASF licenses this file to You under the Apache License, Version 2.0\n", 
            "+ * (the \"License\"); you may not use this file except in compliance with\n", 
            "+ * the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *      http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.commons.vfs2.provider.ftp;\n", 
            "+\n", 
            "+import java.util.Arrays;\n", 
            "+import java.util.Collection;\n", 
            "+import java.util.Collections;\n", 
            "+import java.util.StringTokenizer;\n", 
            "+\n", 
            "+import org.apache.commons.vfs2.Capability;\n", 
            "+import org.apache.commons.vfs2.FileName;\n", 
            "+import org.apache.commons.vfs2.FileSystem;\n", 
            "+import org.apache.commons.vfs2.FileSystemConfigBuilder;\n", 
            "+import org.apache.commons.vfs2.FileSystemException;\n", 
            "+import org.apache.commons.vfs2.FileSystemOptions;\n", 
            "+import org.apache.commons.vfs2.UserAuthenticationData;\n", 
            "+import org.apache.commons.vfs2.provider.AbstractOriginatingFileProvider;\n", 
            "+import org.apache.commons.vfs2.provider.URLFileName;\n", 
            "+\n", 
            "+/**\n", 
            "+ * A provider for FTP file systems.\n", 
            "+ * PATCH for  : https://issues.apache.org/jira/browse/VFS-178\n", 
            "+ * @author <a href=\"http://commons.apache.org/vfs/team-list.html\">Commons VFS team</a>\n", 
            "+ */\n", 
            "+public class FtpFileProvider\n", 
            "+    extends AbstractOriginatingFileProvider\n", 
            "+{\n", 
            "+    /**\n", 
            "+     * File Entry Parser.\n", 
            "+     */\n", 
            "+    public static final String ATTR_FILE_ENTRY_PARSER = \"FEP\";\n", 
            "+    public final static String PASSIVE_MODE = \"vfs.passive\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Authenticator types.\n", 
            "+     */\n", 
            "+    public static final UserAuthenticationData.Type[] AUTHENTICATOR_TYPES = new UserAuthenticationData.Type[]\n", 
            "+        {\n", 
            "+            UserAuthenticationData.USERNAME, UserAuthenticationData.PASSWORD\n", 
            "+        };\n", 
            "+\n", 
            "+    static final Collection<Capability> capabilities = Collections.unmodifiableCollection(Arrays.asList(new Capability[]\n", 
            "+    {\n", 
            "+        Capability.CREATE,\n", 
            "+        Capability.DELETE,\n", 
            "+        Capability.RENAME,\n", 
            "+        Capability.GET_TYPE,\n", 
            "+        Capability.LIST_CHILDREN,\n", 
            "+        Capability.READ_CONTENT,\n", 
            "+        Capability.GET_LAST_MODIFIED,\n", 
            "+        Capability.URI,\n", 
            "+        Capability.WRITE_CONTENT,\n", 
            "+        Capability.APPEND_CONTENT,\n", 
            "+        Capability.RANDOM_ACCESS_READ,\n", 
            "+    }));\n", 
            "+\n", 
            "+    public FtpFileProvider()\n", 
            "+    {\n", 
            "+        super();\n", 
            "+        setFileNameParser(FtpFileNameParser.getInstance());\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Creates the filesystem.\n", 
            "+     */\n", 
            "+    @Override\n", 
            "+    protected FileSystem doCreateFileSystem(final FileName name, final FileSystemOptions fileSystemOptions)\n", 
            "+        throws FileSystemException\n", 
            "+    {\n", 
            "+        // Create the file system\n", 
            "+        final URLFileName rootName = (URLFileName) name;\n", 
            "+\n", 
            "+              String queryString = rootName.getQueryString();\n", 
            "+        FileSystemOptions opts = fileSystemOptions;\n", 
            "+        if (opts == null) {\n", 
            "+            opts = new FileSystemOptions();\n", 
            "+        }\n", 
            "+\n", 
            "+        if (queryString != null) {\n", 
            "+            FtpFileSystemConfigBuilder cfgBuilder = FtpFileSystemConfigBuilder.getInstance();\n", 
            "+\n", 
            "+            StringTokenizer st = new StringTokenizer(queryString, \"?&!=\");\n", 
            "+            while (st.hasMoreTokens()) {\n", 
            "+                if (PASSIVE_MODE.equalsIgnoreCase(st.nextToken()) &&\n", 
            "+                    st.hasMoreTokens() && \"true\".equalsIgnoreCase(st.nextToken())) {\n", 
            "+                    cfgBuilder.setPassiveMode(opts, true);\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        FTPClientWrapper ftpClient = new FTPClientWrapper(rootName, opts);\n", 
            "+\n", 
            "+        /*\n", 
            "+        FTPClient ftpClient = FtpClientFactory.createConnection(rootName.getHostName(),\n", 
            "+            rootName.getPort(),\n", 
            "+            rootName.getUserName(),\n", 
            "+            rootName.getPassword(),\n", 
            "+            rootName.getPath(),\n", 
            "+            fileSystemOptions);\n", 
            "+        */\n", 
            "+\n", 
            "+        return new FtpFileSystem(rootName, ftpClient, fileSystemOptions);\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public FileSystemConfigBuilder getConfigBuilder()\n", 
            "+    {\n", 
            "+        return FtpFileSystemConfigBuilder.getInstance();\n", 
            "+    }\n", 
            "+\n", 
            "+    public Collection<Capability> getCapabilities()\n", 
            "+    {\n", 
            "+        return capabilities;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/patches/src/main/java/org/apache/commons/vfs2/provider/ftp/FtpFileProvider.java", 
      "from": "java/modules/patches/src/main/java/org/apache/commons/vfs2/provider/ftp/FtpFileProvider.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-18,9 +18,9", 
          "lines": [
            "   ~  under the License.\n", 
            "   -->\n", 
            " <project\n", 
            "-    xmlns=\"http://maven.apache.org/POM/4.0.0\"\n", 
            "-    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n", 
            "-    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n", 
            "+        xmlns=\"http://maven.apache.org/POM/4.0.0\"\n", 
            "+        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n", 
            "+        xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n", 
            "     <modelVersion>4.0.0</modelVersion>\n", 
            "     <parent>\n", 
            "         <groupId>org.apache.synapse</groupId>\n"
          ]
        }, 
        {
          "locn": "-32,13 +32,30", 
          "lines": [
            "     <packaging>jar</packaging>\n", 
            "     <name>Apache Synapse - Patches</name>\n", 
            "     <description>\n", 
            "-        Contains patches for dependencies of Synapse. The project's main artifact is a JAR file\n", 
            "-        containing all the patched classes. It also attaches a ZIP file with the individual JAR\n", 
            "-        files.\n", 
            "+        Automatically generates patches for dependencies of Synapse. The required source code should\n", 
            "+        be included with a dependency to the original dependency. It also attaches a ZIP file with\n", 
            "+        the individual JAR files.\n", 
            "     </description>\n", 
            "+\n", 
            "     <build>\n", 
            "         <plugins>\n", 
            "             <plugin>\n", 
            "+                <groupId>org.apache.maven.plugins</groupId>\n", 
            "+                <artifactId>maven-jar-plugin</artifactId>\n", 
            "+                <version>2.3.2</version>\n", 
            "+                <executions>\n", 
            "+                    <execution>\n", 
            "+                        <phase>process-classes</phase>\n", 
            "+                        <goals>\n", 
            "+                            <goal>jar</goal>\n", 
            "+                        </goals>\n", 
            "+                        <configuration>\n", 
            "+                            <outputDirectory>./jars</outputDirectory>\n", 
            "+                        </configuration>\n", 
            "+                    </execution>\n", 
            "+                </executions>\n", 
            "+            </plugin>\n", 
            "+            <plugin>\n", 
            "                 <artifactId>maven-antrun-plugin</artifactId>\n", 
            "                 <executions>\n", 
            "                     <execution>\n"
          ]
        }, 
        {
          "locn": "-78,4 +95,11", 
          "lines": [
            "             </plugin>\n", 
            "         </plugins>\n", 
            "     </build>\n", 
            "+    <dependencies>\n", 
            "+        <dependency>\n", 
            "+            <groupId>org.apache.commons</groupId>\n", 
            "+            <artifactId>commons-vfs2</artifactId>\n", 
            "+            <version>${commons.vfs.version}</version>\n", 
            "+        </dependency>\n", 
            "+    </dependencies>\n", 
            " </project>\n"
          ]
        }
      ], 
      "to": "java/modules/patches/pom.xml", 
      "from": "java/modules/patches/pom.xml"
    }
  ], 
  "id": "1214337"
}