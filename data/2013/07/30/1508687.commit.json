{
  "when": "2013-07-30T19:57:48-04:00", 
  "message": "Adding OCSP and CRL support to the NHTTP and pass through transports - Applying the patch for SYNAPSE-954 with some modifications.", 
  "who": "hiranya", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-0,0 +1,138", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.utils.sslcert;\n", 
            "+\n", 
            "+import junit.framework.TestCase;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.crl.CRLCache;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.crl.CRLVerifier;import org.bouncycastle.asn1.DERObjectIdentifier;\n", 
            "+import org.bouncycastle.asn1.x509.*;\n", 
            "+import org.bouncycastle.x509.X509V2CRLGenerator;\n", 
            "+import org.bouncycastle.x509.X509V3CertificateGenerator;\n", 
            "+import org.bouncycastle.x509.extension.AuthorityKeyIdentifierStructure;\n", 
            "+\n", 
            "+import java.lang.reflect.Method;\n", 
            "+import java.math.BigInteger;\n", 
            "+import java.security.*;\n", 
            "+import java.security.cert.X509CRL;\n", 
            "+import java.security.cert.X509Certificate;\n", 
            "+import java.util.Date;\n", 
            "+import java.util.List;\n", 
            "+\n", 
            "+public class CRLVerifierTest extends TestCase {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * To test CRLVerifier behaviour when a revoked certificate is given, a fake certificate will be created, signed\n", 
            "+     * by a fake root certificate. To make our life easy, the CrlDistributionPoint extension will be extracted from\n", 
            "+     * the real peer certificate in resources directory and copied to the fake certificate as a certificate extension.\n", 
            "+     * So the criDistributionPointURL in the fake certificate will be the same as in the real certificate.\n", 
            "+     * The created X509CRL object will be put to CRLCache against the criDistributionPointURL. Since the crl is in the\n", 
            "+     * cache, there will NOT be a remote call to the CRL server at criDistributionPointURL.\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    public void testRevokedCertificate() throws Exception {\n", 
            "+\n", 
            "+        //Add BouncyCastle as Security Provider.\n", 
            "+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n", 
            "+\n", 
            "+        Utils utils = new Utils();\n", 
            "+        //Create X509Certificate from the real certificate file in resource folder.\n", 
            "+        X509Certificate realPeerCertificate = utils.getRealPeerCertificate();\n", 
            "+        //Extract crlDistributionPointUrl from the real peer certificate.\n", 
            "+        String crlDistributionPointUrl = getCRLDistributionPointUrl(realPeerCertificate);\n", 
            "+\n", 
            "+        //Create fake CA certificate.\n", 
            "+        KeyPair caKeyPair = utils.generateRSAKeyPair();\n", 
            "+        X509Certificate fakeCACert = utils.generateFakeRootCert(caKeyPair);\n", 
            "+\n", 
            "+        //Create fake peer certificate signed by the fake CA private key. This will be a revoked certificate.\n", 
            "+        KeyPair peerKeyPair = utils.generateRSAKeyPair();\n", 
            "+        BigInteger revokedSerialNumber = BigInteger.valueOf(111);\n", 
            "+        X509Certificate fakeRevokedCertificate = generateFakePeerCert(revokedSerialNumber, peerKeyPair.getPublic(),\n", 
            "+                caKeyPair.getPrivate(), fakeCACert, realPeerCertificate);\n", 
            "+\n", 
            "+        //Create a crl with fakeRevokedCertificate marked as revoked.\n", 
            "+        X509CRL x509CRL = createCRL(fakeCACert, caKeyPair.getPrivate(), revokedSerialNumber);\n", 
            "+\n", 
            "+        CRLCache cache = CRLCache.getCache();\n", 
            "+        cache.init(5, 5);\n", 
            "+        cache.setCacheValue(crlDistributionPointUrl, x509CRL);\n", 
            "+\n", 
            "+        CRLVerifier crlVerifier  = new CRLVerifier(cache);\n", 
            "+        RevocationStatus status = crlVerifier.checkRevocationStatus(fakeRevokedCertificate, null);\n", 
            "+\n", 
            "+        //the fake crl we created will be checked if the fake certificate is revoked. So the status should be REVOKED.\n", 
            "+        assertTrue(status == RevocationStatus.REVOKED);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This will use Reflection to call getCrlDistributionPoints() private method in CRLVerifier.\n", 
            "+     * @param certificate is a certificate with a proper CRLDistributionPoints extension.\n", 
            "+     * @return the extracted cRLDistributionPointUrl.\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    private String getCRLDistributionPointUrl(X509Certificate certificate) throws Exception {\n", 
            "+\n", 
            "+        CRLVerifier crlVerifier = new CRLVerifier(null);\n", 
            "+        // use reflection since getCrlDistributionPoints() is private.\n", 
            "+        Class<? extends CRLVerifier> crlVerifierClass = crlVerifier.getClass();\n", 
            "+        Method getCrlDistributionPoints = crlVerifierClass.getDeclaredMethod(\"getCrlDistributionPoints\", X509Certificate.class);\n", 
            "+        getCrlDistributionPoints.setAccessible(true);\n", 
            "+\n", 
            "+        //getCrlDistributionPoints(..) returns a list of urls. Get the first one.\n", 
            "+        List<String> distPoints = (List<String>) getCrlDistributionPoints.invoke(crlVerifier, certificate);\n", 
            "+        return distPoints.get(0);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Creates a fake CRL for the fake CA. The fake certificate with the given revokedSerialNumber will be marked\n", 
            "+     * as Revoked in the returned CRL.\n", 
            "+     * @param caCert the fake CA certificate.\n", 
            "+     * @param caPrivateKey private key of the fake CA.\n", 
            "+     * @param revokedSerialNumber the serial number of the fake peer certificate made to be marked as revoked.\n", 
            "+     * @return the created fake CRL\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    public static X509CRL createCRL(X509Certificate caCert, PrivateKey caPrivateKey, BigInteger revokedSerialNumber)\n", 
            "+            throws Exception {\n", 
            "+\n", 
            "+        X509V2CRLGenerator crlGen = new X509V2CRLGenerator();\n", 
            "+        Date now = new Date();\n", 
            "+        crlGen.setIssuerDN(caCert.getSubjectX500Principal());\n", 
            "+        crlGen.setThisUpdate(now);\n", 
            "+        crlGen.setNextUpdate(new Date(now.getTime() + TestConstants.NEXT_UPDATE_PERIOD));\n", 
            "+        crlGen.setSignatureAlgorithm(\"SHA256WithRSAEncryption\");\n", 
            "+        crlGen.addCRLEntry(revokedSerialNumber, now, CRLReason.privilegeWithdrawn);\n", 
            "+        crlGen.addExtension(X509Extensions.AuthorityKeyIdentifier, false, new AuthorityKeyIdentifierStructure(caCert));\n", 
            "+        crlGen.addExtension(X509Extensions.CRLNumber, false, new CRLNumber(BigInteger.valueOf(1)));\n", 
            "+\n", 
            "+        return crlGen.generateX509CRL(caPrivateKey, \"BC\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public X509Certificate generateFakePeerCert(BigInteger serialNumber, PublicKey entityKey,\n", 
            "+                                                PrivateKey caKey, X509Certificate caCert, X509Certificate firstCertificate)\n", 
            "+            throws Exception {\n", 
            "+\n", 
            "+        Utils utils = new Utils();\n", 
            "+        X509V3CertificateGenerator certGen = utils.getUsableCertificateGenerator(caCert, entityKey, serialNumber);\n", 
            "+        certGen.copyAndAddExtension(new DERObjectIdentifier(X509Extensions.CRLDistributionPoints.getId()), false, firstCertificate);\n", 
            "+\n", 
            "+        return certGen.generateX509Certificate(caKey, \"BC\");\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/CRLVerifierTest.java", 
      "from": "java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/CRLVerifierTest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,134", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.utils.sslcert;\n", 
            "+\n", 
            "+import junit.framework.TestCase;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.crl.CRLCache;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.crl.CRLVerifier;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPCache;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPVerifier;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.pathvalidation.CertificatePathValidator;\n", 
            "+\n", 
            "+import java.security.Security;\n", 
            "+import java.security.cert.X509Certificate;\n", 
            "+\n", 
            "+public class RevocationVerificationTest extends TestCase {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Tests CRL Path Validation with the use of a real certificate chain. The verification process will make\n", 
            "+     * HTTP calls to remote CRL server URLs extracted from the certificates in the chain. Usually these certificates\n", 
            "+     * will not be revoked. So the path validation must be successful to pass the test. In case they are revoked\n", 
            "+     * or expired, new certificates should be added to the resources directory and Constants should be modified\n", 
            "+     * accordingly. See the interface TestConstants for expiry dates of the certificates.\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    public void testCRLPathValidation() throws Exception {\n", 
            "+        //Add BouncyCastle as Security Provider.\n", 
            "+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n", 
            "+        Utils utils = new Utils();\n", 
            "+        X509Certificate[] certificates = utils.getRealCertificateChain();\n", 
            "+        Throwable throwable = null;\n", 
            "+        try {\n", 
            "+            crlPathValidation(certificates);\n", 
            "+        } catch (CertificateVerificationException e) {\n", 
            "+            //Path Verification Should Pass. This catch block should not be called\n", 
            "+            throwable = e;\n", 
            "+        }\n", 
            "+        assertNull(throwable);\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Tests CRL path validation with fake certificates. The path validation should fail since they are fake and do not\n", 
            "+     * contain proper information.\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    public void testCRLPathValidationWithFakeCerts() throws Exception {\n", 
            "+        //Add BouncyCastle as Security Provider.\n", 
            "+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n", 
            "+        Utils utils = new Utils();\n", 
            "+        X509Certificate[] fakeCertificates = utils.getFakeCertificateChain();\n", 
            "+        Throwable throwable = null;\n", 
            "+        try {\n", 
            "+            crlPathValidation(fakeCertificates);\n", 
            "+        } catch (CertificateVerificationException e) {\n", 
            "+            //Path Verification Should fail. So this catch block should be called.\n", 
            "+            throwable = e;\n", 
            "+        }\n", 
            "+        assertNotNull(throwable);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Tests path validation with OCSP. The process makes remote HTTP requests to corresponding OCSP servers at the\n", 
            "+     * certificate authorities. The path validation must be successful to pass the test.\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    public void testOCSPPathValidation() throws Exception {\n", 
            "+        //Add BouncyCastle as Security Provider.\n", 
            "+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n", 
            "+        Utils utils = new Utils();\n", 
            "+        X509Certificate[] certificates = utils.getRealCertificateChain();\n", 
            "+        Throwable throwable = null;\n", 
            "+        try {\n", 
            "+            ocspPathValidation(certificates);\n", 
            "+        } catch (CertificateVerificationException e) {\n", 
            "+            //Path Verification Should Pass. This catch block should not be called\n", 
            "+            throwable = e;\n", 
            "+        }\n", 
            "+        assertNull(throwable);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Tests OCSP path validation with a chain of fake certificates. In order to pass the test, the path validation\n", 
            "+     * should fail since the certificates are fake and do not contain right information.\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    public void testOCSPPathValidationWithFakeCerts() throws Exception {\n", 
            "+\n", 
            "+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n", 
            "+        Utils utils = new Utils();\n", 
            "+        X509Certificate[] fackeCertificates = utils.getFakeCertificateChain();\n", 
            "+        Throwable throwable = null;\n", 
            "+        try {\n", 
            "+            ocspPathValidation(fackeCertificates);\n", 
            "+        } catch (CertificateVerificationException e) {\n", 
            "+            //Path Verification Should fail. So this catch block should be called.\n", 
            "+            throwable = e;\n", 
            "+        }\n", 
            "+        assertNotNull(throwable);\n", 
            "+    }\n", 
            "+\n", 
            "+    private void crlPathValidation(X509Certificate[] certChain) throws Exception {\n", 
            "+\n", 
            "+        CRLCache crlCache = CRLCache.getCache();\n", 
            "+        crlCache.init(5, 5);\n", 
            "+        RevocationVerifier verifier = new CRLVerifier(crlCache);\n", 
            "+        CertificatePathValidator pathValidator = new CertificatePathValidator(certChain, verifier);\n", 
            "+        pathValidator.validatePath();\n", 
            "+    }\n", 
            "+\n", 
            "+    private void ocspPathValidation(X509Certificate[] certChain) throws Exception {\n", 
            "+\n", 
            "+        OCSPCache ocspCache = OCSPCache.getCache();\n", 
            "+        ocspCache.init(5, 5);\n", 
            "+        RevocationVerifier verifier = new OCSPVerifier(ocspCache);\n", 
            "+        CertificatePathValidator pathValidator = new CertificatePathValidator(certChain, verifier);\n", 
            "+        pathValidator.validatePath();\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/RevocationVerificationTest.java", 
      "from": "java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/RevocationVerificationTest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,47", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.utils.sslcert;\n", 
            "+\n", 
            "+public interface TestConstants {\n", 
            "+\n", 
            "+    //Validity period of a fake certificate made. 1 day (in milliseconds)\n", 
            "+    final static int VALIDITY_PERIOD = 24 * 60 * 60 * 1000;\n", 
            "+    //Next update for OCSPResponse or X509CRL will be after Now + NEXT_UPDATE_PERIOD\n", 
            "+    final static int NEXT_UPDATE_PERIOD = 1000000;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The certificates in the resources folder will contain the certificates in the certificate chain from\n", 
            "+     * https://www.github.com\n", 
            "+     * These certificates are chosen because the certificate issuers support both CRL and OCSP. Read the certificates for\n", 
            "+     * more details.\n", 
            "+     *\n", 
            "+     * CAUTION: Replace the certificates if they expire or are marked as revoked by their issuers. At the moment they are\n", 
            "+     * valid. The expiry dates of the certificates are as follows:\n", 
            "+     *\n", 
            "+     * github.com                    : 09/02/2015\n", 
            "+     * DigiCertHighAssuranceEVCA-1   : 11/10/2021\n", 
            "+     * DigiCertHighAssuranceEVRootCA : 11/10/2031\n", 
            "+     */\n", 
            "+    final static String REAL_PEER_CERT = \"/org/apache/synapse/transport/utils/sslcert\" +\n", 
            "+            \"/certificates/github/github.com\";\n", 
            "+    final static String INTERMEDIATE_CERT = \"/org/apache/synapse/transport/utils/sslcert\" +\n", 
            "+            \"/certificates/github/DigiCertHighAssuranceEVCA-1\";\n", 
            "+    final static String ROOT_CERT = \"/org/apache/synapse/transport/utils/sslcert\" +\n", 
            "+            \"/certificates/github/DigiCertHighAssuranceEVRootCA\";\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/TestConstants.java", 
      "from": "java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/TestConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,171", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.utils.sslcert;\n", 
            "+\n", 
            "+import junit.framework.TestCase;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPCache;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPVerifier;\n", 
            "+import org.bouncycastle.asn1.ASN1ObjectIdentifier;\n", 
            "+import org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers;\n", 
            "+import org.bouncycastle.asn1.x509.CRLReason;\n", 
            "+import org.bouncycastle.asn1.x509.X509Extension;\n", 
            "+import org.bouncycastle.asn1.x509.X509Extensions;\n", 
            "+import org.bouncycastle.ocsp.*;\n", 
            "+import org.bouncycastle.x509.X509V3CertificateGenerator;\n", 
            "+\n", 
            "+import java.lang.reflect.Method;\n", 
            "+import java.math.BigInteger;\n", 
            "+import java.security.*;\n", 
            "+import java.security.cert.X509Certificate;\n", 
            "+import java.util.Date;\n", 
            "+import java.util.Vector;\n", 
            "+\n", 
            "+public class OCSPVerifierTest extends TestCase {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * A fake certificate signed by a fake CA is made as the revoked certificate. The created OCSP response to the\n", 
            "+     * OCSP request will say that that the fake peer certificate is revoked. The SingleResp derived from the OCSP\n", 
            "+     * response will be put in to the cache against the serial number of the fake peer certificate. Since the SingleResp\n", 
            "+     * which corresponds to the revokedSerialNumber is in the cache, there will NOT be a call to a remote OCSP server.\n", 
            "+     * Note that the serviceUrl passed to cache.setCacheValue(..) is null since it is not needed.\n", 
            "+     *\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    public void testOCSPVerifier() throws Exception{\n", 
            "+\n", 
            "+        //Add BouncyCastle as Security Provider.\n", 
            "+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n", 
            "+\n", 
            "+        Utils utils = new Utils();\n", 
            "+        //Create fake CA certificate.\n", 
            "+        KeyPair caKeyPair = utils.generateRSAKeyPair();\n", 
            "+        X509Certificate caCert = utils.generateFakeRootCert(caKeyPair);\n", 
            "+\n", 
            "+        //Create fake peer certificate signed by the fake CA private key. This will be a revoked certificate.\n", 
            "+        KeyPair peerKeyPair = utils.generateRSAKeyPair();\n", 
            "+        BigInteger revokedSerialNumber = BigInteger.valueOf(111);\n", 
            "+        X509Certificate revokedCertificate = generateFakePeerCert(revokedSerialNumber, peerKeyPair.getPublic(),\n", 
            "+                caKeyPair.getPrivate(), caCert);\n", 
            "+\n", 
            "+        //Create OCSP request to check if certificate with \"serialNumber == revokedSerialNumber\" is revoked.\n", 
            "+        OCSPReq request = getOCSPRequest(caCert,revokedSerialNumber);\n", 
            "+\n", 
            "+        //Create OCSP response saying that certificate with given serialNumber is revoked.\n", 
            "+        CertificateID revokedID = new CertificateID(CertificateID.HASH_SHA1, caCert, revokedSerialNumber);\n", 
            "+        OCSPResp response = generateOCSPResponse(request, caKeyPair.getPrivate(), caKeyPair.getPublic(), revokedID);\n", 
            "+        SingleResp singleResp = ((BasicOCSPResp)response.getResponseObject()).getResponses()[0];\n", 
            "+\n", 
            "+        OCSPCache cache = OCSPCache.getCache();\n", 
            "+        cache.init(5,5);\n", 
            "+        cache.setCacheValue(revokedSerialNumber,singleResp, request, null);\n", 
            "+\n", 
            "+        OCSPVerifier ocspVerifier= new OCSPVerifier(cache);\n", 
            "+        RevocationStatus status = ocspVerifier.checkRevocationStatus(revokedCertificate, caCert);\n", 
            "+\n", 
            "+        //the cache will have the SingleResponse derived from the OCSP response and it will be checked to see if the\n", 
            "+        //fake certificate is revoked. So the status should be REVOKED.\n", 
            "+        assertTrue(status == RevocationStatus.REVOKED);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * An OCSP request is made to be given to the fake CA. Reflection is used to call generateOCSPRequest(..) private\n", 
            "+     * method in OCSPVerifier.\n", 
            "+     *\n", 
            "+     * @param caCert the fake CA certificate.\n", 
            "+     * @param revokedSerialNumber the serial number of the certificate which needs to be checked if revoked.\n", 
            "+     * @return the created OCSP request.\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    private OCSPReq getOCSPRequest(X509Certificate caCert, BigInteger revokedSerialNumber) throws Exception{\n", 
            "+        OCSPVerifier ocspVerifier = new OCSPVerifier(null);\n", 
            "+        Class ocspVerifierClass = ocspVerifier.getClass();\n", 
            "+        Method generateOCSPRequest = ocspVerifierClass.getDeclaredMethod(\"generateOCSPRequest\", X509Certificate.class,\n", 
            "+                BigInteger.class);\n", 
            "+        generateOCSPRequest.setAccessible(true);\n", 
            "+\n", 
            "+        OCSPReq request =  (OCSPReq)generateOCSPRequest.invoke(ocspVerifier, caCert, revokedSerialNumber);\n", 
            "+        return request;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This makes the corresponding OCSP response to the OCSP request which is sent to the fake CA. If the request\n", 
            "+     * has a certificateID which is marked as revoked by the CA, the OCSP response will say that the certificate\n", 
            "+     * which is referred to by the request, is revoked.\n", 
            "+     *\n", 
            "+     * @param request the OCSP request which asks if the certificate is revoked.\n", 
            "+     * @param caPrivateKey privateKey of the fake CA.\n", 
            "+     * @param caPublicKey  publicKey of the fake CA\n", 
            "+     * @param revokedID the ID at fake CA which is checked against the certificateId in the request.\n", 
            "+     * @return the created OCSP response by the fake CA.\n", 
            "+     * @throws NoSuchProviderException\n", 
            "+     * @throws OCSPException\n", 
            "+     */\n", 
            "+    private OCSPResp generateOCSPResponse(OCSPReq request, PrivateKey caPrivateKey, PublicKey caPublicKey,\n", 
            "+                                          CertificateID revokedID) throws NoSuchProviderException, OCSPException {\n", 
            "+\n", 
            "+        BasicOCSPRespGenerator basicOCSPRespGenerator = new BasicOCSPRespGenerator(caPublicKey);\n", 
            "+        X509Extensions requestExtensions = request.getRequestExtensions();\n", 
            "+\n", 
            "+        if (requestExtensions != null) {\n", 
            "+\n", 
            "+            X509Extension extension = requestExtensions.getExtension(OCSPObjectIdentifiers.id_pkix_ocsp_nonce);\n", 
            "+\n", 
            "+            if (extension != null) {\n", 
            "+\n", 
            "+                Vector<ASN1ObjectIdentifier> oids = new Vector<ASN1ObjectIdentifier>();\n", 
            "+                Vector<X509Extension> values = new Vector<X509Extension>();\n", 
            "+\n", 
            "+                oids.add(OCSPObjectIdentifiers.id_pkix_ocsp_nonce);\n", 
            "+                values.add(extension);\n", 
            "+\n", 
            "+                basicOCSPRespGenerator.setResponseExtensions(new X509Extensions(oids, values));\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        Req[] requests = request.getRequestList();\n", 
            "+\n", 
            "+        for (Req req : requests) {\n", 
            "+\n", 
            "+            CertificateID certID = req.getCertID();\n", 
            "+\n", 
            "+            if (certID.equals(revokedID)) {\n", 
            "+\n", 
            "+                RevokedStatus revokedStatus = new RevokedStatus(new Date(), CRLReason.privilegeWithdrawn);\n", 
            "+                Date nextUpdate = new Date(new Date().getTime() + TestConstants.NEXT_UPDATE_PERIOD);\n", 
            "+                basicOCSPRespGenerator.addResponse(certID, revokedStatus , nextUpdate , null);\n", 
            "+            }\n", 
            "+            else {\n", 
            "+                basicOCSPRespGenerator.addResponse(certID, CertificateStatus.GOOD);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        BasicOCSPResp basicResp = basicOCSPRespGenerator.generate(\"SHA256WithRSA\", caPrivateKey, null, new Date(), \"BC\");\n", 
            "+        OCSPRespGenerator respGen = new OCSPRespGenerator();\n", 
            "+\n", 
            "+        return respGen.generate(OCSPRespGenerator.SUCCESSFUL, basicResp);\n", 
            "+    }\n", 
            "+\n", 
            "+    private X509Certificate generateFakePeerCert(BigInteger serialNumber, PublicKey entityKey,\n", 
            "+                                                PrivateKey caKey, X509Certificate caCert)\n", 
            "+            throws Exception {\n", 
            "+        Utils utils = new Utils();\n", 
            "+        X509V3CertificateGenerator certGen = utils.getUsableCertificateGenerator(caCert,entityKey, serialNumber);\n", 
            "+        return certGen.generateX509Certificate(caKey, \"BC\");\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/OCSPVerifierTest.java", 
      "from": "java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/OCSPVerifierTest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-77,7 +77,7", 
          "lines": [
            "  */\n", 
            " public class PassThroughHttpSender extends AbstractHandler implements TransportSender {\n", 
            " \n", 
            "-    protected Log log;\n", 
            "+    protected Log log = LogFactory.getLog(this.getClass().getName());\n", 
            " \n", 
            "     /** IOReactor used to create connections and manage them */\n", 
            "     private DefaultConnectingIOReactor ioReactor;\n"
          ]
        }, 
        {
          "locn": "-108,10 +108,6", 
          "lines": [
            "     /** The list of known hosts to go via proxy */\n", 
            "     private List<String> knownProxyHosts = new ArrayList<String>();\n", 
            " \n", 
            "-    public PassThroughHttpSender() {\n", 
            "-        log = LogFactory.getLog(this.getClass().getName());\n", 
            "-    }\n", 
            "-\n", 
            "     public void init(ConfigurationContext configurationContext,\n", 
            "                      TransportOutDescription transportOutDescription) throws AxisFault {\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-31,6 +31,9", 
          "lines": [
            " import org.apache.axis2.description.TransportOutDescription;\n", 
            " import org.apache.axis2.transport.base.ParamUtils;\n", 
            " import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationConfig;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationException;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.adaptor.SynapseAdaptorForOcspCrl;\n", 
            " \n", 
            " import javax.net.ssl.*;\n", 
            " import javax.xml.namespace.QName;\n"
          ]
        }, 
        {
          "locn": "-44,10 +47,12", 
          "lines": [
            " import java.net.SocketAddress;\n", 
            " import java.net.InetSocketAddress;\n", 
            " \n", 
            "-public class HttpCoreNIOSSLSender extends HttpCoreNIOSender{\n", 
            "+public class HttpCoreNIOSSLSender extends HttpCoreNIOSender {\n", 
            " \n", 
            "     private static final Log log = LogFactory.getLog(HttpCoreNIOSSLSender.class);\n", 
            " \n", 
            "+    private static final SynapseAdaptorForOcspCrl ocspCrl = new SynapseAdaptorForOcspCrl();\n", 
            "+\n", 
            "     protected IOEventDispatch getEventDispatch(NHttpClientEventHandler handler, SSLContext sslContext,\n", 
            "         SSLSetupHandler sslIOSessionHandler, HttpParams params,\n", 
            "         TransportOutDescription transportOut) throws AxisFault {\n"
          ]
        }, 
        {
          "locn": "-58,6 +63,7", 
          "lines": [
            " \n", 
            "     /**\n", 
            "      * Create the SSLContext to be used by this sender\n", 
            "+     *\n", 
            "      * @param transportOut the Axis2 transport configuration\n", 
            "      * @return the SSLContext to be used\n", 
            "      */\n"
          ]
        }, 
        {
          "locn": "-98,12 +104,12", 
          "lines": [
            "     protected SSLSetupHandler getSSLSetupHandler(TransportOutDescription transportOut)\n", 
            "             throws AxisFault {\n", 
            " \n", 
            "-        final Parameter hostnameVerifier = transportOut.getParameter(\"HostnameVerifier\");\n", 
            "-        if (hostnameVerifier != null) {\n", 
            "-            return createSSLSetupHandler(hostnameVerifier.getValue().toString());\n", 
            "-        } else {\n", 
            "-            return createSSLSetupHandler(null);\n", 
            "-        }        \n", 
            "+        Parameter hostnameVerifier = transportOut.getParameter(\"HostnameVerifier\");\n", 
            "+        String hostnameVerifierValue = hostnameVerifier != null ?\n", 
            "+                hostnameVerifier.getValue().toString() : null;\n", 
            "+        Parameter revocationVerifierParam = transportOut.getParameter(\"CertificateRevocationVerifier\");\n", 
            "+        return createSSLSetupHandler(hostnameVerifierValue,\n", 
            "+                new CertificateVerificationConfig(revocationVerifierParam));\n", 
            "     }\n", 
            " \n", 
            "     /**\n"
          ]
        }, 
        {
          "locn": "-274,8 +280,8", 
          "lines": [
            "         }\n", 
            "     }\n", 
            " \n", 
            "-    private SSLSetupHandler createSSLSetupHandler(final String hostnameVerifier)\n", 
            "-            throws AxisFault {\n", 
            "+    private SSLSetupHandler createSSLSetupHandler(final String hostnameVerifier,\n", 
            "+\t\t\t\t\t\t\t\t\t\t\t\t  final CertificateVerificationConfig cvConfig) throws AxisFault {\n", 
            " \n", 
            "         return new SSLSetupHandler() {\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-292,6 +298,7", 
          "lines": [
            "                 }\n", 
            " \n", 
            "                 boolean valid = false;\n", 
            "+                //Do HostName verification.\n", 
            "                 if (hostnameVerifier != null) {\n", 
            "                     if (\"Strict\".equals(hostnameVerifier)) {\n", 
            "                         valid = HostnameVerifier.STRICT.verify(address, session);\n"
          ]
        }, 
        {
          "locn": "-307,6 +314,16", 
          "lines": [
            "                 if (!valid) {\n", 
            "                     throw new SSLException(\"Host name verification failed for host : \" + address);\n", 
            "                 }\n", 
            "+\n", 
            "+                if (cvConfig.isEnabled()) {\n", 
            "+                    try {\n", 
            "+                        ocspCrl.verifyRevocationStatus(session.getPeerCertificateChain(),\n", 
            "+                                cvConfig.getCacheSize(), cvConfig.getCacheDuration());\n", 
            "+                    } catch (CertificateVerificationException e) {\n", 
            "+                        throw new SSLException(\"Certificate chain validation failed for host : \" +\n", 
            "+                                address, e);\n", 
            "+                    }\n", 
            "+                }\n", 
            "             }\n", 
            "         };\n", 
            "     }\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSSLSender.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSSLSender.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-738,6 +738,13", 
          "lines": [
            "                 <version>${httpcore.nio.version}</version>\n", 
            "             </dependency>\n", 
            " \n", 
            "+            <!-- Bouncy Castle Library for OCSP/CRL Certificate Validation in HTTP Transports -->\n", 
            "+            <dependency>\n", 
            "+                <groupId>org.bouncycastle</groupId>\n", 
            "+                <artifactId>bcprov-jdk15on</artifactId>\n", 
            "+                <version>${bcprov.nhttp.version}</version>\n", 
            "+            </dependency>\n", 
            "+\n", 
            "             <!-- Testing -->\n", 
            "             <dependency>\n", 
            "                 <groupId>junit</groupId>\n"
          ]
        }, 
        {
          "locn": "-1124,6 +1131,7", 
          "lines": [
            "         <snmp4j.version>2.0.3</snmp4j.version>\n", 
            "         <snmp4j.agent.version>2.0.5</snmp4j.agent.version>\n", 
            "         <rabbitmq.version>3.1.2</rabbitmq.version>\n", 
            "+        <bcprov.nhttp.version>1.49</bcprov.nhttp.version>\n", 
            " \n", 
            "         <!-- dependencies of Synapse extensions module -->\n", 
            "         <wso2commons.version>1.2</wso2commons.version>\n"
          ]
        }
      ], 
      "to": "java/pom.xml", 
      "from": "java/pom.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,133", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.utils.sslcert;\n", 
            "+\n", 
            "+import org.bouncycastle.x509.X509V1CertificateGenerator;\n", 
            "+import org.bouncycastle.x509.X509V3CertificateGenerator;\n", 
            "+\n", 
            "+import javax.security.auth.x500.X500Principal;\n", 
            "+import java.io.File;\n", 
            "+import java.io.FileInputStream;\n", 
            "+import java.io.InputStream;\n", 
            "+import java.math.BigInteger;\n", 
            "+import java.security.*;\n", 
            "+import java.security.cert.CertificateFactory;\n", 
            "+import java.security.cert.X509Certificate;\n", 
            "+import java.util.Date;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Contains utility methods used by the test classes.\n", 
            "+ */\n", 
            "+public class Utils {\n", 
            "+\n", 
            "+\n", 
            "+    public X509Certificate generateFakeRootCert(KeyPair pair) throws Exception {\n", 
            "+        \n", 
            "+        X509V1CertificateGenerator  certGen = new X509V1CertificateGenerator();\n", 
            "+        certGen.setSerialNumber(BigInteger.valueOf(1));\n", 
            "+        certGen.setIssuerDN(new X500Principal(\"CN=Test CA Certificate\"));\n", 
            "+        certGen.setNotBefore(new Date(System.currentTimeMillis()));\n", 
            "+        certGen.setNotAfter(new Date(System.currentTimeMillis() + TestConstants.VALIDITY_PERIOD));\n", 
            "+        certGen.setSubjectDN(new X500Principal(\"CN=Test CA Certificate\"));\n", 
            "+        certGen.setPublicKey(pair.getPublic());\n", 
            "+        certGen.setSignatureAlgorithm(\"SHA1WithRSAEncryption\");\n", 
            "+\n", 
            "+        return certGen.generateX509Certificate(pair.getPrivate(), \"BC\");\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    public KeyPair generateRSAKeyPair() throws Exception {\n", 
            "+\n", 
            "+        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"RSA\", \"BC\");\n", 
            "+        kpGen.initialize(1024, new SecureRandom());\n", 
            "+        return kpGen.generateKeyPair();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * CRLVerifierTest and OCSPVerifierTest both will use this method. This has common code for both test classes\n", 
            "+     * in creating fake peer certificates.\n", 
            "+     * @param caCert Certificate of CA which signs the peer certificate which will be generated.\n", 
            "+     * @param peerPublicKey public key of the peer certificate which will be generated.\n", 
            "+     * @param serialNumber  serial number of the peer certificate.\n", 
            "+     * @return\n", 
            "+     */\n", 
            "+    public X509V3CertificateGenerator getUsableCertificateGenerator(X509Certificate caCert,\n", 
            "+                                                                    PublicKey peerPublicKey, BigInteger serialNumber){\n", 
            "+        X509V3CertificateGenerator certGen = new X509V3CertificateGenerator();\n", 
            "+\n", 
            "+        certGen.setSerialNumber(serialNumber);\n", 
            "+        certGen.setIssuerDN(caCert.getSubjectX500Principal());\n", 
            "+        certGen.setNotBefore(new Date(System.currentTimeMillis()));\n", 
            "+        certGen.setNotAfter(new Date(System.currentTimeMillis() + TestConstants.VALIDITY_PERIOD));\n", 
            "+        certGen.setSubjectDN(new X500Principal(\"CN=Test End Certificate\"));\n", 
            "+        certGen.setPublicKey(peerPublicKey);\n", 
            "+        certGen.setSignatureAlgorithm(\"SHA1WithRSAEncryption\");\n", 
            "+\n", 
            "+        return certGen;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Generate X509Certificate object from the peer certificate file in resources directory.\n", 
            "+     * @return the created certificate object.\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    public X509Certificate getRealPeerCertificate()throws Exception {\n", 
            "+        return createCertificateFromResourceFile(TestConstants.REAL_PEER_CERT);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Create a certificate chain from the certificates in the resources directory.\n", 
            "+     * @return created array of certificates.\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    public X509Certificate[] getRealCertificateChain() throws Exception {\n", 
            "+\n", 
            "+        X509Certificate peerCert = createCertificateFromResourceFile(TestConstants.REAL_PEER_CERT);\n", 
            "+        X509Certificate intermediateCert = createCertificateFromResourceFile(TestConstants.INTERMEDIATE_CERT);\n", 
            "+        X509Certificate rootCert = createCertificateFromResourceFile(TestConstants.ROOT_CERT);\n", 
            "+\n", 
            "+        return new X509Certificate[]{ peerCert,intermediateCert,rootCert  };\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Generates a fake certificate chain. The array will contain two certificates, the root and the peer.\n", 
            "+     * @return the created array of certificates.\n", 
            "+     * @throws Exception\n", 
            "+     */\n", 
            "+    public X509Certificate[] getFakeCertificateChain() throws Exception{\n", 
            "+\n", 
            "+        KeyPair rootKeyPair = generateRSAKeyPair();\n", 
            "+        X509Certificate rootCert = generateFakeRootCert(rootKeyPair);\n", 
            "+        KeyPair entityKeyPair = generateRSAKeyPair();\n", 
            "+        BigInteger entitySerialNum =BigInteger.valueOf(111);\n", 
            "+        X509V3CertificateGenerator certGen = getUsableCertificateGenerator(rootCert,\n", 
            "+                entityKeyPair.getPublic(), entitySerialNum);\n", 
            "+        X509Certificate entityCert = certGen.generateX509Certificate(rootKeyPair.getPrivate(), \"BC\");\n", 
            "+        return new X509Certificate[]{entityCert, rootCert};\n", 
            "+    }\n", 
            "+\n", 
            "+    private X509Certificate createCertificateFromResourceFile(String resourcePath) throws Exception{\n", 
            "+\n", 
            "+        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\", \"BC\");\n", 
            "+        File faceBookCertificateFile = new File(this.getClass().getResource(resourcePath).toURI());\n", 
            "+        InputStream in = new FileInputStream(faceBookCertificateFile);\n", 
            "+        X509Certificate certificate = (X509Certificate) certFactory.generateCertificate(in);\n", 
            "+        return certificate;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/Utils.java", 
      "from": "java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/Utils.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,32", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.cache;\n", 
            "+\n", 
            "+/**\n", 
            "+ * A cache which needs to be managed by CacheManager needs to implement this interface.\n", 
            "+ */\n", 
            "+public interface ManageableCache {\n", 
            "+\n", 
            "+    public ManageableCacheValue getNextCacheValue();\n", 
            "+\n", 
            "+    public int getCacheSize();\n", 
            "+\n", 
            "+    public void resetIterator();\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/ManageableCache.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/ManageableCache.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,55", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.cache;\n", 
            "+\n", 
            "+public class CacheController implements CacheControllerMBean{\n", 
            "+\n", 
            "+    private ManageableCache cache;\n", 
            "+    private CacheManager cacheManager;\n", 
            "+\n", 
            "+    public CacheController(ManageableCache cache, CacheManager cacheManager){\n", 
            "+        this.cache = cache;\n", 
            "+        this.cacheManager = cacheManager;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean stopCacheManager() {\n", 
            "+        return cacheManager.stop();\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean wakeUpCacheManager() {\n", 
            "+        return cacheManager.wakeUpNow();\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean changeCacheManagerDelayMins(int delay){\n", 
            "+        return cacheManager.changeDelay(delay);\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isCacheManagerRunning() {\n", 
            "+        return cacheManager.isRunning();\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getCacheSize() {\n", 
            "+        return cache.getCacheSize();\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getCacheManagerDelayMins(){\n", 
            "+        return cacheManager.getDelay();\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheController.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheController.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,57", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.cache;\n", 
            "+\n", 
            "+public interface CacheControllerMBean {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Gracefully stops a cacheManager scheduled thread.\n", 
            "+     * @return true if successfully stopped. False otherwise.\n", 
            "+     */\n", 
            "+    public boolean stopCacheManager();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Wakes up a stopped cacheManager thread.\n", 
            "+     * @return true if cacheManager is waken up. False otherwise.\n", 
            "+     */\n", 
            "+    public boolean wakeUpCacheManager();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Changes cacheManager task scheduled period.\n", 
            "+     * @param delay Delay which cacheManager thread waits to start its task again.\n", 
            "+     * @return true if successfully changed delay. False otherwise.\n", 
            "+     */\n", 
            "+    public boolean changeCacheManagerDelayMins(int delay);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * @return true if CacheManager is running. False if its stopped.\n", 
            "+     */\n", 
            "+    public boolean isCacheManagerRunning();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * @return Number of cacheEntries in the cache.\n", 
            "+     */\n", 
            "+    public int getCacheSize();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * @return cacheManager delay in minutes.\n", 
            "+     */\n", 
            "+    public int getCacheManagerDelayMins();\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheControllerMBean.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheControllerMBean.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,37", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.cache;\n", 
            "+\n", 
            "+/**\n", 
            "+ * A cache which needs to be managed by a CacheManager should have values which implement\n", 
            "+ * this interface.\n", 
            "+ */\n", 
            "+public interface ManageableCacheValue {\n", 
            "+\n", 
            "+    //To remove invalid entries from the cache.\n", 
            "+    public boolean isValid();\n", 
            "+\n", 
            "+    //To decide LRU value to replace.\n", 
            "+    public long getTimeStamp();\n", 
            "+\n", 
            "+    public void removeThisCacheValue();\n", 
            "+\n", 
            "+    public void updateCacheWithNewValue();\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/ManageableCacheValue.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/ManageableCacheValue.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,233", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.cache;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.Constants;\n", 
            "+\n", 
            "+import java.util.ArrayList;\n", 
            "+import java.util.List;\n", 
            "+import java.util.concurrent.Executors;\n", 
            "+import java.util.concurrent.ScheduledExecutorService;\n", 
            "+import java.util.concurrent.ScheduledFuture;\n", 
            "+import java.util.concurrent.TimeUnit;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Cache Manager takes care of and maintains an LRU cache which implements ManageableCache Interface.\n", 
            "+ * Delay should be configured such that cacheManager is not too much involved with the cache,\n", 
            "+ * but manages it optimally.\n", 
            "+ */\n", 
            "+\n", 
            "+public class CacheManager {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(CacheManager.class);\n", 
            "+\n", 
            "+    private final boolean DO_NOT_INTERRUPT_IF_RUNNING = false;\n", 
            "+    private ScheduledExecutorService scheduler;\n", 
            "+    private ScheduledFuture scheduledFuture = null;\n", 
            "+    private ManageableCache cache;\n", 
            "+    private int cacheMaxSize;\n", 
            "+    private int delay;\n", 
            "+    private CacheManagingTask cacheManagingTask;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * A new cacheManager will be started on the given ManageableCache object.\n", 
            "+     *\n", 
            "+     * @param cache        a Manageable Cache which could be managed by this cache manager.\n", 
            "+     * @param cacheMaxSize Maximum size of the cache. If the cache exceeds this size, LRU values\n", 
            "+     *                     will be removed\n", 
            "+     */\n", 
            "+    public CacheManager(ManageableCache cache, int cacheMaxSize, int delay) {\n", 
            "+        int NUM_THREADS = 1;\n", 
            "+        scheduler = Executors.newScheduledThreadPool(NUM_THREADS);\n", 
            "+        this.cache = cache;\n", 
            "+        this.cacheMaxSize = cacheMaxSize;\n", 
            "+        this.cacheManagingTask = new CacheManagingTask();\n", 
            "+        this.delay = delay;\n", 
            "+        start();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * To Start the CacheManager. Should be called only once per CacheManager so called in\n", 
            "+     * constructor. CacheManager will run its scheduled task every \"delay\" number of minutes.\n", 
            "+     */\n", 
            "+    private boolean start() {\n", 
            "+        if(scheduledFuture == null || (scheduledFuture.isCancelled())) {\n", 
            "+            scheduledFuture = scheduler.scheduleWithFixedDelay(cacheManagingTask,\n", 
            "+                    delay, delay, TimeUnit.MINUTES);\n", 
            "+            log.info(cache.getClass().getSimpleName()+\" Cache Manager Started\");\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+        return false;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * To wake cacheManager up at will. If this method is called while its task is running, it\n", 
            "+     * will run its task again soon after its done. CacheManagerTask will be rescheduled as before.\n", 
            "+     * @return true if successfully waken up. false otherwise.\n", 
            "+     */\n", 
            "+    public boolean wakeUpNow(){\n", 
            "+        if(scheduledFuture !=null) {\n", 
            "+            if(!scheduledFuture.isCancelled()) {\n", 
            "+                scheduledFuture.cancel(DO_NOT_INTERRUPT_IF_RUNNING);\n", 
            "+            }\n", 
            "+            scheduledFuture = scheduler.scheduleWithFixedDelay(cacheManagingTask,\n", 
            "+                    0, delay,TimeUnit.MINUTES);\n", 
            "+            log.info(cache.getClass().getSimpleName()+\" Cache Manager Wakened Up.....\");\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+        return false;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Change the cacheManager delay (schedule period) to given value.\n", 
            "+     * @param delay new delay to which the cacheManager schedule period should change.\n", 
            "+     * @return true if successfully changed. false otherwise.\n", 
            "+     * @throws IllegalArgumentException if given delay is not between the allowed limit.\n", 
            "+     */\n", 
            "+    public boolean changeDelay(int delay) throws IllegalArgumentException {\n", 
            "+        int min = Constants.CACHE_MIN_DELAY_MINS;\n", 
            "+        int max = Constants.CACHE_MAX_DELAY_MINS;\n", 
            "+        if(delay < min || delay > max) {\n", 
            "+            throw new IllegalArgumentException(\"Delay time should should be between \" + min +\n", 
            "+                    \" and \" + max + \" minutes\");\n", 
            "+        }\n", 
            "+        this.delay = delay;\n", 
            "+        return wakeUpNow();\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getDelay(){\n", 
            "+        return delay;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Gracefully stop cacheManager.\n", 
            "+     */\n", 
            "+    public boolean stop(){\n", 
            "+        if(scheduledFuture !=null && !scheduledFuture.isCancelled()){\n", 
            "+            scheduledFuture.cancel(DO_NOT_INTERRUPT_IF_RUNNING);\n", 
            "+            log.info(cache.getClass().getSimpleName()+\" Cache Manager Stopped.....\");\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+        return false;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isRunning() {\n", 
            "+        return !scheduledFuture.isCancelled();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This is the Scheduled Task the CacheManager uses in order to remove invalid cache values and\n", 
            "+     * to remove LRU values if the cache reaches cacheMaxSize.\n", 
            "+     */\n", 
            "+    private class CacheManagingTask implements Runnable {\n", 
            "+\n", 
            "+        public void run() {\n", 
            "+            long start = System.currentTimeMillis();\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(cache.getClass().getSimpleName() + \" Cache Manager Task Started.\");\n", 
            "+            }\n", 
            "+\n", 
            "+            ManageableCacheValue nextCacheValue;\n", 
            "+            //cache.getCacheSize() can vary when new entries are added. So get cache size at this point\n", 
            "+            int cacheSize = cache.getCacheSize();\n", 
            "+            int numberToRemove = (cacheSize>cacheMaxSize)?  cacheSize - cacheMaxSize: 0;\n", 
            "+\n", 
            "+            List<ManageableCacheValue> entriesToRemove = new ArrayList<ManageableCacheValue>();\n", 
            "+            LRUEntryCollector lruEntryCollector = new LRUEntryCollector(entriesToRemove, numberToRemove);\n", 
            "+\n", 
            "+            //Start looking at cache entries from the beginning.\n", 
            "+            cache.resetIterator();\n", 
            "+            //Iteration through the cache entries.\n", 
            "+            while ((cacheSize--)>0) {\n", 
            "+\n", 
            "+                nextCacheValue = cache.getNextCacheValue();\n", 
            "+                if (nextCacheValue == null) {\n", 
            "+                    log.debug(\"Cache manager iteration through Cache values done\");\n", 
            "+                    break;\n", 
            "+                }\n", 
            "+\n", 
            "+                //Updating invalid cache values\n", 
            "+                if (!nextCacheValue.isValid()) {\n", 
            "+                    log.debug(\"Updating Invalid Cache Value by Manager\");\n", 
            "+                    nextCacheValue.updateCacheWithNewValue();\n", 
            "+                }\n", 
            "+\n", 
            "+                //There are LRU entries to be removed since cacheSize > maxCacheSize. So collect them.\n", 
            "+                if(numberToRemove>0) {\n", 
            "+                    lruEntryCollector.collectEntriesToRemove(nextCacheValue);\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+            //LRU entries removing\n", 
            "+            for(ManageableCacheValue oldCacheValue: entriesToRemove) {\n", 
            "+                log.debug(\"Removing LRU value from cache\");\n", 
            "+                oldCacheValue.removeThisCacheValue();\n", 
            "+            }\n", 
            "+\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(cache.getClass().getSimpleName()+\" Cache Manager Task Done. Took \" +\n", 
            "+                        (System.currentTimeMillis() - start) + \" ms.\");\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        private class LRUEntryCollector {\n", 
            "+\n", 
            "+            private List<ManageableCacheValue> entriesToRemove;\n", 
            "+            private int listMaxSize;\n", 
            "+\n", 
            "+            LRUEntryCollector(List<ManageableCacheValue> entriesToRemove, int numberToRemove){\n", 
            "+                this.entriesToRemove = entriesToRemove;\n", 
            "+                this.listMaxSize = numberToRemove;\n", 
            "+            }\n", 
            "+\n", 
            "+            /**\n", 
            "+             * This method collects the listMaxSize number of LRU values from the Cache. This is\n", 
            "+             * called for all the entries in the cache. But only listMaxSize number of LRU entries\n", 
            "+             * will be collected in entriesToRemove list. These collected values will be removed from\n", 
            "+             * the cache. This uses a part of the Logic in Insertion Sort.\n", 
            "+             *\n", 
            "+             * @param value to be collected if LRU.\n", 
            "+             */\n", 
            "+            private void collectEntriesToRemove(ManageableCacheValue value) {\n", 
            "+\n", 
            "+                entriesToRemove.add(value);\n", 
            "+                int i = entriesToRemove.size()-1;\n", 
            "+\n", 
            "+                for(; i>0 && (value.getTimeStamp() < entriesToRemove.get(i-1).getTimeStamp()); i--) {\n", 
            "+                    entriesToRemove.remove(i);\n", 
            "+                    entriesToRemove.add(i,(entriesToRemove.get(i-1)));\n", 
            "+                }\n", 
            "+                entriesToRemove.remove(i);\n", 
            "+                entriesToRemove.add(i,value);\n", 
            "+                /**\n", 
            "+                 * First entry in the list will be the oldest. Last will be the earliest in the list.\n", 
            "+                 * So remove the earliest since we need to collect the old (LRU) values to remove\n", 
            "+                 * from cache later\n", 
            "+                 */\n", 
            "+                if(entriesToRemove.size() > listMaxSize) {\n", 
            "+                    entriesToRemove.remove(entriesToRemove.size() -1);\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheManager.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheManager.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,35", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert;\n", 
            "+\n", 
            "+public class CertificateVerificationException extends Exception {\n", 
            "+\n", 
            "+    public CertificateVerificationException(String message) {\n", 
            "+        super(message);\n", 
            "+    }\n", 
            "+\n", 
            "+    public CertificateVerificationException(Throwable throwable) {\n", 
            "+        super(throwable);\n", 
            "+    }\n", 
            "+\n", 
            "+    public CertificateVerificationException(String message, Throwable throwable) {\n", 
            "+        super(message, throwable);\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/CertificateVerificationException.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/CertificateVerificationException.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,231", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.ocsp;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.commons.jmx.MBeanRegistrar;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationException;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.cache.CacheController;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.cache.CacheManager;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.cache.ManageableCache;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.cache.ManageableCacheValue;\n", 
            "+import org.bouncycastle.ocsp.*;\n", 
            "+\n", 
            "+import java.math.BigInteger;\n", 
            "+import java.util.Date;\n", 
            "+import java.util.Iterator;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.concurrent.ConcurrentHashMap;\n", 
            "+\n", 
            "+/**\n", 
            "+ * This is a cache to store OCSP responses against Certificate Serial Number since an OCSP\n", 
            "+ * response depends on the certificate. This is a singleton since more than one cache of this\n", 
            "+ * kind should not be allowed. This cache can be shared by many transports which need SSL\n", 
            "+ * validation through OCSP.\n", 
            "+ */\n", 
            "+public class OCSPCache implements ManageableCache {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(OCSPCache.class);\n", 
            "+\n", 
            "+    private static final OCSPCache cache = new OCSPCache();\n", 
            "+    private final Map<BigInteger,OCSPCacheValue> hashMap;\n", 
            "+    private Iterator<Map.Entry<BigInteger,OCSPCacheValue>> iterator;\n", 
            "+    private volatile CacheManager cacheManager;\n", 
            "+    private final OCSPVerifier ocspVerifier;\n", 
            "+\n", 
            "+    private OCSPCache() {\n", 
            "+        this.hashMap = new ConcurrentHashMap<BigInteger, OCSPCacheValue>();\n", 
            "+        this.iterator = hashMap.entrySet().iterator();\n", 
            "+        this.ocspVerifier = new OCSPVerifier(null);\n", 
            "+    }\n", 
            "+\n", 
            "+    public static OCSPCache getCache() {\n", 
            "+        return cache;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This lazy initializes the Cache with a CacheManager. If this method is not called, a cache manager will not be used.\n", 
            "+     * @param size max size of the cache\n", 
            "+     * @param delay defines how frequently the CacheManager will be started\n", 
            "+     */\n", 
            "+    public void init(int size, int delay) {\n", 
            "+        if (cacheManager == null) {\n", 
            "+            synchronized (OCSPCache.class) {\n", 
            "+                if (cacheManager == null) {\n", 
            "+                    cacheManager = new CacheManager(cache, size, delay);\n", 
            "+                    CacheController mbean = new CacheController(cache,cacheManager);\n", 
            "+                    MBeanRegistrar.getInstance().registerMBean(mbean, \"CacheController\", \"OCSPCacheController\");\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This method is needed by the cache Manager to go through the cache entries to remove invalid values or\n", 
            "+     * to remove LRU cache values if the cache has reached its max size.\n", 
            "+     * Todo: Can move to an abstract class.\n", 
            "+     * @return next cache value of the cache.\n", 
            "+     */\n", 
            "+    public ManageableCacheValue getNextCacheValue() {\n", 
            "+        //Changes to the hash map are reflected on the keySet. And its iterator is weakly consistent. so will never\n", 
            "+        //throw concurrent modification exception.\n", 
            "+        if (iterator.hasNext()) {\n", 
            "+            return hashMap.get(iterator.next().getKey());\n", 
            "+        } else {\n", 
            "+            resetIterator();\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * @return the current cache size (size of the hash map)\n", 
            "+     */\n", 
            "+    public int getCacheSize() {\n", 
            "+        return hashMap.size();\n", 
            "+    }\n", 
            "+\n", 
            "+    public void resetIterator(){\n", 
            "+        iterator = hashMap.entrySet().iterator();\n", 
            "+    }\n", 
            "+\n", 
            "+    // This has to be synchronized coz several threads will try to replace cache value\n", 
            "+    // (cacheManager and Reactor thread)\n", 
            "+    private synchronized void replaceNewCacheValue(OCSPCacheValue cacheValue){\n", 
            "+        //If someone has updated with the new value before current Thread.\n", 
            "+        if (cacheValue.isValid()) {\n", 
            "+            return;\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            String serviceUrl = cacheValue.serviceUrl;\n", 
            "+            OCSPReq request = cacheValue.request;\n", 
            "+            OCSPResp response= ocspVerifier.getOCSPResponce(serviceUrl, request);\n", 
            "+\n", 
            "+            if (OCSPRespStatus.SUCCESSFUL != response.getStatus())\n", 
            "+                throw new CertificateVerificationException(\"OCSP response status not SUCCESSFUL\");\n", 
            "+\n", 
            "+            BasicOCSPResp basicResponse = (BasicOCSPResp) response.getResponseObject();\n", 
            "+            SingleResp[] responses = (basicResponse == null) ? null : basicResponse.getResponses();\n", 
            "+\n", 
            "+            if (responses == null)\n", 
            "+                throw new CertificateVerificationException(\"Cant get OCSP response\");\n", 
            "+\n", 
            "+            SingleResp resp = responses[0];\n", 
            "+            this.setCacheValue(cacheValue.serialNumber, resp, request, serviceUrl);\n", 
            "+\n", 
            "+        } catch (Exception e){\n", 
            "+            log.debug(\"Cant replace old CacheValue with new CacheValue. So remove\", e);\n", 
            "+            //If cant be replaced remove.\n", 
            "+            cacheValue.removeThisCacheValue();\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public synchronized SingleResp getCacheValue(BigInteger serialNumber) {\n", 
            "+        OCSPCacheValue cacheValue = hashMap.get(serialNumber);\n", 
            "+        if(cacheValue != null) {\n", 
            "+            //If who ever gets this cache value before Cache manager task found its invalid, update it and get the\n", 
            "+            // new value.\n", 
            "+            if (!cacheValue.isValid()) {\n", 
            "+                cacheValue.updateCacheWithNewValue();\n", 
            "+                OCSPCacheValue ocspCacheValue = hashMap.get(serialNumber);\n", 
            "+                return (ocspCacheValue!=null? ocspCacheValue.getValue(): null);\n", 
            "+            }\n", 
            "+\n", 
            "+            return cacheValue.getValue();\n", 
            "+        }\n", 
            "+        else\n", 
            "+            return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    public synchronized void setCacheValue(BigInteger serialNumber, SingleResp singleResp, OCSPReq request, String serviceUrl) {\n", 
            "+        OCSPCacheValue cacheValue = new OCSPCacheValue(serialNumber, singleResp, request, serviceUrl);\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Before set - HashMap size \" + hashMap.size());\n", 
            "+        }\n", 
            "+        hashMap.put(serialNumber, cacheValue);\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"After set - HashMap size \" + hashMap.size());\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public synchronized void removeCacheValue(BigInteger serialNumber) {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Before remove - HashMap size \" + hashMap.size());\n", 
            "+        }\n", 
            "+        hashMap.remove(serialNumber);\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"After remove - HashMap size \" + hashMap.size());\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This is the wrapper class of the actual cache value which is a SingleResp.\n", 
            "+     */\n", 
            "+    private class OCSPCacheValue implements ManageableCacheValue {\n", 
            "+\n", 
            "+        private BigInteger serialNumber;\n", 
            "+        private SingleResp singleResp;\n", 
            "+        private OCSPReq request;\n", 
            "+        private String serviceUrl;\n", 
            "+        private long timeStamp = System.currentTimeMillis();\n", 
            "+\n", 
            "+        public OCSPCacheValue(BigInteger serialNumber, SingleResp singleResp, OCSPReq request, String serviceUrl) {\n", 
            "+            this.serialNumber = serialNumber;\n", 
            "+            this.singleResp = singleResp;\n", 
            "+            //request and serviceUrl are needed to update the cache with new values.\n", 
            "+            this.request = request;\n", 
            "+            this.serviceUrl = serviceUrl;\n", 
            "+        }\n", 
            "+\n", 
            "+        public BigInteger getKey() {\n", 
            "+            return serialNumber;\n", 
            "+        }\n", 
            "+\n", 
            "+        public SingleResp getValue() {\n", 
            "+            timeStamp = System.currentTimeMillis();\n", 
            "+            return singleResp;\n", 
            "+        }\n", 
            "+\n", 
            "+        /**\n", 
            "+         * An OCSP response is valid during its validity period.\n", 
            "+         */\n", 
            "+        public boolean isValid() {\n", 
            "+            Date now = new Date();\n", 
            "+            Date nextUpdate = singleResp.getNextUpdate();\n", 
            "+            return nextUpdate != null && nextUpdate.after(now);\n", 
            "+        }\n", 
            "+\n", 
            "+        public long getTimeStamp() {\n", 
            "+            return timeStamp;\n", 
            "+        }\n", 
            "+\n", 
            "+        /**\n", 
            "+         * Used by cacheManager to remove invalid entries.\n", 
            "+         */\n", 
            "+        public void removeThisCacheValue() {\n", 
            "+            removeCacheValue(serialNumber);\n", 
            "+        }\n", 
            "+\n", 
            "+        public void updateCacheWithNewValue() {\n", 
            "+            replaceNewCacheValue(this);\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/ocsp/OCSPCache.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/ocsp/OCSPCache.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,252", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.ocsp;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.bouncycastle.asn1.*;\n", 
            "+import org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers;\n", 
            "+import org.bouncycastle.asn1.x509.*;\n", 
            "+import org.bouncycastle.ocsp.*;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.*;\n", 
            "+\n", 
            "+import java.io.*;\n", 
            "+import java.math.BigInteger;\n", 
            "+import java.net.HttpURLConnection;\n", 
            "+import java.net.URL;\n", 
            "+import java.security.Security;\n", 
            "+import java.security.cert.X509Certificate;\n", 
            "+import java.util.ArrayList;\n", 
            "+import java.util.List;\n", 
            "+import java.util.Vector;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Used to check if a Certificate is revoked or not by its CA using Online Certificate\n", 
            "+ * Status Protocol (OCSP).\n", 
            "+ */\n", 
            "+public class OCSPVerifier implements RevocationVerifier {\n", 
            "+\n", 
            "+    private OCSPCache cache;\n", 
            "+    private static final Log log = LogFactory.getLog(OCSPVerifier.class);\n", 
            "+\n", 
            "+    public OCSPVerifier(OCSPCache cache) {\n", 
            "+        this.cache = cache;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Gets the revocation status (Good, Revoked or Unknown) of the given peer certificate.\n", 
            "+     *\n", 
            "+     * @param peerCert   The certificate we want to check if revoked.\n", 
            "+     * @param issuerCert Needed to create OCSP request.\n", 
            "+     * @return revocation status of the peer certificate.\n", 
            "+     * @throws CertificateVerificationException\n", 
            "+     *\n", 
            "+     */\n", 
            "+    public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert)\n", 
            "+            throws CertificateVerificationException {\n", 
            "+\n", 
            "+        //check cache\n", 
            "+        if (cache != null) {\n", 
            "+            SingleResp resp = cache.getCacheValue(peerCert.getSerialNumber());\n", 
            "+            if (resp != null) {\n", 
            "+                //If cant be casted, we have used the wrong cache.\n", 
            "+                RevocationStatus status = getRevocationStatus(resp);\n", 
            "+                log.debug(\"OCSP response taken from cache....\");\n", 
            "+                return status;\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        OCSPReq request = generateOCSPRequest(issuerCert, peerCert.getSerialNumber());\n", 
            "+        //This list will sometimes have non ocsp urls as well.\n", 
            "+        List<String> locations = getAIALocations(peerCert);\n", 
            "+\n", 
            "+        for (String serviceUrl : locations) {\n", 
            "+\n", 
            "+            SingleResp[] responses;\n", 
            "+            try {\n", 
            "+                OCSPResp ocspResponse = getOCSPResponce(serviceUrl, request);\n", 
            "+                if (OCSPRespStatus.SUCCESSFUL != ocspResponse.getStatus()) {\n", 
            "+                    continue; // Server didn't give the response right.\n", 
            "+                }\n", 
            "+\n", 
            "+                BasicOCSPResp basicResponse = (BasicOCSPResp) ocspResponse.getResponseObject();\n", 
            "+                responses = (basicResponse == null) ? null : basicResponse.getResponses();\n", 
            "+                //todo use the super exception\n", 
            "+            } catch (Exception e) {\n", 
            "+                continue;\n", 
            "+            }\n", 
            "+\n", 
            "+            if (responses != null && responses.length == 1) {\n", 
            "+                SingleResp resp = responses[0];\n", 
            "+                RevocationStatus status = getRevocationStatus(resp);\n", 
            "+                if (cache != null)\n", 
            "+                    cache.setCacheValue(peerCert.getSerialNumber(), resp, request, serviceUrl);\n", 
            "+                return status;\n", 
            "+            }\n", 
            "+        }\n", 
            "+        throw new CertificateVerificationException(\"Cant get Revocation Status from OCSP.\");\n", 
            "+    }\n", 
            "+\n", 
            "+    private RevocationStatus getRevocationStatus(SingleResp resp) throws CertificateVerificationException {\n", 
            "+        Object status = resp.getCertStatus();\n", 
            "+        if (status == CertificateStatus.GOOD) {\n", 
            "+            return RevocationStatus.GOOD;\n", 
            "+        } else if (status instanceof org.bouncycastle.ocsp.RevokedStatus) {\n", 
            "+            return RevocationStatus.REVOKED;\n", 
            "+        } else if (status instanceof org.bouncycastle.ocsp.UnknownStatus) {\n", 
            "+            return RevocationStatus.UNKNOWN;\n", 
            "+        }\n", 
            "+        throw new CertificateVerificationException(\"Cant recognize Certificate Status\");\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Gets an ASN.1 encoded OCSP response (as defined in RFC 2560) from the given service URL. Currently supports\n", 
            "+     * only HTTP.\n", 
            "+     *\n", 
            "+     * @param serviceUrl URL of the OCSP endpoint.\n", 
            "+     * @param request    an OCSP request object.\n", 
            "+     * @return OCSP response encoded in ASN.1 structure.\n", 
            "+     * @throws CertificateVerificationException\n", 
            "+     *\n", 
            "+     */\n", 
            "+    protected OCSPResp getOCSPResponce(String serviceUrl, OCSPReq request) throws CertificateVerificationException {\n", 
            "+\n", 
            "+        try {\n", 
            "+            //Todo: Use http client.\n", 
            "+            byte[] array = request.getEncoded();\n", 
            "+            if (serviceUrl.startsWith(\"http\")) {\n", 
            "+                HttpURLConnection con;\n", 
            "+                URL url = new URL(serviceUrl);\n", 
            "+                con = (HttpURLConnection) url.openConnection();\n", 
            "+                con.setRequestProperty(\"Content-Type\", \"application/ocsp-request\");\n", 
            "+                con.setRequestProperty(\"Accept\", \"application/ocsp-response\");\n", 
            "+                con.setDoOutput(true);\n", 
            "+                OutputStream out = con.getOutputStream();\n", 
            "+                DataOutputStream dataOut = new DataOutputStream(new BufferedOutputStream(out));\n", 
            "+                dataOut.write(array);\n", 
            "+\n", 
            "+                dataOut.flush();\n", 
            "+                dataOut.close();\n", 
            "+\n", 
            "+                //Check errors in response:\n", 
            "+                if (con.getResponseCode() / 100 != 2) {\n", 
            "+                    throw new CertificateVerificationException(\"Error getting ocsp response.\" +\n", 
            "+                            \"Response code is \" + con.getResponseCode());\n", 
            "+                }\n", 
            "+\n", 
            "+                //Get Response\n", 
            "+                InputStream in = (InputStream) con.getContent();\n", 
            "+                return new OCSPResp(in);\n", 
            "+            } else {\n", 
            "+                throw new CertificateVerificationException(\"Only http is supported for ocsp calls\");\n", 
            "+            }\n", 
            "+        } catch (IOException e) {\n", 
            "+            throw new CertificateVerificationException(\"Cannot get ocspResponse from url: \" + serviceUrl, e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This method generates an OCSP Request to be sent to an OCSP endpoint.\n", 
            "+     *\n", 
            "+     * @param issuerCert   is the Certificate of the Issuer of the peer certificate we are interested in.\n", 
            "+     * @param serialNumber of the peer certificate.\n", 
            "+     * @return generated OCSP request.\n", 
            "+     * @throws CertificateVerificationException\n", 
            "+     */\n", 
            "+    private OCSPReq generateOCSPRequest(X509Certificate issuerCert, BigInteger serialNumber)\n", 
            "+            throws CertificateVerificationException {\n", 
            "+\n", 
            "+        //TODO: Have to check if this is OK with synapse implementation.\n", 
            "+        //Add provider BC\n", 
            "+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n", 
            "+        try {\n", 
            "+            //  CertID structure is used to uniquely identify certificates that are the subject of\n", 
            "+            // an OCSP request or response and has an ASN.1 definition. CertID structure is defined in RFC 2560\n", 
            "+            CertificateID id = new CertificateID(CertificateID.HASH_SHA1, issuerCert, serialNumber);\n", 
            "+\n", 
            "+            // basic request generation with nonce\n", 
            "+            OCSPReqGenerator generator = new OCSPReqGenerator();\n", 
            "+            generator.addRequest(id);\n", 
            "+\n", 
            "+            // create details for nonce extension. The nonce extension is used to bind\n", 
            "+            // a request to a response to prevent replay attacks. As the name implies,\n", 
            "+            // the nonce value is something that the client should only use once within a reasonably small period.\n", 
            "+            BigInteger nonce = BigInteger.valueOf(System.currentTimeMillis());\n", 
            "+            Vector<ASN1ObjectIdentifier> objectIdentifiers = new Vector<ASN1ObjectIdentifier>();\n", 
            "+            Vector<X509Extension> values = new Vector<X509Extension>();\n", 
            "+\n", 
            "+            //to create the request Extension\n", 
            "+            objectIdentifiers.add(OCSPObjectIdentifiers.id_pkix_ocsp_nonce);\n", 
            "+            values.add(new X509Extension(false, new DEROctetString(nonce.toByteArray())));\n", 
            "+            generator.setRequestExtensions(new X509Extensions(objectIdentifiers, values));\n", 
            "+\n", 
            "+            return generator.generate();\n", 
            "+        } catch (OCSPException e) {\n", 
            "+            throw new CertificateVerificationException(\"Cannot generate OSCP Request with the given certificate\", e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Authority Information Access (AIA) is a non-critical extension in an X509 Certificate. This contains the\n", 
            "+     * URL of the OCSP endpoint if one is available.\n", 
            "+     * TODO: This might contain non OCSP urls as well. Handle this.\n", 
            "+     *\n", 
            "+     * @param cert is the certificate\n", 
            "+     * @return a lit of URLs in AIA extension of the certificate which will hopefully contain an OCSP endpoint.\n", 
            "+     * @throws CertificateVerificationException\n", 
            "+     *\n", 
            "+     */\n", 
            "+    private List<String> getAIALocations(X509Certificate cert) throws CertificateVerificationException {\n", 
            "+\n", 
            "+        //Gets the DER-encoded OCTET string for the extension value for Authority information access Points\n", 
            "+        byte[] aiaExtensionValue = cert.getExtensionValue(X509Extensions.AuthorityInfoAccess.getId());\n", 
            "+        if (aiaExtensionValue == null)\n", 
            "+            throw new CertificateVerificationException(\"Certificate Doesnt have Authority Information Access points\");\n", 
            "+        //might have to pass an ByteArrayInputStream(aiaExtensionValue)\n", 
            "+        ASN1InputStream asn1In = new ASN1InputStream(aiaExtensionValue);\n", 
            "+        AuthorityInformationAccess authorityInformationAccess;\n", 
            "+\n", 
            "+        try {\n", 
            "+            DEROctetString aiaDEROctetString = (DEROctetString) (asn1In.readObject());\n", 
            "+            ASN1InputStream asn1Inoctets = new ASN1InputStream(aiaDEROctetString.getOctets());\n", 
            "+            ASN1Sequence aiaASN1Sequence = (ASN1Sequence) asn1Inoctets.readObject();\n", 
            "+            authorityInformationAccess = AuthorityInformationAccess.getInstance(aiaASN1Sequence);//new AuthorityInformationAccess(aiaASN1Sequence);\n", 
            "+        } catch (IOException e) {\n", 
            "+            throw new CertificateVerificationException(\"Cannot read certificate to get OSCP urls\", e);\n", 
            "+        }\n", 
            "+\n", 
            "+        List<String> ocspUrlList = new ArrayList<String>();\n", 
            "+        AccessDescription[] accessDescriptions = authorityInformationAccess.getAccessDescriptions();\n", 
            "+        for (AccessDescription accessDescription : accessDescriptions) {\n", 
            "+\n", 
            "+            GeneralName gn = accessDescription.getAccessLocation();\n", 
            "+            if (gn.getTagNo() == GeneralName.uniformResourceIdentifier) {\n", 
            "+                DERIA5String str = DERIA5String.getInstance(gn.getName());\n", 
            "+                String accessLocation = str.getString();\n", 
            "+                ocspUrlList.add(accessLocation);\n", 
            "+            }\n", 
            "+        }\n", 
            "+        if(ocspUrlList.isEmpty())\n", 
            "+            throw new CertificateVerificationException(\"Cant get OCSP urls from certificate\");\n", 
            "+\n", 
            "+        return ocspUrlList;\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/ocsp/OCSPVerifier.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/ocsp/OCSPVerifier.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,31", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert;\n", 
            "+\n", 
            "+import java.security.cert.X509Certificate;\n", 
            "+\n", 
            "+/**\n", 
            "+ * All the revocation verifiers should implement this interface.\n", 
            "+ */\n", 
            "+public interface RevocationVerifier {\n", 
            "+\n", 
            "+    public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert)\n", 
            "+            throws CertificateVerificationException;\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationVerifier.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationVerifier.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,124", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.crl.CRLCache;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.crl.CRLVerifier;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPCache;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPVerifier;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.pathvalidation.CertificatePathValidator;\n", 
            "+\n", 
            "+import java.io.ByteArrayInputStream;\n", 
            "+import java.security.cert.X509Certificate;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Manager class responsible for verifying certificates. This class will use the available\n", 
            "+ * verifiers according to a predefined policy.\n", 
            "+ */\n", 
            "+public class RevocationVerificationManager {\n", 
            "+\n", 
            "+    private int cacheSize = Constants.CACHE_DEFAULT_ALLOCATED_SIZE;\n", 
            "+    private int cacheDelayMins = Constants.CACHE_DEFAULT_DELAY_MINS;\n", 
            "+    private static final Log log = LogFactory.getLog(RevocationVerificationManager.class);\n", 
            "+\n", 
            "+    public RevocationVerificationManager(Integer cacheAllocatedSize, Integer cacheDelayMins) {\n", 
            "+\n", 
            "+        if (cacheAllocatedSize != null && cacheAllocatedSize > Constants.CACHE_MIN_ALLOCATED_SIZE\n", 
            "+                && cacheAllocatedSize < Constants.CACHE_MAX_ALLOCATED_SIZE) {\n", 
            "+            this.cacheSize = cacheAllocatedSize;\n", 
            "+        }\n", 
            "+        if (cacheDelayMins != null && cacheDelayMins > Constants.CACHE_MIN_DELAY_MINS\n", 
            "+                && cacheDelayMins < Constants.CACHE_MAX_DELAY_MINS) {\n", 
            "+            this.cacheDelayMins = cacheDelayMins;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This method first tries to verify the given certificate chain using OCSP since OCSP\n", 
            "+     * verification is faster. If that fails it tries to do the verification using CRL.\n", 
            "+     *\n", 
            "+     * @param peerCertificates  javax.security.cert.X509Certificate[] array of peer\n", 
            "+     *                          certificate chain from peer/client.\n", 
            "+     * @throws CertificateVerificationException\n", 
            "+     */\n", 
            "+    public void verifyRevocationStatus(javax.security.cert.X509Certificate[] peerCertificates)\n", 
            "+            throws CertificateVerificationException {\n", 
            "+\n", 
            "+        X509Certificate[] convertedCertificates = convert(peerCertificates);\n", 
            "+\n", 
            "+        long start = System.currentTimeMillis();\n", 
            "+\n", 
            "+        OCSPCache ocspCache = OCSPCache.getCache();\n", 
            "+        ocspCache.init(cacheSize, cacheDelayMins);\n", 
            "+        CRLCache crlCache = CRLCache.getCache();\n", 
            "+        crlCache.init(cacheSize, cacheDelayMins);\n", 
            "+\n", 
            "+        RevocationVerifier[] verifiers = {new OCSPVerifier(ocspCache), new CRLVerifier(crlCache)};\n", 
            "+\n", 
            "+        for (RevocationVerifier verifier : verifiers) {\n", 
            "+            try {\n", 
            "+                CertificatePathValidator pathValidator = new CertificatePathValidator(\n", 
            "+                        convertedCertificates, verifier);\n", 
            "+                pathValidator.validatePath();\n", 
            "+                log.info(\"Path verification Successful with \" + verifier.getClass().getSimpleName() +\n", 
            "+                        \". Took \" + (System.currentTimeMillis() - start) + \" ms.\");\n", 
            "+                return;\n", 
            "+            } catch (Exception e) {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Certificate verification with \" + verifier.getClass().getSimpleName() +\n", 
            "+                            \" failed. \", e);\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+        throw new CertificateVerificationException(\"Path Verification Failed for both OCSP and CRL\");\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * @param certs array of javax.security.cert.X509Certificate[] s.\n", 
            "+     * @return the converted array of java.security.cert.X509Certificate[] s.\n", 
            "+     * @throws CertificateVerificationException\n", 
            "+     */\n", 
            "+    private X509Certificate[] convert(javax.security.cert.X509Certificate[] certs)\n", 
            "+            throws CertificateVerificationException {\n", 
            "+        X509Certificate[] certChain = new X509Certificate[certs.length];\n", 
            "+        Throwable exceptionThrown;\n", 
            "+        for (int i = 0; i < certs.length; i++) {\n", 
            "+            try {\n", 
            "+                byte[] encoded = certs[i].getEncoded();\n", 
            "+                ByteArrayInputStream bis = new ByteArrayInputStream(encoded);\n", 
            "+                java.security.cert.CertificateFactory cf\n", 
            "+                        = java.security.cert.CertificateFactory.getInstance(\"X.509\");\n", 
            "+                certChain[i]=((X509Certificate)cf.generateCertificate(bis));\n", 
            "+                continue;\n", 
            "+            } catch (java.security.cert.CertificateEncodingException e) {\n", 
            "+                exceptionThrown = e;\n", 
            "+            } catch (javax.security.cert.CertificateEncodingException e) {\n", 
            "+                exceptionThrown = e;\n", 
            "+            } catch (java.security.cert.CertificateException e) {\n", 
            "+                exceptionThrown = e;\n", 
            "+            }\n", 
            "+            throw new CertificateVerificationException(\"Cant Convert certificates from \" +\n", 
            "+                    \"javax to java\", exceptionThrown);\n", 
            "+        }\n", 
            "+        return certChain;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationVerificationManager.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationVerificationManager.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,111", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.pathvalidation;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.*;\n", 
            "+\n", 
            "+import java.security.cert.CertPathValidatorException;\n", 
            "+import java.security.cert.Certificate;\n", 
            "+import java.security.cert.PKIXCertPathChecker;\n", 
            "+import java.security.cert.X509Certificate;\n", 
            "+import java.util.Collection;\n", 
            "+import java.util.Set;\n", 
            "+\n", 
            "+/**\n", 
            "+ * This class is used by CertificatePathValidator to check revocation status of the certificate\n", 
            "+ * chain. Certificates in the chain will be passed to the check(..,..) method one by one.\n", 
            "+ * This is not Thread safe since the process is state full. Should not be shared among threads.\n", 
            "+ */\n", 
            "+public class PathChecker extends PKIXCertPathChecker {\n", 
            "+\n", 
            "+    private X509Certificate[] certChainArray;\n", 
            "+    private RevocationVerifier verifier;\n", 
            "+    private int position;\n", 
            "+    private static final Log log = LogFactory.getLog(PathChecker.class);\n", 
            "+\n", 
            "+    protected PathChecker(X509Certificate[] certChainArray, RevocationVerifier verifier) {\n", 
            "+        this.certChainArray = certChainArray;\n", 
            "+        //initialize position to Root Certificate position.\n", 
            "+        this.position = certChainArray.length - 1;\n", 
            "+        this.verifier = verifier;\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public void init(boolean forward) throws CertPathValidatorException {\n", 
            "+        if (forward) {\n", 
            "+            throw new CertPathValidatorException(\"Forward checking is not supported\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Forward checking is not supported. Certificates should be passed from the most trusted CA\n", 
            "+     * certificate to the target certificate. This is the default implementation of the Path\n", 
            "+     * validator used CertPathValidator.getInstance(\"PKIX\", \"BC\") in CertificatePathValidator;\n", 
            "+     */\n", 
            "+    @Override\n", 
            "+    public boolean isForwardCheckingSupported() {\n", 
            "+        return false;\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public Set<String> getSupportedExtensions() {\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Used by CertPathValidator to pass the certificates one by one from the certificate chain.\n", 
            "+     *\n", 
            "+     * @param cert the certificate passed to be checked.\n", 
            "+     * @param unresolvedCritExts not used in this method.\n", 
            "+     * @throws CertPathValidatorException\n", 
            "+     */\n", 
            "+    @Override\n", 
            "+    public void check(Certificate cert,\n", 
            "+                      Collection<String> unresolvedCritExts) throws CertPathValidatorException {\n", 
            "+\n", 
            "+        RevocationStatus status;\n", 
            "+        try {\n", 
            "+            status = verifier.checkRevocationStatus((X509Certificate) cert, nextIssuer());\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Certificate status is: \" + status.getMessage());\n", 
            "+            }\n", 
            "+            if (status != RevocationStatus.GOOD) {\n", 
            "+                throw new CertPathValidatorException(\"Revocation Status is Not Good\");\n", 
            "+            }\n", 
            "+        } catch (CertificateVerificationException e) {\n", 
            "+            throw new CertPathValidatorException(e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * @return the immediate issuer certificate of the current certificate which is being checked.\n", 
            "+     *          This is tracked by the position variable\n", 
            "+     */\n", 
            "+    private X509Certificate nextIssuer() {\n", 
            "+        //get immediate issuer\n", 
            "+        if (position > 0) {\n", 
            "+            return certChainArray[position--];\n", 
            "+        } else {\n", 
            "+            throw new ArrayIndexOutOfBoundsException(\"Certificate Chain Index Out of Bounds\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/pathvalidation/PathChecker.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/pathvalidation/PathChecker.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,105", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.pathvalidation;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.*;\n", 
            "+\n", 
            "+import java.security.*;\n", 
            "+import java.security.cert.X509Certificate;\n", 
            "+import java.util.List;\n", 
            "+import java.security.cert.*;\n", 
            "+import java.util.*;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Used to validate the revocation status of a certificate chain acquired from the peer. A\n", 
            "+ * revocation verifier (OCSP or CRL) should be given. Must be used only once when validating\n", 
            "+ * certificate chain for an SSLSession. Create a new instance if need to be reused because the\n", 
            "+ * path validation process is state-full. Not thread safe.\n", 
            "+ */\n", 
            "+public class CertificatePathValidator {\n", 
            "+\n", 
            "+    private PathChecker pathChecker;\n", 
            "+\n", 
            "+    // Certificate Chain with Root CA certificate (eg: peer cert, issuer cert, root cert)\n", 
            "+    List<X509Certificate> fullCertChain;\n", 
            "+    // Certificate Chain without Root CA certificate. (eg: peer cert, issuer cert)\n", 
            "+    List<X509Certificate> certChain;\n", 
            "+    private static final Log log = LogFactory.getLog(CertificatePathValidator.class);\n", 
            "+\n", 
            "+    public CertificatePathValidator(X509Certificate[] certChainArray, RevocationVerifier verifier) {\n", 
            "+        this.pathChecker = new PathChecker(certChainArray, verifier);\n", 
            "+        init(certChainArray);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Here revocation status checking is started from one below the root certificate in the\n", 
            "+     * chain (certChain). Since ssl implementation ensures that at least one certificate in the\n", 
            "+     * chain is trusted, we can logically say that the root is trusted.\n", 
            "+     */\n", 
            "+    private void init(X509Certificate[] certChainArray) {\n", 
            "+        X509Certificate[] partCertChainArray = new X509Certificate[certChainArray.length-1];\n", 
            "+        System.arraycopy(certChainArray,0,partCertChainArray,0,partCertChainArray.length);\n", 
            "+        certChain = Arrays.asList(partCertChainArray);\n", 
            "+        fullCertChain = Arrays.asList(certChainArray);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Certificate Path Validation process\n", 
            "+     *\n", 
            "+     * @throws CertificateVerificationException\n", 
            "+     *          if validation process fails.\n", 
            "+     */\n", 
            "+    public void validatePath() throws CertificateVerificationException {\n", 
            "+\n", 
            "+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n", 
            "+        CollectionCertStoreParameters params = new CollectionCertStoreParameters(fullCertChain);\n", 
            "+        try {\n", 
            "+            CertStore store = CertStore.getInstance(\"Collection\", params, \"BC\");\n", 
            "+\n", 
            "+            // create certificate path\n", 
            "+            CertificateFactory fact = CertificateFactory.getInstance(\"X.509\", \"BC\");\n", 
            "+\n", 
            "+            CertPath certPath = fact.generateCertPath(certChain);\n", 
            "+            TrustAnchor trustAnchor = new TrustAnchor(fullCertChain.get(fullCertChain.size() - 1),\n", 
            "+                    null);\n", 
            "+            Set<TrustAnchor> trust = Collections.singleton(trustAnchor);\n", 
            "+\n", 
            "+            // perform validation\n", 
            "+            CertPathValidator validator = CertPathValidator.getInstance(\"PKIX\", \"BC\");\n", 
            "+            PKIXParameters param = new PKIXParameters(trust);\n", 
            "+\n", 
            "+            param.addCertPathChecker(pathChecker);\n", 
            "+            param.setRevocationEnabled(false);\n", 
            "+            param.addCertStore(store);\n", 
            "+            param.setDate(new Date());\n", 
            "+\n", 
            "+            validator.validate(certPath, param);\n", 
            "+\n", 
            "+            log.debug(\"Certificate path validated\");\n", 
            "+        } catch (CertPathValidatorException e) {\n", 
            "+            throw new CertificateVerificationException(\"Certificate Path Validation failed on \" +\n", 
            "+                    \"certificate number \" + e.getIndex() + \", details: \" + e.getMessage(), e);\n", 
            "+        } catch (Exception e) {\n", 
            "+            throw new CertificateVerificationException(\"Certificate Path Validation failed\", e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/pathvalidation/CertificatePathValidator.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/pathvalidation/CertificatePathValidator.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,113", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.adaptor;\n", 
            "+\n", 
            "+import java.io.ByteArrayOutputStream;\n", 
            "+import java.io.File;\n", 
            "+import java.io.FileFilter;\n", 
            "+import java.io.InputStream;\n", 
            "+import java.util.Hashtable;\n", 
            "+import java.util.jar.JarEntry;\n", 
            "+import java.util.jar.JarFile;\n", 
            "+\n", 
            "+/**\n", 
            "+ * The ParentLastClassLoader is needed because the OCSP/CRL feature for synapse uses a dependency\n", 
            "+ * jar from bouncyCastle version bcprov-jdk16-1.46.jar. Apache Rampart which is a synapse\n", 
            "+ * dependency for WS-Security also uses an older version of a bouncyCastle jar. The JVM loads the\n", 
            "+ * older version thus making OCSP/CRL feature fail to function. This is known as Jar Hell in java\n", 
            "+ * community. As a workaround, a Parent Last Class Loader is used to load the classes used by\n", 
            "+ * OCSP/CRL feature from the relevant jar files. The default class loader hierarchy in Java is\n", 
            "+ * Parent First. This custom ParentLastClassLoader overrides the default behaviour. If\n", 
            "+ * ParentLastClassLoader could not load a class it will delegate the job to the parent, the system\n", 
            "+ * class loader.\n", 
            "+ */\n", 
            "+public class ParentLastClassLoader extends ClassLoader {\n", 
            "+\n", 
            "+    //used to cache already defined classes\n", 
            "+    private static final Hashtable<String,Class> classes = new Hashtable<String,Class>();\n", 
            "+\n", 
            "+    private File[] jarFiles; // Jar files\n", 
            "+\n", 
            "+    public ParentLastClassLoader(ClassLoader parent) {\n", 
            "+        super(parent);\n", 
            "+        String libDir = System.getProperty(\"synapse.bcprov.lib\");\n", 
            "+        if (libDir == null) {\n", 
            "+            libDir = \"lib\";\n", 
            "+        }\n", 
            "+\n", 
            "+        File dir = new File(libDir);\n", 
            "+        jarFiles = dir.listFiles(new FileFilter() {\n", 
            "+            public boolean accept(File f) {\n", 
            "+                return f.getName().startsWith(\"synapse-nhttp-transport\") ||\n", 
            "+                        f.getName().equals(\"bcprov-jdk15on-1.49.jar\");\n", 
            "+            }\n", 
            "+        });\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public Class<?> findClass(String name) throws ClassNotFoundException {\n", 
            "+        throw new ClassNotFoundException();\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    protected synchronized Class<?> loadClass(String className,\n", 
            "+                                              boolean resolve) throws ClassNotFoundException {\n", 
            "+\n", 
            "+        try {\n", 
            "+            byte classByte[];\n", 
            "+            Class result;\n", 
            "+\n", 
            "+            //checks in cached classes\n", 
            "+            result = classes.get(className);\n", 
            "+            if (result != null) {\n", 
            "+                return result;\n", 
            "+            }\n", 
            "+\n", 
            "+            for (File jarFile : jarFiles) {\n", 
            "+                try {\n", 
            "+                    JarFile jar = new JarFile(jarFile);\n", 
            "+                    JarEntry entry = jar.getJarEntry(className.replace(\".\", \"/\") + \".class\");\n", 
            "+                    InputStream is = jar.getInputStream(entry);\n", 
            "+                    ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n", 
            "+                    int nextValue = is.read();\n", 
            "+                    while (-1 != nextValue) {\n", 
            "+                        byteStream.write(nextValue);\n", 
            "+                        nextValue = is.read();\n", 
            "+                    }\n", 
            "+\n", 
            "+                    classByte = byteStream.toByteArray();\n", 
            "+                    result = defineClass(className, classByte, 0, classByte.length, null);\n", 
            "+                    classes.put(className, result);\n", 
            "+                    break;\n", 
            "+                } catch (Exception ignored) {}\n", 
            "+            }\n", 
            "+\n", 
            "+            if (result != null) {\n", 
            "+                return result;\n", 
            "+            } else {\n", 
            "+                throw new ClassNotFoundException(\"Not found \" + className);\n", 
            "+            }\n", 
            "+        } catch (ClassNotFoundException e) {\n", 
            "+            // didn't find it, try the parent\n", 
            "+            return super.loadClass(className, resolve);\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n", 
            "+\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/adaptor/ParentLastClassLoader.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/adaptor/ParentLastClassLoader.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,60", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.adaptor;\n", 
            "+\n", 
            "+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationException;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.Constants;\n", 
            "+\n", 
            "+import java.lang.reflect.Constructor;\n", 
            "+import java.lang.reflect.Method;\n", 
            "+import javax.security.cert.X509Certificate;\n", 
            "+\n", 
            "+/**\n", 
            "+ * This is the adaptor used to plug OCSP/CRL feature to synapse while solving the Jar Hell\n", 
            "+ * problem internally using ParentLastClassLoader. This adaptor is not needed if Apache Rampart\n", 
            "+ * and OCSP/CRL feature uses the same bouncyCastle dependency. At the time of this feature is\n", 
            "+ * made, Apache Rampart and OCSP/CRL feature use two different versions of bouncyCastle.\n", 
            "+ */\n", 
            "+public class SynapseAdaptorForOcspCrl {\n", 
            "+\n", 
            "+    private static final ClassLoader loader = new ParentLastClassLoader(\n", 
            "+            Thread.currentThread().getContextClassLoader());\n", 
            "+\n", 
            "+    public void verifyRevocationStatus(X509Certificate[] peerCertificates, Integer cacheSize,\n", 
            "+                                       Integer cacheDelay) throws CertificateVerificationException {\n", 
            "+\n", 
            "+        if (peerCertificates == null || cacheSize == null || cacheDelay == null) {\n", 
            "+            throw new IllegalArgumentException(\"Argument cannot be null\");\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            Class revocationManagerClass = loader.loadClass(Constants.REVOCATION_MANAGER);\n", 
            "+            Method method = revocationManagerClass.getMethod(Constants.VERIFY_METHOD,\n", 
            "+                    peerCertificates.getClass());\n", 
            "+            Constructor constructor = revocationManagerClass.getConstructor(cacheSize.getClass(),\n", 
            "+                    cacheDelay.getClass());\n", 
            "+            Object revocationManager = constructor.newInstance(cacheSize, cacheDelay);\n", 
            "+            method.invoke(revocationManager, new Object[] { peerCertificates });\n", 
            "+        } catch (Exception e) {\n", 
            "+            throw new CertificateVerificationException(\"Failed to load BouncyCastle classes for \" +\n", 
            "+                    \"certificate validation\", e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/adaptor/SynapseAdaptorForOcspCrl.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/adaptor/SynapseAdaptorForOcspCrl.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,64", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axis2.description.Parameter;\n", 
            "+import org.apache.axis2.util.JavaUtils;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+\n", 
            "+public class CertificateVerificationConfig {\n", 
            "+\n", 
            "+    private boolean enabled;\n", 
            "+    private Integer cacheSize = Constants.CACHE_DEFAULT_ALLOCATED_SIZE;\n", 
            "+    private Integer cacheDuration = Constants.CACHE_DEFAULT_DELAY_MINS;\n", 
            "+\n", 
            "+    public CertificateVerificationConfig(Parameter param) {\n", 
            "+        if (param == null) {\n", 
            "+            return;\n", 
            "+        }\n", 
            "+        OMElement element = param.getParameterElement();\n", 
            "+        OMElement enabledElement = element.getFirstChildWithName(new QName(\"Enabled\"));\n", 
            "+        if (enabledElement != null && JavaUtils.isTrueExplicitly(enabledElement.getText())) {\n", 
            "+            enabled = true;\n", 
            "+        }\n", 
            "+        OMElement sizeElement = element.getFirstChildWithName(new QName(\"CacheSize\"));\n", 
            "+        if (sizeElement != null) {\n", 
            "+            cacheSize = new Integer(sizeElement.getText());\n", 
            "+        }\n", 
            "+        OMElement delayElement = element.getFirstChildWithName(new QName(\"CacheDelayMins\"));\n", 
            "+        if (delayElement != null) {\n", 
            "+            cacheSize = new Integer(delayElement.getText());\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isEnabled() {\n", 
            "+        return enabled;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Integer getCacheSize() {\n", 
            "+        return cacheSize;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Integer getCacheDuration() {\n", 
            "+        return cacheDuration;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/CertificateVerificationConfig.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/CertificateVerificationConfig.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,34", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert;\n", 
            "+\n", 
            "+public interface Constants {\n", 
            "+\n", 
            "+    public static final int CACHE_MAX_ALLOCATED_SIZE = 10000;\n", 
            "+    public static final int CACHE_MIN_ALLOCATED_SIZE = 50;\n", 
            "+    public static final int CACHE_DEFAULT_ALLOCATED_SIZE = 50;\n", 
            "+    public static final int CACHE_MAX_DELAY_MINS = 60 * 24;\n", 
            "+    public static final int CACHE_MIN_DELAY_MINS = 1;\n", 
            "+    public static final int CACHE_DEFAULT_DELAY_MINS = 15;\n", 
            "+\n", 
            "+    public static final String REVOCATION_MANAGER = \"org.apache.synapse.transport.utils.sslcert.\" +\n", 
            "+            \"RevocationVerificationManager\";\n", 
            "+    public static final String VERIFY_METHOD = \"verifyRevocationStatus\";\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/Constants.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/Constants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,34", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert;\n", 
            "+\n", 
            "+public enum RevocationStatus {\n", 
            "+\n", 
            "+    GOOD(\"Good\"), UNKNOWN(\"Unknown\"), REVOKED(\"Revoked\");\n", 
            "+    private String message;\n", 
            "+\n", 
            "+    private RevocationStatus(String message) {\n", 
            "+        this.message = message;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getMessage() {\n", 
            "+        return message;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationStatus.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationStatus.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,212", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.crl;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+\n", 
            "+import org.apache.synapse.commons.jmx.MBeanRegistrar;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.cache.CacheController;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.cache.CacheManager;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.cache.ManageableCache;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.cache.ManageableCacheValue;\n", 
            "+\n", 
            "+import java.security.cert.X509CRL;\n", 
            "+import java.util.Date;\n", 
            "+import java.util.Iterator;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.concurrent.ConcurrentHashMap;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Since a CRL maps to a CRL URL, the CRLCache should have x509CRL entries against CRL URLs.\n", 
            "+ * This cache is a Singleton since it is shared by any transport which needs SSL certificate\n", 
            "+ * validation and more than one CRLCache should not be allowed per system.\n", 
            "+ */\n", 
            "+public class CRLCache implements ManageableCache {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(CRLCache.class);\n", 
            "+\n", 
            "+    private static final CRLCache cache = new CRLCache();\n", 
            "+    private final Map<String, CRLCacheValue> hashMap;\n", 
            "+    private Iterator<Map.Entry<String, CRLCacheValue>> iterator;\n", 
            "+    private volatile CacheManager cacheManager;\n", 
            "+    private final CRLVerifier crlVerifier;\n", 
            "+\n", 
            "+    private CRLCache() {\n", 
            "+        hashMap = new ConcurrentHashMap<String, CRLCacheValue>();\n", 
            "+        iterator = hashMap.entrySet().iterator();\n", 
            "+        crlVerifier = new CRLVerifier(null);\n", 
            "+    }\n", 
            "+\n", 
            "+    public static CRLCache getCache() {\n", 
            "+        return cache;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This initialize the Cache with a CacheManager. If this method is not called, a cache manager\n", 
            "+     * will not be used.\n", 
            "+     *\n", 
            "+     * @param size max size of the cache\n", 
            "+     * @param delay defines how frequently the CacheManager will be started\n", 
            "+     */\n", 
            "+    public void init(int size, int delay) {\n", 
            "+        if (cacheManager == null) {\n", 
            "+            synchronized (CRLCache.class) {\n", 
            "+                if (cacheManager == null) {\n", 
            "+                    cacheManager = new CacheManager(cache, size, delay);\n", 
            "+                    CacheController mbean = new CacheController(cache,cacheManager);\n", 
            "+                    MBeanRegistrar.getInstance().registerMBean(mbean, \"CacheController\",\n", 
            "+                            \"CRLCacheController\");\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This method is needed by the cache Manager to go through the cache entries to remove\n", 
            "+     * invalid values or to remove LRU cache values if the cache has reached its max size.\n", 
            "+     *\n", 
            "+     * @return next cache value of the cache.\n", 
            "+     */\n", 
            "+    public synchronized ManageableCacheValue getNextCacheValue() {\n", 
            "+        //changes to the map are reflected on the keySet. And its iterator is weakly consistent.\n", 
            "+        // so will never throw concurrent modification exception.\n", 
            "+        if (iterator.hasNext()) {\n", 
            "+            return hashMap.get(iterator.next().getKey());\n", 
            "+        } else {\n", 
            "+            resetIterator();\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * To get the current cache size (size of the hash map).\n", 
            "+     */\n", 
            "+    public synchronized int getCacheSize() {\n", 
            "+        return hashMap.size();\n", 
            "+    }\n", 
            "+\n", 
            "+    public void resetIterator() {\n", 
            "+        iterator = hashMap.entrySet().iterator();\n", 
            "+    }\n", 
            "+\n", 
            "+    private synchronized void replaceNewCacheValue(CRLCacheValue cacheValue) {\n", 
            "+        //If someone has updated with the new value before current Thread.\n", 
            "+        if (cacheValue.isValid()) {\n", 
            "+            return;\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            String crlUrl = cacheValue.crlUrl;\n", 
            "+            X509CRL x509CRL = crlVerifier.downloadCRLFromWeb(crlUrl);\n", 
            "+            this.setCacheValue(crlUrl, x509CRL);\n", 
            "+        } catch (Exception e) {\n", 
            "+            log.debug(\"Cant replace old CacheValue with new CacheValue. So remove\", e);\n", 
            "+            //If cant be replaced remove.\n", 
            "+            cacheValue.removeThisCacheValue();\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public synchronized X509CRL getCacheValue(String crlUrl) {\n", 
            "+        CRLCacheValue cacheValue = hashMap.get(crlUrl);\n", 
            "+        if (cacheValue != null) {\n", 
            "+            //If who ever gets this cache value before Cache manager task found its invalid,\n", 
            "+            // update it and get the new value.\n", 
            "+            if (!cacheValue.isValid()) {\n", 
            "+                cacheValue.updateCacheWithNewValue();\n", 
            "+                CRLCacheValue crlCacheValue = hashMap.get(crlUrl);\n", 
            "+                return (crlCacheValue != null ? crlCacheValue.getValue() : null);\n", 
            "+            }\n", 
            "+\n", 
            "+            return cacheValue.getValue();\n", 
            "+        } else\n", 
            "+            return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    public synchronized void setCacheValue(String crlUrl, X509CRL crl) {\n", 
            "+        CRLCacheValue cacheValue = new CRLCacheValue(crlUrl, crl);\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Before set- HashMap size \" + hashMap.size());\n", 
            "+        }\n", 
            "+        hashMap.put(crlUrl, cacheValue);\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"After set - HashMap size \" + hashMap.size());\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public synchronized void removeCacheValue(String crlUrl) {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Before remove - HashMap size \" + hashMap.size());\n", 
            "+        }\n", 
            "+        hashMap.remove(crlUrl);\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"After remove - HashMap size \" + hashMap.size());\n", 
            "+        }\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * This is the wrapper class of the actual cache value which is a X509CRL.\n", 
            "+     */\n", 
            "+    private class CRLCacheValue implements ManageableCacheValue {\n", 
            "+\n", 
            "+        private String crlUrl;\n", 
            "+        private X509CRL crl;\n", 
            "+        private long timeStamp = System.currentTimeMillis();\n", 
            "+\n", 
            "+        public CRLCacheValue(String crlUrl, X509CRL crl) {\n", 
            "+            this.crlUrl = crlUrl;\n", 
            "+            this.crl = crl;\n", 
            "+        }\n", 
            "+\n", 
            "+        public String getKey() {\n", 
            "+            return crlUrl;\n", 
            "+        }\n", 
            "+\n", 
            "+        public X509CRL getValue() {\n", 
            "+            timeStamp = System.currentTimeMillis();\n", 
            "+            return crl;\n", 
            "+        }\n", 
            "+\n", 
            "+        /**\n", 
            "+         * CRL has a validity period. We can reuse a downloaded CRL within that period.\n", 
            "+         */\n", 
            "+        public boolean isValid() {\n", 
            "+            Date today = new Date();\n", 
            "+            Date nextUpdate = crl.getNextUpdate();\n", 
            "+            return nextUpdate != null && nextUpdate.after(today);\n", 
            "+        }\n", 
            "+\n", 
            "+        public long getTimeStamp() {\n", 
            "+            return timeStamp;\n", 
            "+        }\n", 
            "+\n", 
            "+        /**\n", 
            "+         * Used by cacheManager to remove invalid entries.\n", 
            "+         */\n", 
            "+        public void removeThisCacheValue() {\n", 
            "+            removeCacheValue(crlUrl);\n", 
            "+        }\n", 
            "+\n", 
            "+        public void updateCacheWithNewValue() {\n", 
            "+            replaceNewCacheValue(this);\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/crl/CRLCache.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/crl/CRLCache.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,192", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.utils.sslcert.crl;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.bouncycastle.asn1.ASN1InputStream;\n", 
            "+import org.bouncycastle.asn1.ASN1Primitive;\n", 
            "+import org.bouncycastle.asn1.DERIA5String;\n", 
            "+import org.bouncycastle.asn1.DEROctetString;\n", 
            "+import org.bouncycastle.asn1.x509.*;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.*;\n", 
            "+\n", 
            "+import java.io.IOException;\n", 
            "+import java.io.InputStream;\n", 
            "+import java.net.MalformedURLException;\n", 
            "+import java.net.URL;\n", 
            "+import java.security.cert.*;\n", 
            "+import java.util.ArrayList;\n", 
            "+import java.util.List;\n", 
            "+\n", 
            "+/**\n", 
            "+ * This is used to verify a certificate is revoked or not by using the Certificate Revocation\n", 
            "+ * List published by the CA.\n", 
            "+ */\n", 
            "+public class CRLVerifier implements RevocationVerifier {\n", 
            "+\n", 
            "+    private CRLCache cache;\n", 
            "+    private static final Log log = LogFactory.getLog(CRLVerifier.class);\n", 
            "+\n", 
            "+    public CRLVerifier(CRLCache cache) {\n", 
            "+        this.cache = cache;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Checks revocation status (Good, Revoked) of the peer certificate.\n", 
            "+     *\n", 
            "+     * @param peerCert   peer certificate\n", 
            "+     * @param issuerCert issuer certificate of the peer. not used currently.\n", 
            "+     * @return revocation status of the peer certificate.\n", 
            "+     * @throws CertificateVerificationException\n", 
            "+     *\n", 
            "+     */\n", 
            "+    public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert)\n", 
            "+            throws CertificateVerificationException {\n", 
            "+\n", 
            "+        List<String> list = getCrlDistributionPoints(peerCert);\n", 
            "+        //check with distributions points in the list one by one. if one fails go to the other.\n", 
            "+        for (String crlUrl : list) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Trying to get CRL for URL: \" + crlUrl);\n", 
            "+            }\n", 
            "+\n", 
            "+            if (cache != null) {\n", 
            "+                X509CRL x509CRL = cache.getCacheValue(crlUrl);\n", 
            "+                if (x509CRL != null) {\n", 
            "+                    //If cant be casted, we have used the wrong cache.\n", 
            "+                    RevocationStatus status = getRevocationStatus(x509CRL, peerCert);\n", 
            "+                    log.debug(\"CRL taken from cache....\");\n", 
            "+                    return status;\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+            //todo: Do we need to check if URL has the same domain name as issuerCert?\n", 
            "+            try {\n", 
            "+                X509CRL x509CRL = downloadCRLFromWeb(crlUrl);\n", 
            "+                if (x509CRL != null) {\n", 
            "+                    if (cache != null)\n", 
            "+                        cache.setCacheValue(crlUrl, x509CRL);\n", 
            "+                    return getRevocationStatus(x509CRL, peerCert);\n", 
            "+                }\n", 
            "+            } catch (Exception e) {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Either the url is bad or cannot build X509CRL. Check with the next \" +\n", 
            "+                            \"url in the list.\", e);\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+        throw new CertificateVerificationException(\"Cannot check revocation status with the \" +\n", 
            "+                \"certificate\");\n", 
            "+    }\n", 
            "+\n", 
            "+    private RevocationStatus getRevocationStatus(X509CRL x509CRL, X509Certificate peerCert) {\n", 
            "+        if (x509CRL.isRevoked(peerCert)) {\n", 
            "+            return RevocationStatus.REVOKED;\n", 
            "+        } else {\n", 
            "+            return RevocationStatus.GOOD;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Downloads CRL from the crlUrl. Does not support HTTPS\n", 
            "+     */\n", 
            "+    protected X509CRL downloadCRLFromWeb(String crlURL)\n", 
            "+            throws IOException, CertificateVerificationException {\n", 
            "+        InputStream crlStream = null;\n", 
            "+        try {\n", 
            "+            URL url = new URL(crlURL);\n", 
            "+            crlStream = url.openStream();\n", 
            "+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n", 
            "+            return (X509CRL) cf.generateCRL(crlStream);\n", 
            "+        } catch (MalformedURLException e) {\n", 
            "+            throw new CertificateVerificationException(\"CRL Url is malformed\", e);\n", 
            "+        } catch (IOException e) {\n", 
            "+            throw new CertificateVerificationException(\"Cant reach URI: \" + crlURL +\n", 
            "+                    \" - only support HTTP\", e);\n", 
            "+        } catch (CertificateException e) {\n", 
            "+            throw new CertificateVerificationException(e);\n", 
            "+        } catch (CRLException e) {\n", 
            "+            throw new CertificateVerificationException(\"Cannot generate X509CRL from the \" +\n", 
            "+                    \"stream data\", e);\n", 
            "+        } finally {\n", 
            "+            if (crlStream != null)\n", 
            "+                crlStream.close();\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Extracts all CRL distribution point URLs from the \"CRL Distribution Point\"\n", 
            "+     * extension in a X.509 certificate. If CRL distribution point extension is\n", 
            "+     * unavailable, returns an empty list.\n", 
            "+     */\n", 
            "+    private List<String> getCrlDistributionPoints(X509Certificate cert)\n", 
            "+            throws CertificateVerificationException {\n", 
            "+\n", 
            "+        //Gets the DER-encoded OCTET string for the extension value for CRLDistributionPoints\n", 
            "+        byte[] crlDPExtensionValue = cert.getExtensionValue(\n", 
            "+                X509Extensions.CRLDistributionPoints.getId());\n", 
            "+        if (crlDPExtensionValue == null)\n", 
            "+            throw new CertificateVerificationException(\"Certificate doesn't have CRL \" +\n", 
            "+                    \"distribution points\");\n", 
            "+        //crlDPExtensionValue is encoded in ASN.1 format.\n", 
            "+        ASN1InputStream asn1In = new ASN1InputStream(crlDPExtensionValue);\n", 
            "+        // DER (Distinguished Encoding Rules) is one of ASN.1 encoding rules defined in ITU-T X.690,\n", 
            "+        // 2002, specification. ASN.1 encoding rules can be used to encode any data object into a\n", 
            "+        // binary file. Read the object in octets.\n", 
            "+        CRLDistPoint distPoint;\n", 
            "+        try {\n", 
            "+            DEROctetString crlDEROctetString = (DEROctetString) asn1In.readObject();\n", 
            "+            //Get Input stream in octets\n", 
            "+            ASN1InputStream asn1InOctets = new ASN1InputStream(crlDEROctetString.getOctets());\n", 
            "+            ASN1Primitive asn1Primitive = asn1InOctets.readObject();\n", 
            "+            distPoint = CRLDistPoint.getInstance(asn1Primitive);\n", 
            "+        } catch (IOException e) {\n", 
            "+            throw new CertificateVerificationException(\"Cannot read certificate to get CRL urls\", e);\n", 
            "+        }\n", 
            "+\n", 
            "+        List<String> crlUrls = new ArrayList<String>();\n", 
            "+        //Loop through ASN1Encodable DistributionPoints\n", 
            "+        for (DistributionPoint dp : distPoint.getDistributionPoints()) {\n", 
            "+            //get ASN1Encodable DistributionPointName\n", 
            "+            DistributionPointName dpn = dp.getDistributionPoint();\n", 
            "+            if (dpn != null && dpn.getType() == DistributionPointName.FULL_NAME) {\n", 
            "+                //Create ASN1Encodable General Names\n", 
            "+                GeneralName[] genNames = GeneralNames.getInstance(dpn.getName()).getNames();\n", 
            "+                // Look for a URI\n", 
            "+                //todo: May be able to check for OCSP url specifically.\n", 
            "+                for (GeneralName genName : genNames) {\n", 
            "+                    if (genName.getTagNo() == GeneralName.uniformResourceIdentifier) {\n", 
            "+                        //DERIA5String contains an ascii string.\n", 
            "+                        //A IA5String is a restricted character string type in the ASN.1 notation\n", 
            "+                        String url = DERIA5String.getInstance(genName.getName()).getString().trim();\n", 
            "+                        crlUrls.add(url);\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        if (crlUrls.isEmpty()) {\n", 
            "+            throw new CertificateVerificationException(\"Cant get CRL urls from certificate\");\n", 
            "+        }\n", 
            "+\n", 
            "+        return crlUrls;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/crl/CRLVerifier.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/crl/CRLVerifier.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-23,8 +23,6", 
          "lines": [
            " import org.apache.axis2.AxisFault;\n", 
            " import org.apache.axis2.description.Parameter;\n", 
            " import org.apache.axis2.description.TransportInDescription;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            " import org.apache.http.nio.NHttpServerEventHandler;\n", 
            " import org.apache.http.nio.reactor.IOEventDispatch;\n", 
            " import org.apache.http.nio.reactor.IOSession;\n"
          ]
        }, 
        {
          "locn": "-39,8 +37,6", 
          "lines": [
            " import java.security.KeyStore;\n", 
            " \n", 
            " public class PassThroughHttpSSLListener extends PassThroughHttpListener {\n", 
            "-    \n", 
            "-    private Log log = LogFactory.getLog(PassThroughHttpSSLListener.class);\n", 
            " \n", 
            "     @Override\n", 
            "     protected IOEventDispatch getEventDispatch(NHttpServerEventHandler handler, SSLContext sslContext,\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-24,13 +24,14", 
          "lines": [
            " import org.apache.axis2.description.Parameter;\n", 
            " import org.apache.axis2.description.TransportOutDescription;\n", 
            " import org.apache.axis2.transport.base.ParamUtils;\n", 
            "-import org.apache.commons.logging.Log;\n", 
            "-import org.apache.commons.logging.LogFactory;\n", 
            " import org.apache.http.nio.NHttpClientEventHandler;\n", 
            " import org.apache.http.nio.reactor.IOEventDispatch;\n", 
            " import org.apache.http.nio.reactor.IOSession;\n", 
            " import org.apache.http.nio.reactor.ssl.SSLSetupHandler;\n", 
            " import org.apache.http.params.HttpParams;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationConfig;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationException;\n", 
            "+import org.apache.synapse.transport.utils.sslcert.adaptor.SynapseAdaptorForOcspCrl;\n", 
            " \n", 
            " import javax.net.ssl.*;\n", 
            " import javax.xml.namespace.QName;\n"
          ]
        }, 
        {
          "locn": "-48,7 +49,7", 
          "lines": [
            " \n", 
            " public class PassThroughHttpSSLSender extends PassThroughHttpSender {\n", 
            " \n", 
            "-    private Log log = LogFactory.getLog(PassThroughHttpSSLSender.class);\n", 
            "+    private static final SynapseAdaptorForOcspCrl ocspCrl = new SynapseAdaptorForOcspCrl();\n", 
            " \n", 
            "     protected IOEventDispatch getEventDispatch(NHttpClientEventHandler handler,\n", 
            "                                                SSLContext sslContext,\n"
          ]
        }, 
        {
          "locn": "-104,12 +105,12", 
          "lines": [
            "     protected SSLSetupHandler getSSLSetupHandler(TransportOutDescription transportOut)\n", 
            "             throws AxisFault {\n", 
            " \n", 
            "-        final Parameter hostnameVerifier = transportOut.getParameter(\"HostnameVerifier\");\n", 
            "-        if (hostnameVerifier != null) {\n", 
            "-            return createSSLSetupHandler(hostnameVerifier.getValue().toString());\n", 
            "-        } else {\n", 
            "-            return createSSLSetupHandler(null);\n", 
            "-        }\n", 
            "+        Parameter hostnameVerifier = transportOut.getParameter(\"HostnameVerifier\");\n", 
            "+        String hostnameVerifierValue = hostnameVerifier != null ?\n", 
            "+                hostnameVerifier.getValue().toString() : null;\n", 
            "+        Parameter revocationVerifierParam = transportOut.getParameter(\"CertificateRevocationVerifier\");\n", 
            "+        return createSSLSetupHandler(hostnameVerifierValue,\n", 
            "+                new CertificateVerificationConfig(revocationVerifierParam));\n", 
            "     }\n", 
            " \n", 
            "     /**\n"
          ]
        }, 
        {
          "locn": "-280,8 +281,8", 
          "lines": [
            "         }\n", 
            "     }\n", 
            " \n", 
            "-    private SSLSetupHandler createSSLSetupHandler(final String hostnameVerifier)\n", 
            "-            throws AxisFault {\n", 
            "+    private SSLSetupHandler createSSLSetupHandler(final String hostnameVerifier,\n", 
            "+                                                  final CertificateVerificationConfig cvConfig) throws AxisFault {\n", 
            " \n", 
            "         return new SSLSetupHandler() {\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-298,6 +299,7", 
          "lines": [
            "                 }\n", 
            " \n", 
            "                 boolean valid = false;\n", 
            "+                //Do HostName verification.\n", 
            "                 if (hostnameVerifier != null) {\n", 
            "                     if (\"Strict\".equals(hostnameVerifier)) {\n", 
            "                         valid = HostnameVerifier.STRICT.verify(address, session);\n"
          ]
        }, 
        {
          "locn": "-313,6 +315,17", 
          "lines": [
            "                 if (!valid) {\n", 
            "                     throw new SSLException(\"Host name verification failed for host : \" + address);\n", 
            "                 }\n", 
            "+\n", 
            "+                if (cvConfig.isEnabled()) {\n", 
            "+                    //Do revocation verification of Certificates\n", 
            "+                    try {\n", 
            "+                        ocspCrl.verifyRevocationStatus(session.getPeerCertificateChain(),\n", 
            "+                                cvConfig.getCacheSize(), cvConfig.getCacheDuration());\n", 
            "+                    } catch (CertificateVerificationException e) {\n", 
            "+                        throw new SSLException(\"Certificate chain validation failed for host : \" +\n", 
            "+                                address, e);\n", 
            "+                    }\n", 
            "+                }\n", 
            "             }\n", 
            "         };\n", 
            "     }\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-153,6 +153,12", 
          "lines": [
            "             <groupId>commons-lang</groupId>\n", 
            "             <artifactId>commons-lang</artifactId>\n", 
            "         </dependency>\n", 
            "+\n", 
            "+        <!-- BouncyCastle API which is required when validating Certificates. -->\n", 
            "+        <dependency>\n", 
            "+            <groupId>org.bouncycastle</groupId>\n", 
            "+            <artifactId>bcprov-jdk15on</artifactId>\n", 
            "+        </dependency>\n", 
            "     </dependencies>\n", 
            " \n", 
            " </project>\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/pom.xml", 
      "from": "java/modules/transports/core/nhttp/pom.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-313,6 +313,12", 
          "lines": [
            "         </parameter>\n", 
            "         <!--<parameter name=\"HostnameVerifier\">DefaultAndLocalhost</parameter>\n", 
            "             supports Strict|AllowAll|DefaultAndLocalhost or the default if none specified -->\n", 
            "+        <!-- Uncomment to enable OCSP/CRL certification revocation verification support\n", 
            "+        <parameter name=\"CertificateRevocationVerifier\" locked=\"false\">\n", 
            "+            <Enabled>true</Enabled>\n", 
            "+            <CacheSize>50</CacheSize>\n", 
            "+            <CacheDelayMins>15</CacheDelayMins>\n", 
            "+        </parameter-->\n", 
            "     </transportSender>\n", 
            " \n", 
            "     <!-- Uncomment Transport sender for the non blocking local transport-->\n"
          ]
        }
      ], 
      "to": "java/repository/conf/axis2.xml", 
      "from": "java/repository/conf/axis2.xml"
    }
  ], 
  "id": "1508687"
}