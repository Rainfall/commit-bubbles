{
  "when": "2013-07-14T16:43:58-04:00", 
  "who": "hiranya", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-33,7 +33,6", 
          "lines": [
            " import org.apache.axis2.transport.base.threads.WorkerPool;\n", 
            " import org.apache.axis2.transport.base.ParamUtils;\n", 
            " import org.apache.axis2.AxisFault;\n", 
            "-import org.apache.synapse.transport.nhttp.DefaultHttpGetProcessor;\n", 
            " \n", 
            " import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            " import org.apache.synapse.transport.passthru.HttpGetRequestProcessor;\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/SourceConfiguration.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/SourceConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,470", 
          "lines": [
            "+/*\n", 
            "+ * Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ * or more contributor license agreements. See the NOTICE file\n", 
            "+ * distributed with this work for additional information\n", 
            "+ * regarding copyright ownership. The ASF licenses this file\n", 
            "+ * to you under the Apache License, Version 2.0 (the\n", 
            "+ * \"License\"); you may not use this file except in compliance\n", 
            "+ * with the License. You may obtain a copy of the License at\n", 
            "+ * \n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ * \n", 
            "+ * Unless required by applicable law or agreed to in writing,\n", 
            "+ * software distributed under the License is distributed on an\n", 
            "+ * * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ * KIND, either express or implied. See the License for the\n", 
            "+ * specific language governing permissions and limitations\n", 
            "+ * under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.transport.passthru.api;\n", 
            "+\n", 
            "+import java.io.ByteArrayOutputStream;\n", 
            "+import java.io.IOException;\n", 
            "+import java.io.OutputStream;\n", 
            "+import java.net.InetAddress;\n", 
            "+import java.net.NetworkInterface;\n", 
            "+import java.net.SocketException;\n", 
            "+import java.util.Enumeration;\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.Set;\n", 
            "+import java.util.StringTokenizer;\n", 
            "+\n", 
            "+import org.apache.axis2.AxisFault;\n", 
            "+import org.apache.axis2.addressing.EndpointReference;\n", 
            "+import org.apache.axis2.context.ConfigurationContext;\n", 
            "+import org.apache.axis2.context.MessageContext;\n", 
            "+import org.apache.axis2.description.AxisService;\n", 
            "+import org.apache.axis2.wsdl.WSDLConstants;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.http.HttpRequest;\n", 
            "+import org.apache.http.HttpResponse;\n", 
            "+import org.apache.http.HttpStatus;\n", 
            "+import org.apache.http.nio.NHttpServerConnection;\n", 
            "+import org.apache.http.protocol.HTTP;\n", 
            "+import org.apache.synapse.transport.nhttp.NHttpConfiguration;\n", 
            "+import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            "+import org.apache.synapse.transport.passthru.HttpGetRequestProcessor;\n", 
            "+import org.apache.synapse.transport.passthru.PassThroughConstants;\n", 
            "+import org.apache.synapse.transport.passthru.ProtocolState;\n", 
            "+import org.apache.synapse.transport.passthru.SourceContext;\n", 
            "+import org.apache.synapse.transport.passthru.SourceHandler;\n", 
            "+import org.apache.ws.commons.schema.XmlSchema;\n", 
            "+\n", 
            "+public class PassThroughNHttpGetProcessor implements HttpGetRequestProcessor {\n", 
            "+\n", 
            "+\tprivate static final Log log = LogFactory.getLog(PassThroughNHttpGetProcessor.class);\n", 
            "+\n", 
            "+\t \n", 
            "+\tprivate static final String LOCATION = \"Location\";\n", 
            "+\tprivate static final String CONTENT_TYPE = \"Content-Type\";\n", 
            "+\tprivate static final String TEXT_HTML = \"text/html\";\n", 
            "+\tprivate static final String TEXT_XML = \"text/xml\";\n", 
            "+\n", 
            "+\tprotected ConfigurationContext cfgCtx;\n", 
            "+\n", 
            "+\tprotected SourceHandler sourceHandler;\n", 
            "+\n", 
            "+\tpublic void init(ConfigurationContext cfgCtx, SourceHandler handler)\n", 
            "+\t\t\tthrows AxisFault {\n", 
            "+\n", 
            "+\t\tthis.cfgCtx = cfgCtx;\n", 
            "+\t\tthis.sourceHandler = handler;\n", 
            "+\t}\n", 
            "+\n", 
            "+\tpublic void process(HttpRequest request, HttpResponse response,\n", 
            "+\t\t\tMessageContext msgContext, NHttpServerConnection conn,\n", 
            "+\t\t\tOutputStream os, boolean isRestDispatching) {\n", 
            "+\n", 
            "+\t\tString uri = request.getRequestLine().getUri();\n", 
            "+\t\tString serviceName = getServiceName(request);\n", 
            "+\n", 
            "+\t\tMap<String, String> parameters = new HashMap<String, String>();\n", 
            "+\t\tint pos = uri.indexOf(\"?\");\n", 
            "+\t\tif (pos != -1) {\n", 
            "+\t\t\tmsgContext.setTo(new EndpointReference(uri.substring(0, pos)));\n", 
            "+\t\t\tStringTokenizer st = new StringTokenizer(uri.substring(pos + 1),\n", 
            "+\t\t\t\t\t\"&\");\n", 
            "+\t\t\twhile (st.hasMoreTokens()) {\n", 
            "+\t\t\t\tString param = st.nextToken();\n", 
            "+\t\t\t\tpos = param.indexOf(\"=\");\n", 
            "+\t\t\t\tif (pos != -1) {\n", 
            "+\t\t\t\t\tparameters.put(param.substring(0, pos),\n", 
            "+\t\t\t\t\t\t\tparam.substring(pos + 1));\n", 
            "+\t\t\t\t} else {\n", 
            "+\t\t\t\t\tparameters.put(param, null);\n", 
            "+\t\t\t\t}\n", 
            "+\t\t\t}\n", 
            "+\t\t} else {\n", 
            "+\t\t\tmsgContext.setTo(new EndpointReference(uri));\n", 
            "+\t\t}\n", 
            "+\n", 
            "+\t\tif (isServiceListBlocked(uri)) {\n", 
            "+\t\t\tresponse.setStatusCode(HttpStatus.SC_FORBIDDEN);\n", 
            "+\t\t\tsourceHandler.commitResponseHideExceptions(conn, response);\n", 
            "+            closeOutputStream(os);\n", 
            "+\t\t} else if (uri.equals(\"/favicon.ico\")) {\n", 
            "+\t\t\tresponse.setStatusCode(HttpStatus.SC_MOVED_PERMANENTLY);\n", 
            "+\t\t\tresponse.addHeader(LOCATION, \"http://ws.apache.org/favicon.ico\");\n", 
            "+\t\t\tsourceHandler.commitResponseHideExceptions(conn, response);\n", 
            "+            closeOutputStream(os);\n", 
            "+\t\t} else if (serviceName != null && parameters.containsKey(\"wsdl\")) {\n", 
            "+\t\t\tgenerateWsdl(response, msgContext, conn, os, serviceName, parameters);\n", 
            "+\t\t} else if (serviceName != null && parameters.containsKey(\"wsdl2\")) {\n", 
            "+\t\t\tgenerateWsdl2(response, msgContext, conn, os, serviceName);\n", 
            "+\t\t} else if (serviceName != null && parameters.containsKey(\"xsd\")) {\n", 
            "+\t\t\tgenerateXsd(response, msgContext, conn, os, serviceName, parameters);\n", 
            "+\t\t} else {\n", 
            "+\t\t\tmsgContext.setProperty(PassThroughConstants.REST_GET_DELETE_INVOKE, true);\n", 
            "+\t\t}\n", 
            "+\t}\n", 
            "+\n", 
            "+\tprivate void closeOutputStream(OutputStream os) {\n", 
            "+\t\ttry {\n", 
            "+\t\t\tos.flush();\n", 
            "+\t\t\tos.close();\n", 
            "+\t\t} catch (IOException ignore) {\n", 
            "+\t\t}\n", 
            "+\t}\n", 
            "+\n", 
            "+\t/**\n", 
            "+\t * Generate WSDL.\n", 
            "+\t *\n", 
            "+\t * @param response\n", 
            "+\t *            HttpResponse\n", 
            "+\t * @param msgContext\n", 
            "+\t *            MessageContext\n", 
            "+\t * @param conn\n", 
            "+\t *            NHttpServerConnection\n", 
            "+\t * @param os\n", 
            "+\t *            OutputStream\n", 
            "+\t * @param serviceName\n", 
            "+\t *            service name\n", 
            "+\t * @param parameters\n", 
            "+\t *            parameters\n", 
            "+\t */\n", 
            "+\tprotected void generateWsdl(HttpResponse response,\n", 
            "+\t\t\tMessageContext msgContext, NHttpServerConnection conn,\n", 
            "+\t\t\tOutputStream os, String serviceName,\n", 
            "+\t\t\tMap<String, String> parameters) {\n", 
            "+\t\tAxisService service = cfgCtx.getAxisConfiguration().getServices()\n", 
            "+\t\t\t\t.get(serviceName);\n", 
            "+\t\tif (service != null) {\n", 
            "+\t\t\ttry {\n", 
            "+\t\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n", 
            "+\t\t\t\tString parameterValue = parameters.get(\"wsdl\");\n", 
            "+\t\t\t\tif (parameterValue == null) {\n", 
            "+\t\t\t\t\tservice.printWSDL(baos, getIpAddress());\n", 
            "+\t\t\t\t} else {\n", 
            "+\t\t\t\t\t// here the parameter value should be the wsdl file name\n", 
            "+\t\t\t\t\tservice.printUserWSDL(baos, parameterValue);\n", 
            "+\t\t\t\t}\n", 
            "+\t\t\t\tSourceContext.updateState(conn, ProtocolState.WSDL_XSD_RESPONSE_DONE);\n", 
            "+\t\t\t\tresponse.addHeader(CONTENT_TYPE, TEXT_XML);\n", 
            "+\t\t\t\tsourceHandler.commitResponseHideExceptions(conn, response);\n", 
            "+\t\t\t\tos.write(baos.toByteArray());\n", 
            "+\t\t\t\tcloseOutputStream(os);\n", 
            "+\n", 
            "+\t\t\t} catch (Exception e) {\n", 
            "+\t\t\t\thandleBrowserException(response, conn, os,\n", 
            "+\t\t\t\t\t\t\"Error generating ?wsdl output for service : \"\n", 
            "+\t\t\t\t\t\t\t\t+ serviceName, e);\n", 
            "+\t\t\t}\n", 
            "+\t\t} else {\n", 
            "+\t\t\tmsgContext.setProperty(PassThroughConstants.REST_GET_DELETE_INVOKE, true);\n", 
            "+\t\t}\n", 
            "+\t}\n", 
            "+\n", 
            "+\t/**\n", 
            "+\t * Generate WSDL2.\n", 
            "+\t * \n", 
            "+\t * @param response\n", 
            "+\t *            HttpResponse\n", 
            "+\t * @param msgContext\n", 
            "+\t *            MessageContext\n", 
            "+\t * @param conn\n", 
            "+\t *            NHttpServerConnection\n", 
            "+\t * @param os\n", 
            "+\t *            OutputStream\n", 
            "+\t * @param serviceName\n", 
            "+\t *            service name\n", 
            "+\t */\n", 
            "+\tprotected void generateWsdl2(HttpResponse response,\n", 
            "+\t\t\tMessageContext msgContext, NHttpServerConnection conn,\n", 
            "+\t\t\tOutputStream os, String serviceName) {\n", 
            "+\t\tAxisService service = cfgCtx.getAxisConfiguration().getServices()\n", 
            "+\t\t\t\t.get(serviceName);\n", 
            "+\t\tif (service != null) {\n", 
            "+\t\t\tString parameterValue = (String) service\n", 
            "+\t\t\t\t\t.getParameterValue(\"serviceType\");\n", 
            "+\t\t\tif (\"proxy\".equals(parameterValue)\n", 
            "+\t\t\t\t\t&& !isWSDLProvidedForProxyService(service)) {\n", 
            "+\t\t\t\thandleBrowserException(response, conn, os,\n", 
            "+\t\t\t\t\t\t\"No WSDL was provided for the Service \" + serviceName\n", 
            "+\t\t\t\t\t\t\t\t+ \". A WSDL cannot be generated.\", null);\n", 
            "+\t\t\t}\n", 
            "+\t\t\ttry {\n", 
            "+\t\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n", 
            "+\t\t\t\tservice.printWSDL2(baos, getIpAddress());\n", 
            "+\t\t\t\tresponse.addHeader(CONTENT_TYPE, TEXT_XML);\n", 
            "+\t\t\t\tSourceContext.updateState(conn, ProtocolState.WSDL_XSD_RESPONSE_DONE);\n", 
            "+\t\t\t\tsourceHandler.commitResponseHideExceptions(conn, response);\n", 
            "+\t\t\t\tos.write(baos.toByteArray());\n", 
            "+\t\t\t\tcloseOutputStream(os);\n", 
            "+\n", 
            "+\t\t\t} catch (Exception e) {\n", 
            "+\t\t\t\thandleBrowserException(response, conn, os,\n", 
            "+\t\t\t\t\t\t\"Error generating ?wsdl2 output for service : \"\n", 
            "+\t\t\t\t\t\t\t\t+ serviceName, e);\n", 
            "+\t\t\t}\n", 
            "+\t\t} else {\n", 
            "+\t\t\tmsgContext.setProperty(PassThroughConstants.REST_GET_DELETE_INVOKE, true);\n", 
            "+\t\t}\n", 
            "+\t}\n", 
            "+\n", 
            "+\t/**\n", 
            "+\t * Returns the service name.\n", 
            "+\t * \n", 
            "+\t * @param request\n", 
            "+\t *            HttpRequest\n", 
            "+\t * @return service name as a String\n", 
            "+\t */\n", 
            "+\tprotected String getServiceName(HttpRequest request) {\n", 
            "+\t\tString uri = request.getRequestLine().getUri();\n", 
            "+\n", 
            "+\t\tString servicePath = cfgCtx.getServiceContextPath();\n", 
            "+\t\tif (!servicePath.startsWith(\"/\")) {\n", 
            "+\t\t\tservicePath = \"/\" + servicePath;\n", 
            "+\t\t}\n", 
            "+\n", 
            "+\t\tString serviceName = null;\n", 
            "+\t\tif (uri.startsWith(servicePath)) {\n", 
            "+\t\t\tserviceName = uri.substring(servicePath.length());\n", 
            "+\t\t\tif (serviceName.startsWith(\"/\")) {\n", 
            "+\t\t\t\tserviceName = serviceName.substring(1);\n", 
            "+\t\t\t}\n", 
            "+\t\t\tif (serviceName.contains(\"?\")) {\n", 
            "+\t\t\t\tserviceName = serviceName\n", 
            "+\t\t\t\t\t\t.substring(0, serviceName.indexOf(\"?\"));\n", 
            "+\t\t\t}\n", 
            "+\t\t} else {\n", 
            "+\t\t\t// this may be a custom URI\n", 
            "+\t\t\tString incomingURI = request.getRequestLine().getUri();\n", 
            "+\n", 
            "+\t\t\tMap serviceURIMap = (Map) cfgCtx\n", 
            "+\t\t\t\t\t.getProperty(NhttpConstants.EPR_TO_SERVICE_NAME_MAP);\n", 
            "+\t\t\tif (serviceURIMap != null) {\n", 
            "+\t\t\t\tSet keySet = serviceURIMap.keySet();\n", 
            "+\t\t\t\tfor (Object key : keySet) {\n", 
            "+\t\t\t\t\tif (incomingURI.toLowerCase().contains(\n", 
            "+\t\t\t\t\t\t\t((String) key).toLowerCase())) {\n", 
            "+\t\t\t\t\t\treturn (String) serviceURIMap.get(key);\n", 
            "+\t\t\t\t\t}\n", 
            "+\t\t\t\t}\n", 
            "+\t\t\t}\n", 
            "+\t\t}\n", 
            "+\n", 
            "+\t\tif (serviceName != null) {\n", 
            "+\t\t\tint opnStart = serviceName.indexOf(\"/\");\n", 
            "+\t\t\tif (opnStart != -1) {\n", 
            "+\t\t\t\tserviceName = serviceName.substring(0, opnStart);\n", 
            "+\t\t\t}\n", 
            "+\t\t}\n", 
            "+\t\treturn serviceName;\n", 
            "+\t}\n", 
            "+\n", 
            "+\t/**\n", 
            "+\t * Generates Schema.\n", 
            "+\t *\n", 
            "+\t * @param response\n", 
            "+\t *            HttpResponse\n", 
            "+\t * @param messageCtx\n", 
            "+\t *            Current MessageContext\n", 
            "+\t * @param conn\n", 
            "+\t *            NHttpServerConnection\n", 
            "+\t * @param os\n", 
            "+\t *            OutputStream\n", 
            "+\t * @param serviceName\n", 
            "+\t *            service name\n", 
            "+\t * @param parameters\n", 
            "+\t *            url parameters\n", 
            "+\t */\n", 
            "+\tprotected void generateXsd(HttpResponse response,\n", 
            "+\t\t\tMessageContext messageCtx, NHttpServerConnection conn,\n", 
            "+\t\t\tOutputStream os, String serviceName,\n", 
            "+\t\t\tMap<String, String> parameters) {\n", 
            "+\t\tif (parameters.get(\"xsd\") == null || \"\".equals(parameters.get(\"xsd\"))) {\n", 
            "+\t\t\tAxisService service = cfgCtx.getAxisConfiguration().getServices()\n", 
            "+\t\t\t\t\t.get(serviceName);\n", 
            "+\t\t\tif (service != null) {\n", 
            "+\t\t\t\ttry {\n", 
            "+\t\t\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n", 
            "+\t\t\t\t\tservice.printSchema(baos);\n", 
            "+\t\t\t\t\tresponse.addHeader(CONTENT_TYPE, TEXT_XML);\n", 
            "+\t\t\t\t\tSourceContext.updateState(conn, ProtocolState.WSDL_XSD_RESPONSE_DONE);\n", 
            "+\t\t\t\t\tsourceHandler.commitResponseHideExceptions(conn, response);\n", 
            "+\t\t\t\t\tos.write(baos.toByteArray());\n", 
            "+\t\t\t\t\tcloseOutputStream(os);\n", 
            "+\n", 
            "+\t\t\t\t} catch (Exception e) {\n", 
            "+\t\t\t\t\thandleBrowserException(response, conn, os,\n", 
            "+\t\t\t\t\t\t\t\"Error generating ?xsd output for service : \"\n", 
            "+\t\t\t\t\t\t\t\t\t+ serviceName, e);\n", 
            "+\t\t\t\t}\n", 
            "+\t\t\t} else {\n", 
            "+\t\t\t\tmessageCtx.setProperty(PassThroughConstants.REST_GET_DELETE_INVOKE,\n", 
            "+\t\t\t\t\t\ttrue);\n", 
            "+\t\t\t}\n", 
            "+\n", 
            "+\t\t} else {\n", 
            "+\t\t\t// cater for named XSDs - check for the xsd name\n", 
            "+\t\t\tString schemaName = parameters.get(\"xsd\");\n", 
            "+\t\t\tAxisService service = cfgCtx.getAxisConfiguration().getServices()\n", 
            "+\t\t\t\t\t.get(serviceName);\n", 
            "+\n", 
            "+\t\t\tif (service != null) {\n", 
            "+\t\t\t\t// run the population logic just to be sure\n", 
            "+\t\t\t\tservice.populateSchemaMappings();\n", 
            "+\t\t\t\t// write out the correct schema\n", 
            "+\t\t\t\tMap schemaTable = service.getSchemaMappingTable();\n", 
            "+\t\t\t\tXmlSchema schema = (XmlSchema) schemaTable.get(schemaName);\n", 
            "+\t\t\t\tif (schema == null) {\n", 
            "+\t\t\t\t\tint dotIndex = schemaName.indexOf('.');\n", 
            "+\t\t\t\t\tif (dotIndex > 0) {\n", 
            "+\t\t\t\t\t\tString schemaKey = schemaName.substring(0, dotIndex);\n", 
            "+\t\t\t\t\t\tschema = (XmlSchema) schemaTable.get(schemaKey);\n", 
            "+\t\t\t\t\t}\n", 
            "+\t\t\t\t}\n", 
            "+\t\t\t\t// schema found - write it to the stream\n", 
            "+\t\t\t\tif (schema != null) {\n", 
            "+\t\t\t\t\ttry {\n", 
            "+\t\t\t\t\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n", 
            "+\t\t\t\t\t\tschema.write(baos);\n", 
            "+\t\t\t\t\t\tresponse.addHeader(CONTENT_TYPE, TEXT_XML);\n", 
            "+\t\t\t\t\t\tsourceHandler.commitResponseHideExceptions(conn,\n", 
            "+\t\t\t\t\t\t\t\tresponse);\n", 
            "+\t\t\t\t\t\tos.write(baos.toByteArray());\n", 
            "+\t\t\t\t\t\tcloseOutputStream(os);\n", 
            "+\t\t\t\t\t} catch (Exception e) {\n", 
            "+\t\t\t\t\t\thandleBrowserException(response, conn, os,\n", 
            "+\t\t\t\t\t\t\t\t\"Error generating named ?xsd output for service : \"\n", 
            "+\t\t\t\t\t\t\t\t\t\t+ serviceName, e);\n", 
            "+\t\t\t\t\t}\n", 
            "+\n", 
            "+\t\t\t\t} else {\n", 
            "+\t\t\t\t\t// no schema available by that name - send 404\n", 
            "+\t\t\t\t\tresponse.setStatusCode(HttpStatus.SC_NOT_FOUND);\n", 
            "+\t\t\t\t\tcloseOutputStream(os);\n", 
            "+\t\t\t\t}\n", 
            "+\t\t\t} else {\n", 
            "+\t\t\t\tmessageCtx.setProperty(PassThroughConstants.REST_GET_DELETE_INVOKE,\n", 
            "+\t\t\t\t\t\ttrue);\n", 
            "+\t\t\t}\n", 
            "+\t\t}\n", 
            "+\t}\n", 
            "+\n", 
            "+\t\n", 
            "+\t/**\n", 
            "+     * Handles browser exception.\n", 
            "+     *\n", 
            "+     * @param response HttpResponse\n", 
            "+     * @param conn     NHttpServerConnection\n", 
            "+     * @param os       OutputStream\n", 
            "+     * @param msg      message\n", 
            "+     * @param e        Exception\n", 
            "+     */\n", 
            "+    protected void handleBrowserException(HttpResponse response,\n", 
            "+                                          NHttpServerConnection conn, OutputStream os,\n", 
            "+                                          String msg, Exception e) {\n", 
            "+        if (e == null) {\n", 
            "+            log.error(msg);\n", 
            "+        } else {\n", 
            "+            log.error(msg, e);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (!response.containsHeader(HTTP.TRANSFER_ENCODING)) {\n", 
            "+            response.setStatusCode(HttpStatus.SC_INTERNAL_SERVER_ERROR);\n", 
            "+            response.setReasonPhrase(msg);\n", 
            "+            response.addHeader(CONTENT_TYPE, TEXT_HTML);\n", 
            "+            sourceHandler.commitResponseHideExceptions(conn, response);\n", 
            "+            try {\n", 
            "+                os.write(msg.getBytes());\n", 
            "+                os.close();\n", 
            "+            } catch (IOException ignore) {\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        if (conn != null) {\n", 
            "+            try {\n", 
            "+                conn.shutdown();\n", 
            "+            } catch (IOException ignore) {\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+    \n", 
            "+    \n", 
            "+\t/**\n", 
            "+\t * Is the incoming URI is requesting service list and\n", 
            "+\t * http.block_service_list=true in nhttp.properties\n", 
            "+\t * \n", 
            "+\t * @param incomingURI\n", 
            "+\t *            incoming URI\n", 
            "+\t * @return whether to proceed with incomingURI\n", 
            "+\t */\n", 
            "+\tprotected boolean isServiceListBlocked(String incomingURI) {\n", 
            "+\t\tString isBlocked = NHttpConfiguration.getInstance()\n", 
            "+\t\t\t\t.isServiceListBlocked();\n", 
            "+\n", 
            "+\t\treturn ((\"/services\").equals(incomingURI) || (\"/services\" + \"/\")\n", 
            "+\t\t\t\t.equals(incomingURI)) && Boolean.parseBoolean(isBlocked);\n", 
            "+\t}\n", 
            "+\t\n", 
            "+\t\n", 
            "+    /**\n", 
            "+     * Checks whether a wsdl is provided for a proxy service.\n", 
            "+     *\n", 
            "+     * @param service AxisService\n", 
            "+     * @return whether the wsdl is provided or not\n", 
            "+     */\n", 
            "+    protected boolean isWSDLProvidedForProxyService(AxisService service) {\n", 
            "+        boolean isWSDLProvided = false;\n", 
            "+        if (service.getParameterValue(WSDLConstants.WSDL_4_J_DEFINITION) != null ||\n", 
            "+                service.getParameterValue(WSDLConstants.WSDL_20_DESCRIPTION) != null) {\n", 
            "+            isWSDLProvided = true;\n", 
            "+        }\n", 
            "+        return isWSDLProvided;\n", 
            "+    }\n", 
            "+\n", 
            "+\t\n", 
            "+\t   /**\n", 
            "+     * Whatever this method returns as the IP is ignored by the actual http/s listener when\n", 
            "+     * its getServiceEPR is invoked. This was originally copied from axis2\n", 
            "+     *\n", 
            "+     * @return Returns String.\n", 
            "+     * @throws java.net.SocketException if the socket can not be accessed\n", 
            "+     */\n", 
            "+    protected static String getIpAddress() throws SocketException {\n", 
            "+        Enumeration e = NetworkInterface.getNetworkInterfaces();\n", 
            "+        String address = \"127.0.0.1\";\n", 
            "+\n", 
            "+        while (e.hasMoreElements()) {\n", 
            "+            NetworkInterface netface = (NetworkInterface) e.nextElement();\n", 
            "+            Enumeration addresses = netface.getInetAddresses();\n", 
            "+\n", 
            "+            while (addresses.hasMoreElements()) {\n", 
            "+                InetAddress ip = (InetAddress) addresses.nextElement();\n", 
            "+                if (!ip.isLoopbackAddress() && isIP(ip.getHostAddress())) {\n", 
            "+                    return ip.getHostAddress();\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return address;\n", 
            "+    }\n", 
            "+    \n", 
            "+    protected static boolean isIP(String hostAddress) {\n", 
            "+        return hostAddress.split(\"[.]\").length == 4;\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/api/PassThroughNHttpGetProcessor.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/api/PassThroughNHttpGetProcessor.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-83,7 +83,7", 
          "lines": [
            "                     System.currentTimeMillis());\n", 
            "         \t \n", 
            "             if (!SourceContext.assertState(conn, ProtocolState.REQUEST_READY) &&\n", 
            "-                    !SourceContext.assertState(conn, ProtocolState.WSDL_RESPONSE_DONE)) {\n", 
            "+                    !SourceContext.assertState(conn, ProtocolState.WSDL_XSD_RESPONSE_DONE)) {\n", 
            "                 handleInvalidState(conn, \"Request received\");\n", 
            "                 return;\n", 
            "             }\n"
          ]
        }, 
        {
          "locn": "-192,7 +192,7", 
          "lines": [
            "             ProtocolState protocolState = SourceContext.getState(conn);\n", 
            "             \n", 
            "             //special case to handle WSDLs\n", 
            "-            if(protocolState == ProtocolState.WSDL_RESPONSE_DONE){\n", 
            "+            if(protocolState == ProtocolState.WSDL_XSD_RESPONSE_DONE){\n", 
            "             \t// we need to shut down if the shutdown flag is set\n", 
            "             \t HttpContext context = conn.getContext();\n", 
            "             \t ContentOutputBuffer outBuf = (ContentOutputBuffer) context.getAttribute(\n"
          ]
        }, 
        {
          "locn": "-433,5 +433,26", 
          "lines": [
            "         }\n", 
            "         log.error(errorMessage, e);\n", 
            "     }\n", 
            "+    \n", 
            "+    \n", 
            "+    /**\n", 
            "+     * Commit the response to the connection. Processes the response through the configured\n", 
            "+     * HttpProcessor and submits it to be sent out. This method hides any exceptions and is targetted\n", 
            "+     * for non critical (i.e. browser requests etc) requests, which are not core messages\n", 
            "+     * @param conn the connection being processed\n", 
            "+     * @param response the response to commit over the connection\n", 
            "+     */\n", 
            "+    public void commitResponseHideExceptions(\n", 
            "+            final NHttpServerConnection conn, final HttpResponse response) {\n", 
            "+        try {\n", 
            "+            conn.suspendInput();\n", 
            "+            sourceConfiguration.getHttpProcessor().process(response, conn.getContext());\n", 
            "+            conn.submitResponse(response);\n", 
            "+        } catch (HttpException e) {\n", 
            "+            handleException(\"Unexpected HTTP protocol error : \" + e.getMessage(), e, conn);\n", 
            "+        } catch (IOException e) {\n", 
            "+            handleException(\"IO error submiting response : \" + e.getMessage(), e, conn);\n", 
            "+        }\n", 
            "+    }\n", 
            " \n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceHandler.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-200,7 +200,7", 
          "lines": [
            " \t\tSourceContext info = (SourceContext) request.getConnection().getContext().\n", 
            "                 getAttribute(SourceContext.CONNECTION_INFORMATION);\n", 
            " \t\tif (info != null &&\n", 
            "-\t\t    info.getState().equals(ProtocolState.WSDL_RESPONSE_DONE) ||\n", 
            "+\t\t    info.getState().equals(ProtocolState.WSDL_XSD_RESPONSE_DONE) ||\n", 
            " \t\t    (msgContext.getProperty(PassThroughConstants.WSDL_GEN_HANDLED) != null &&\n", 
            "                     Boolean.TRUE.equals((msgContext.getProperty(PassThroughConstants.WSDL_GEN_HANDLED))))) {\n", 
            " \t\t\treturn;\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-44,5 +44,5", 
          "lines": [
            "     /** The connection is closed */\n", 
            "     CLOSED,\n", 
            "     /** WSDL response has been sent */\n", 
            "-    WSDL_RESPONSE_DONE\n", 
            "+    WSDL_XSD_RESPONSE_DONE\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ProtocolState.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ProtocolState.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-118,12 +118,6", 
          "lines": [
            "             response.setStatusCode(HttpStatus.SC_MOVED_PERMANENTLY);\n", 
            "             response.addHeader(LOCATION, \"http://ws.apache.org/favicon.ico\");\n", 
            "             serverHandler.commitResponseHideExceptions(conn, response);\n", 
            "-\n", 
            "-//        } else if (!uri.startsWith(servicePath)) {\n", 
            "-//            response.setStatusCode(HttpStatus.SC_MOVED_PERMANENTLY);\n", 
            "-//            response.addHeader(LOCATION, servicePath + \"/\");\n", 
            "-//            serverHandler.commitResponseHideExceptions(conn, response);\n", 
            "-\n", 
            "         } else if (serviceName != null && parameters.containsKey(\"wsdl\")) {\n", 
            "             generateWsdl(request, response, msgContext,\n", 
            "                     conn, os, serviceName, parameters, isRestDispatching);\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/DefaultHttpGetProcessor.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/DefaultHttpGetProcessor.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-192,6 +192,7", 
          "lines": [
            "     <transportReceiver name=\"http\" class=\"org.apache.synapse.transport.passthru.PassThroughHttpListener\">\n", 
            "         <parameter name=\"port\">8280</parameter>\n", 
            "         <parameter name=\"non-blocking\">true</parameter>\n", 
            "+        <parameter name=\"httpGetProcessor\" locked=\"false\">org.apache.synapse.transport.passthru.api.PassThroughNHttpGetProcessor</parameter>\n", 
            "         <!--parameter name=\"bind-address\" locked=\"false\">hostname or IP address</parameter-->\n", 
            "         <!--parameter name=\"WSDLEPRPrefix\" locked=\"false\">https://apachehost:port/somepath</parameter-->\n", 
            "     </transportReceiver>\n"
          ]
        }, 
        {
          "locn": "-199,6 +200,7", 
          "lines": [
            "     <transportReceiver name=\"https\" class=\"org.apache.synapse.transport.passthru.PassThroughHttpSSLListener\">\n", 
            "         <parameter name=\"port\" locked=\"false\">8243</parameter>\n", 
            "         <parameter name=\"non-blocking\" locked=\"false\">true</parameter>\n", 
            "+        <parameter name=\"httpGetProcessor\" locked=\"false\">org.apache.synapse.transport.passthru.api.PassThroughNHttpGetProcessor</parameter>\n", 
            "         <parameter name=\"keystore\" locked=\"false\">\n", 
            "             <KeyStore>\n", 
            "                 <Location>modules/integration/src/test/resources/identity.jks</Location>\n"
          ]
        }
      ], 
      "to": "java/modules/integration/src/test/resources/axis2Xml/synapse/axis2_def.xml", 
      "from": "java/modules/integration/src/test/resources/axis2Xml/synapse/axis2_def.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-189,6 +189,7", 
          "lines": [
            "     <transportReceiver name=\"http\" class=\"org.apache.synapse.transport.passthru.PassThroughHttpListener\">\n", 
            "         <parameter name=\"port\">8280</parameter>\n", 
            "         <parameter name=\"non-blocking\">true</parameter>\n", 
            "+\t    <parameter name=\"httpGetProcessor\" locked=\"false\">org.apache.synapse.transport.passthru.api.PassThroughNHttpGetProcessor</parameter>\n", 
            "         <!--parameter name=\"bind-address\" locked=\"false\">hostname or IP address</parameter-->\n", 
            "         <!--parameter name=\"WSDLEPRPrefix\" locked=\"false\">https://apachehost:port/somepath</parameter-->\n", 
            "         <!-- paramter name=\"priorityConfigFile\" locked=\"false\">location of priority configuration file<parameter-->\n"
          ]
        }, 
        {
          "locn": "-197,9 +198,11", 
          "lines": [
            "     <!-- the non blocking https transport based on HttpCore + SSL-NIO extensions -->\n", 
            "     <transportReceiver name=\"https\" class=\"org.apache.synapse.transport.passthru.PassThroughHttpSSLListener\">\n", 
            "         <parameter name=\"port\" locked=\"false\">8243</parameter>\n", 
            "+        <parameter name=\"non-blocking\" locked=\"false\">true</parameter>\n", 
            "+        <parameter name=\"httpGetProcessor\" locked=\"false\">org.apache.synapse.transport.passthru.api.PassThroughNHttpGetProcessor</parameter>\n", 
            "         <!--parameter name=\"bind-address\" locked=\"false\">hostname or IP address</parameter-->\n", 
            "         <!--parameter name=\"WSDLEPRPrefix\" locked=\"false\">http://apachehost:port/somepath</parameter-->\n", 
            "-        <parameter name=\"non-blocking\" locked=\"false\">true</parameter>\n", 
            "+\n", 
            "         <parameter name=\"keystore\" locked=\"false\">\n", 
            "             <KeyStore>\n", 
            "                 <Location>lib/identity.jks</Location>\n"
          ]
        }, 
        {
          "locn": "-585,4 +588,4", 
          "lines": [
            "         <phase name=\"MessageOut\"/>\n", 
            "         <phase name=\"Security\"/>\n", 
            "     </phaseOrder>\n", 
            "-</axisconfig>\n", 
            "\\ No newline at end of file\n", 
            "+</axisconfig>\n"
          ]
        }
      ], 
      "to": "java/repository/conf/axis2.xml", 
      "from": "java/repository/conf/axis2.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-14,6 +14,7", 
          "lines": [
            "                         <arg expression=\"get-property('uri.var.symbol')\"/>\n", 
            "                     </args>\n", 
            "                 </payloadFactory>\n", 
            "+                <header name=\"Action\" value=\"urn:getQuote\"/>\n", 
            "                 <send>\n", 
            "                     <endpoint>\n", 
            "                         <address uri=\"http://localhost:9000/services/SimpleStockQuoteService\" format=\"soap11\"/>\n"
          ]
        }, 
        {
          "locn": "-28,6 +29,7", 
          "lines": [
            "             <inSequence>\n", 
            "                 <property name=\"FORCE_SC_ACCEPTED\" value=\"true\" scope=\"axis2\"/>\n", 
            "                 <property name=\"OUT_ONLY\" value=\"true\"/>\n", 
            "+                <header name=\"Action\" value=\"urn:placeOrder\"/>\n", 
            "                 <send>\n", 
            "                     <endpoint>\n", 
            "                         <address uri=\"http://localhost:9000/services/SimpleStockQuoteService\" format=\"soap11\"/>\n"
          ]
        }
      ], 
      "to": "java/repository/conf/sample/synapse_sample_800.xml", 
      "from": "java/repository/conf/sample/synapse_sample_800.xml"
    }
  ], 
  "id": "1503049"
}