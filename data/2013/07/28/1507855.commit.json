{
  "when": "2013-07-28T17:35:59-04:00", 
  "message": "added amqp transport.", 
  "who": "rajikak", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-47,6 +47,7", 
          "lines": [
            "         <module>core/pipe</module>\n", 
            "         <module>core/vfs</module>\n", 
            "         <module>optional/fix</module>\n", 
            "+\t\t<module>optional/amqp</module>\n", 
            "     </modules>\n", 
            " \n", 
            "     <dependencies>\n"
          ]
        }
      ], 
      "to": "java/modules/transports/pom.xml", 
      "from": "java/modules/transports/pom.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-49,6 +49,11", 
          "lines": [
            "                     exchanges, industry utilities and associations, institutional investors, and IT\n", 
            "                     providers around the world.\n", 
            " \t\t\t\t</li>\n", 
            "+                <li>\n", 
            "+                    A AMQP transport which support the AMQP protocol.\n", 
            "+                    <a class=\"externalLink\" href=\"http://www.amqp.org/\">AMQP</a>  is a messaging\n", 
            "+                    protocol.\n", 
            "+                </li>\n", 
            " \t\t\t</ul>\n", 
            " \t\t\t<p>Note that while these transports are developed as part of the Synapse project,\n", 
            "                 they can be used with any Axis2 based application.\n"
          ]
        }, 
        {
          "locn": "-141,6 +146,20", 
          "lines": [
            " \t\t\t\t\t\t</li>\n", 
            " \t\t\t\t\t</ul>\n", 
            " \t\t\t\t</li>\n", 
            "+                <li>\n", 
            "+                    <a href=\"#amqp_transport\">AMQP transport</a>\n", 
            "+                    <ul>\n", 
            "+                        <li>\n", 
            "+                            <a href=\"#setting_up_the_amqp_transport\">Setting up the AMQP Transport</a>\n", 
            "+                        </li>\n", 
            "+                        <li>\n", 
            "+                            <a href=\"#amqp_transport_parameters\">AMQP Transport Parameters</a>\n", 
            "+                        </li>\n", 
            "+                        <li>\n", 
            "+                            <a href=\"#amqp_transport_ex\">Sample Configurations</a>\n", 
            "+                        </li>\n", 
            "+                    </ul>\n", 
            "+                </li>\n", 
            " \t\t\t</ul>\n", 
            " \t\t</section>\n", 
            " \t    <section name=\"Non-blocking HTTP transport\" id=\"Non-blocking_HTTP_transport\">\n"
          ]
        }, 
        {
          "locn": "-815,6 +834,355", 
          "lines": [
            " \t\t\t\t</dl>\n", 
            " \t\t\t</subsection>\n", 
            " \t\t</section>\n", 
            "+        <section name=\"AMQP transport\" id=\"amqp_transport\">\n", 
            "+            <subsection name=\"Setting Up the Transport\" id=\"setting_up_the_amqp_transport\">\n", 
            "+                <p>\n", 
            "+                    AMQP transport is based on the excellent\n", 
            "+                    <a href=\"http://www.rabbitmq.com/java-client.html\">Java AMQP client</a> library from\n", 
            "+                    <a class=\"externalLink\" href=\"http://www.rabbitmq.com/\">RabbitMQ</a>.\n", 
            "+                    Due to the license, the client library doesn't ship with Apache Synapse. In order to use\n", 
            "+                    the AMQP transport download the RabbitMQ Java client library and copy\n", 
            "+                    the client library(rabbitmq-client.jar) into Synapse classpath(lib folder).\n", 
            "+                </p>\n", 
            "+                <p>\n", 
            "+                    To enable the AMQP transport, uncomment the AMQP transport sender and AMQP transport\n", 
            "+                    receiver configurations in the SYNAPSE_HOME/repository/conf/axis2.xml.\n", 
            "+                </p>\n", 
            "+            </subsection>\n", 
            "+            <subsection name=\"AMQP Transport Parameters\" id=\"amqp_transport_parameters\">\n", 
            "+                <p>\n", 
            "+                    Following parameters can be configured as part of transport receiver, sender or\n", 
            "+                    as part of the proxy service parameter or amqp endpoint deceleration.\n", 
            "+                </p>\n", 
            "+                <dl>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.Uri</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The connection URL for the broker of the form\n", 
            "+                        amqp://userName:password@hostName:portNumber/virtualHost</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.BrokerList</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The list of broker of the form, host1:port1,host2:port2... which will be used\n", 
            "+                        as the address array in AMQP connection to the broker</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ExchangeName</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The name of the exchange to connect</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.IsExchangeDurable</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Should the exchange be declared as durable?</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.IsExchangeAutoDelete</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Should the exchange be auto delete? Possible values are true or false</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ChannelPreFetchSize</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The channel pre fetch size for fair dispatch</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ChannelPreFetchCountSize</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The channel prefetch count for fair dispatch</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ExchangeType</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Type of the exchange to use. Possible values are, fanout, direct, header or topic</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ExchangeInternal</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Should the exchange be declared as internal? Possible values are true or false </dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.BindExchange</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The name of the exchange that the publisher/consumer should publish/consume message to.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.BindingKeys</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The comma separated binding keys this queue should be bound into exchange</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.RoutingKey</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The routing key to be used by the publisher.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ConsumerTx</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Use transactions at consumer side if set to true. By default this will be\n", 
            "+                        considered false and explicit acknowledgement will be done</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.QueueName</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The name of the queue</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.IsQueueDurable</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Should the queue declare as durable? Possible values are true or false.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.IsQueueRestricted</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Should the queue declare as restricted? Possible values are true or false.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.IsQueueAutoDelete</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Should the queue declare as auto delete when it's no longer in use?.\n", 
            "+                    Possible values are true or false.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.OperateOnBlockingMode</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>True if the polling task should wait until it process  the accepted\n", 
            "+                        messages. This can be used in conjunction with a single thread polling\n", 
            "+                        task(in the whole transport, i.e. only a single AMQP proxy per flow)\n", 
            "+                        to achieve in order delivery</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.InitialReconnectDuration</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>If a polling task encounter an exception due to some reason(most probably\n", 
            "+                        due to broker outage) the number of milliseconds it should be suspended\n", 
            "+                        before next re-try</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ReconnectionProgressionFactor</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>If the polling task fails again after the initial re-connection duration,\n", 
            "+                        next suspend duration will be calculated using this.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.MaximumReconnectionDuration</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The maximum duration to suspend the polling task in case of an error. The\n", 
            "+                        current suspend duration will reach this value by following the series;\n", 
            "+                        transport.amqp.ReconnectionProgressionFactor * transport.amqp.InitialReconnectDuration.\n", 
            "+                        This upper bound is there because nobody wants to wait a long time until the\n", 
            "+                        next re-try if the broker is alive.\n", 
            "+                    </dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ConnectionFactoryName</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The connection factory to be used either with consumer or producer.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ResponseConnectionFactoryName</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>In a two-way scenario which connection factory of the senders' should be used\n", 
            "+                        to send the response</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ScheduledTaskInitialDelay</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The initial delay(in milliseconds) that the polling task should delay before initial attempt</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ScheduledTaskDelay</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The delay(in milliseconds) that the polling task should delay before next attempt.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ScheduledTaskTimeUnit</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>The time unit which should use to calculate,\n", 
            "+                        transport.amqp.ScheduledTaskInitialDelay and transport.amqp.ScheduledTaskDelay.</dd>\n", 
            "+                    <dt>\n", 
            "+                    <tt>transport.amqp.NoOfConcurrentConsumers</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Number of concurrent consumers per polling task.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.NoOfDispatchingTask</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Number of dispatching task to use any request messages to actual processing task.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>transport.amqp.ContentType</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Configure the content type as a service parameter.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_CONTENT_TYPE</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Message context property to set the AMQP message content type.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_CONTENT_ENCODING</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd> Message context property to set the AMQP message encoding</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_HEADER_*</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Specify any AMQP headers as message context properties using AMQP_HEADER_*</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_DELIVERY_MODE</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Message context property to set the AMQP message delivery mode</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_PRIORITY</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Message context property to set the AMQP message priority.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_CORRELATION_ID</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Message context property to set the AMQP message correlation id</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_REPLY_TO</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Message context property to set the AMQP message reply to header.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_EXPIRATION</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Message context property to set the AMQP expiration.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_MESSAGE_ID</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Message context property to set the message id of the AMQP message</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_TIME_STAMP</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Message context property to set the timestamp of the AMQP message.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_TYPE</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Message context property to set the type of the AMQP message</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>connection-factory-pool-size</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>A system property to set the worker pool size of the connection factory executor service.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>worker-pool-size</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>A system property to set the worker pool size used by deployed services for polling broker.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>semaphore-time-out</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>A system property to set the time out(in seconds) of semaphore which waits for\n", 
            "+                    a response.</dd>\n", 
            "+                    <dt>\n", 
            "+                        <tt>AMQP_PRODUCER_TX</tt>\n", 
            "+                    </dt>\n", 
            "+                    <dd>Use transactions at producer side. Possible values are tx(for blocking transactions),\n", 
            "+                        lwpc(for light weight producer connections).</dd>\n", 
            "+                </dl>\n", 
            "+            </subsection>\n", 
            "+            <subsection name=\"Sample Configurations\" id=\"amqp_transport_ex\">\n", 
            "+                    <p>Producer example</p>\n", 
            "+                    <div class=\"xmlConf\">\n", 
            "+&lt;proxy name=\"ProducerProxy\" transports=\"http\"&gt;\n", 
            "+    &lt;target&gt;\n", 
            "+        &lt;inSequence&gt;\n", 
            "+            &lt;property action=\"set\" name=\"OUT_ONLY\" value=\"true\"/&gt;\n", 
            "+            &lt;property name=\"PRESERVE_WS_ADDRESSING\" value=\"true\"/&gt;\"\n", 
            "+            &lt;log level=\"custom\"&gt;\n", 
            "+                &lt;property name=\"status\" value=\"At ProducerProxy\"/&gt;\n", 
            "+            &lt;/log&gt;\n", 
            "+        &lt;/inSequence&gt;\n", 
            "+        &lt;endpoint&gt;\n", 
            "+            &lt;!--use the defined connection factory in AMQP transport sender--&gt;\n", 
            "+            &lt;address\n", 
            "+                uri=\"amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer&amp;transport.amqp.QueueName=ProducerProxy\"/&gt;\n", 
            "+        &lt;/endpoint&gt;\n", 
            "+        &lt;outSequence&gt;\n", 
            "+            &lt;send/&gt;\n", 
            "+        &lt;/outSequence&gt;\n", 
            "+    &lt;/target&gt;\n", 
            "+&lt;/proxy&gt;\n", 
            "+                    </div>\n", 
            "+                    <p>Consumer example</p>\n", 
            "+                    <div class=\"xmlConf\">\n", 
            "+&lt;proxy name=\"ConsumerProxy\" transports=\"amqp\"&gt;\n", 
            "+    &lt;target&gt;\n", 
            "+        &lt;inSequence&gt;\n", 
            "+            &lt;property action=\"set\" name=\"OUT_ONLY\" value=\"true\"/&gt;\n", 
            "+            &lt;log level=\"custom\"&gt;\n", 
            "+                &lt;property name=\"status\" value=\"At ConsumerProxy\"/&gt;\n", 
            "+            &lt;/log&gt;\n", 
            "+        &lt;/inSequence&gt;\n", 
            "+        &lt;endpoint&gt;\n", 
            "+            &lt;address uri=\"http://localhost:9000/services/SimpleStockQuoteService\"/&gt;\n", 
            "+        &lt;/endpoint&gt;\n", 
            "+        &lt;outSequence&gt;\n", 
            "+            &lt;send/&gt;\n", 
            "+        &lt;/outSequence&gt;\n", 
            "+    &lt;/target&gt;\n", 
            "+    &lt;parameter name=\"transport.amqp.ConnectionFactoryName\"&gt;consumer&lt;/parameter&gt;\n", 
            "+    &lt;parameter name=\"transport.amqp.QueueName\"&gt;ProducerProxy&lt;/parameter&gt;\n", 
            "+&lt;/proxy&gt;\n", 
            "+                    </div>\n", 
            "+                    <p>Routing example</p>\n", 
            "+                    <div class=\"xmlConf\">\n", 
            "+&lt;proxy name=\"DirectPublisherProxy\" transports=\"http\"&gt;\n", 
            "+    &lt;target&gt;\n", 
            "+    &lt;inSequence&gt;\n", 
            "+        &lt;property action=\"set\" name=\"OUT_ONLY\" value=\"true\"/&gt;\n", 
            "+        &lt;log level=\"custom\"&gt;\n", 
            "+            &lt;property name=\"status\" value=\"At DirectPublisherProxy\"/&gt;\n", 
            "+        &lt;/log&gt;\n", 
            "+    &lt;/inSequence&gt;\n", 
            "+    &lt;endpoint&gt;\n", 
            "+        &lt;!--use the defined connection factory in AMQP transport sender, note how we don't provide\n", 
            "+            any queue name because this is bind to the exchange--&gt;\n", 
            "+        &lt;address\n", 
            "+            uri=\"amqp://?transport.amqp.ConnectionFactoryName=publisher&amp;transport.amqp.ExchangeName=direct_logs&amp;transport.amqp.ExchangeType=direct&amp;transport.amqp.RoutingKey=error\"/&gt;\n", 
            "+    &lt;/endpoint&gt;\n", 
            "+    &lt;outSequence&gt;\n", 
            "+        &lt;send/&gt;\n", 
            "+    &lt;/outSequence&gt;\n", 
            "+    &lt;/target&gt;\n", 
            "+&lt;/proxy&gt;\n", 
            " \n", 
            "+&lt;proxy name=\"DirectSubscriberProxy1\" transports=\"amqp\"&gt;\n", 
            "+    &lt;target&gt;\n", 
            "+        &lt;inSequence&gt;\n", 
            "+            &lt;property action=\"set\" name=\"OUT_ONLY\" value=\"true\"/&gt;\n", 
            "+            &lt;log level=\"custom\"&gt;\n", 
            "+                &lt;property name=\"status\" value=\"At DirectSubscriberProxy 1\"/&gt;\n", 
            "+            &lt;/log&gt;\n", 
            "+        &lt;/inSequence&gt;\n", 
            "+        &lt;endpoint&gt;\n", 
            "+            &lt;address uri=\"http://localhost:9000/services/SimpleStockQuoteService\"/&gt;\n", 
            "+        &lt;/endpoint&gt;\n", 
            "+        &lt;outSequence&gt;\n", 
            "+            &lt;send/&gt;\n", 
            "+        &lt;/outSequence&gt;\n", 
            "+    &lt;/target&gt;\n", 
            "+    &lt;parameter name=\"transport.amqp.ConnectionFactoryName\"&gt;subscriber&lt;/parameter&gt;\n", 
            "+    &lt;parameter name=\"transport.amqp.ExchangeName\"&gt;direct_logs&lt;/parameter&gt;\n", 
            "+    &lt;parameter name=\"transport.amqp.ExchangeType\"&gt;direct&lt;/parameter&gt;\n", 
            "+    &lt;parameter name=\"transport.amqp.BindingKeys\"&gt;warning,error&lt;/parameter&gt;\n", 
            "+&lt;/proxy&gt;\n", 
            "+\n", 
            "+&lt;proxy name=\"DirectSubscriberProxy2\" transports=\"amqp\"&gt;\n", 
            "+    &lt;target&gt;\n", 
            "+        &lt;inSequence&gt;\n", 
            "+            &lt;property action=\"set\" name=\"OUT_ONLY\" value=\"true\"/&gt;\n", 
            "+            &lt;log level=\"custom\"&gt;\n", 
            "+                &lt;property name=\"status\" value=\"At DirectSubscriberProxy 2\"/&gt;\n", 
            "+            &lt;/log&gt;\n", 
            "+        &lt;/inSequence&gt;\n", 
            "+        &lt;endpoint&gt;\n", 
            "+            &lt;address uri=\"http://localhost:9000/services/SimpleStockQuoteService\"/&gt;\n", 
            "+        &lt;/endpoint&gt;\n", 
            "+        &lt;outSequence&gt;\n", 
            "+            &lt;send/&gt;\n", 
            "+        &lt;/outSequence&gt;\n", 
            "+    &lt;/target&gt;\n", 
            "+    &lt;parameter name=\"transport.amqp.ConnectionFactoryName\"&gt;subscriber&lt;/parameter&gt;\n", 
            "+    &lt;parameter name=\"transport.amqp.ExchangeName\"&gt;direct_logs&lt;/parameter&gt;\n", 
            "+    &lt;parameter name=\"transport.amqp.ExchangeType\"&gt;direct&lt;/parameter&gt;\n", 
            "+    &lt;parameter name=\"transport.amqp.BindingKeys\"&gt;error&lt;/parameter&gt;\n", 
            "+&lt;/proxy&gt;\n", 
            "+                    </div>\n", 
            "+                    <p>Producer transactions</p>\n", 
            "+                    <div class=\"xmlConf\">\n", 
            "+&lt;proxy name=\"ProducerTxProxy1\" transports=\"http\"&gt;\n", 
            "+    &lt;target&gt;\n", 
            "+        &lt;inSequence&gt;\n", 
            "+            &lt;property action=\"set\" name=\"OUT_ONLY\" value=\"true\"/&gt;\n", 
            "+            &lt;property action=\"set\" name=\"AMQP_PRODUCER_TX\" scope=\"axis2\" value=\"lwpc\"/&gt;\n", 
            "+            &lt;log level=\"custom\"&gt;\n", 
            "+                &lt;property name=\"status\" value=\"At ProducerTxProxy1, use light weight producer confirm...\"/&gt;\n", 
            "+            &lt;/log&gt;\n", 
            "+        &lt;/inSequence&gt;\n", 
            "+        &lt;endpoint&gt;\n", 
            "+            &lt;!--use the defined connection factory in AMQP transport sender--&gt;\n", 
            "+            &lt;address\n", 
            "+                uri=\"amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer&amp;transport.amqp.QueueName=ProducerProxy\"/&gt;\n", 
            "+        &lt;/endpoint&gt;\n", 
            "+        &lt;outSequence&gt;\n", 
            "+            &lt;send/&gt;\n", 
            "+        &lt;/outSequence&gt;\n", 
            "+    &lt;/target&gt;\n", 
            "+&lt;/proxy&gt;\n", 
            "+                    </div>\n", 
            "+            </subsection>\n", 
            "+        </section>\n", 
            " \t</body>\n", 
            " </document>\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/documentation/src/site/xdoc/userguide/transports.xml", 
      "from": "java/modules/documentation/src/site/xdoc/userguide/transports.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-266,6 +266,22", 
          "lines": [
            "     <!--Uncomment this for UDP transport support\n", 
            "     <transportReceiver name=\"udp\" class=\"org.apache.axis2.transport.udp.UDPListener\"/>-->\n", 
            " \n", 
            "+    <!--Uncomment this for AMQP transport support-->\n", 
            "+    <!--<transportReceiver name=\"amqp\" class=\"org.apache.synapse.transport.amqp.AMQPTransportListener\">-->\n", 
            "+        <!--<parameter name=\"consumer\" locked=\"false\">-->\n", 
            "+            <!--<parameter name=\"transport.amqp.Uri\" locked=\"false\">amqp://localhost:5672</parameter>-->\n", 
            "+        <!--</parameter>-->\n", 
            "+        <!--<parameter name=\"worker-queue\" locked=\"false\">-->\n", 
            "+            <!--<parameter name=\"transport.amqp.Uri\" locked=\"false\">amqp://localhost:5672</parameter>-->\n", 
            "+            <!--<parameter name=\"transport.amqp.ChannelPreFetchCountSize\" locked=\"false\">1</parameter>-->\n", 
            "+        <!--</parameter>-->\n", 
            "+        <!--<parameter name=\"subscriber\" locked=\"false\">-->\n", 
            "+            <!--<parameter name=\"transport.amqp.Uri\" locked=\"false\">amqp://localhost:5672</parameter>-->\n", 
            "+        <!--</parameter>-->\n", 
            "+    <!--</transportReceiver>-->\n", 
            "+\n", 
            "+    <!--Uncomment this for AMQP transport support -->\n", 
            "+\n", 
            "     <!-- ================================================= -->\n", 
            "     <!-- Transport Outs -->\n", 
            "     <!-- ================================================= -->\n"
          ]
        }, 
        {
          "locn": "-348,6 +364,18", 
          "lines": [
            "     <!--Uncomment this for UDP transport support\n", 
            "     <transportSender name=\"udp\" class=\"org.apache.axis2.transport.udp.UDPSender\"/>-->\n", 
            " \n", 
            "+\n", 
            "+    <!--Uncomment this for AMQP transport support-->\n", 
            "+    <!--<transportSender name=\"amqp\" class=\"org.apache.synapse.transport.amqp.AMQPTransportSender\">-->\n", 
            "+        <!--<parameter name=\"producer\" locked=\"false\">-->\n", 
            "+            <!--<parameter name=\"transport.amqp.Uri\" locked=\"false\">amqp://localhost:5672</parameter>-->\n", 
            "+        <!--</parameter>-->\n", 
            "+        <!--<parameter name=\"publisher\" locked=\"false\">-->\n", 
            "+            <!--<parameter name=\"transport.amqp.Uri\" locked=\"false\">amqp://localhost:5672</parameter>-->\n", 
            "+        <!--</parameter>-->\n", 
            "+    <!--</transportSender>-->\n", 
            "+\n", 
            "+\n", 
            "     <!-- ================================================= -->\n", 
            "     <!-- Global Modules  -->\n", 
            "     <!-- ================================================= -->\n"
          ]
        }
      ], 
      "to": "java/repository/conf/axis2.xml", 
      "from": "java/repository/conf/axis2.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,7", 
          "lines": [
            "+# Do not edit. This is for JUnit tests.\n", 
            "+string=username@domain.com\n", 
            "+int=10\n", 
            "+long=13\n", 
            "+double=14.4\n", 
            "+boolean1=true\n", 
            "+boolean2=false\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/test/resources/amqp-transport.properties", 
      "from": "java/modules/transports/optional/amqp/src/test/resources/amqp-transport.properties"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,34", 
          "lines": [
            "+package org.apache.synapse.tranport.amqp;\n", 
            "+\n", 
            "+import com.rabbitmq.client.Channel;\n", 
            "+import com.rabbitmq.client.Connection;\n", 
            "+import com.rabbitmq.client.ConnectionFactory;\n", 
            "+import com.rabbitmq.client.QueueingConsumer;\n", 
            "+\n", 
            "+import java.io.IOException;\n", 
            "+\n", 
            "+/**\n", 
            "+ * The consumer client for AMQP transport\n", 
            "+ */\n", 
            "+public class AMQPConsumerClient {\n", 
            "+\n", 
            "+    public static final String QUEUE_NAME = \"ProducerProxy\";\n", 
            "+\n", 
            "+    public static void main(String[] args) throws IOException, InterruptedException {\n", 
            "+\n", 
            "+        ConnectionFactory factory = new ConnectionFactory();\n", 
            "+        factory.setHost(\"localhost\");\n", 
            "+        Connection connection = factory.newConnection();\n", 
            "+\n", 
            "+        Channel channel = connection.createChannel();\n", 
            "+        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n", 
            "+\n", 
            "+        QueueingConsumer consumer = new QueueingConsumer(channel);\n", 
            "+        channel.basicConsume(QUEUE_NAME, true, consumer);\n", 
            "+        System.out.println(\"Waiting for message on queue '\" + QUEUE_NAME + \"'\");\n", 
            "+\n", 
            "+        QueueingConsumer.Delivery delivery = consumer.nextDelivery();\n", 
            "+        String message = new String(delivery.getBody());\n", 
            "+        System.out.println(\"[x] received '\" + message + \"'\");\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPConsumerClient.java", 
      "from": "java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPConsumerClient.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,155", 
          "lines": [
            "+/*\n", 
            "+ * Copyright WSO2, Inc. (http://wso2.com)\n", 
            "+ *\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.tranport.amqp;\n", 
            "+\n", 
            "+import com.rabbitmq.client.Address;\n", 
            "+import junit.framework.TestCase;\n", 
            "+import org.apache.axis2.description.AxisService;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportConstant;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportUtils;\n", 
            "+\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.Map;\n", 
            "+\n", 
            "+public class AMQPTransportUtilsTest extends TestCase {\n", 
            "+\n", 
            "+    private Map<String, String> svcMap = new HashMap<String, String>();\n", 
            "+\n", 
            "+    private Map<String, String> cfMap = new HashMap<String, String>();\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public void setUp() throws Exception {\n", 
            "+        super.setUp();\n", 
            "+        // Do not edit the values, test may fail!\n", 
            "+        svcMap.put(AMQPTransportConstant.PARAMETER_EXCHANGE_NAME, \"directExchange\");\n", 
            "+        svcMap.put(AMQPTransportConstant.PARAMETER_EXCHANGE_INTERNAL, \"true\");\n", 
            "+        svcMap.put(AMQPTransportConstant.PARAMETER_NO_OF_CONCURRENT_CONSUMERS, \"2\");\n", 
            "+\n", 
            "+        cfMap.put(AMQPTransportConstant.PARAMETER_EXCHANGE_TYPE, \"direct\");\n", 
            "+        cfMap.put(AMQPTransportConstant.PARAMETER_QUEUE_DURABLE, \"true\");\n", 
            "+        cfMap.put(AMQPTransportConstant.PARAMETER_INITIAL_RE_CONNECTION_DURATION, \"10\");\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testGetStringProperty() throws Exception {\n", 
            "+        assertEquals(\"In valid string value received,\",\n", 
            "+                \"username@domain.com\", AMQPTransportUtils.getStringProperty(\"string\", null));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testGetIntProperty() throws Exception {\n", 
            "+        assertEquals(\"In valid int value received,\", 10, AMQPTransportUtils.getIntProperty(\"int\", -1));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testGetLongProperty() throws Exception {\n", 
            "+        assertEquals(\"In valid long value received,\", 13, AMQPTransportUtils.getLongProperty(\"long\", -1));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testGetDoubleProperty() throws Exception {\n", 
            "+        assertEquals(\"In valid double value received,\", 14.4, AMQPTransportUtils.getDoubleProperty(\"double\", -1));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testGetBooleanProperty() throws Exception {\n", 
            "+        assertEquals(\n", 
            "+                \"In valid boolean value received,\",\n", 
            "+                false,\n", 
            "+                AMQPTransportUtils.getBooleanProperty(\"boolean2\", true).booleanValue());\n", 
            "+\n", 
            "+        assertEquals(\n", 
            "+                \"In valid boolean value received,\",\n", 
            "+                true,\n", 
            "+                AMQPTransportUtils.getBooleanProperty(\"boolean1\", false).booleanValue());\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testGetServiceStringParameters() throws Exception {\n", 
            "+        AxisService service = new AxisService();\n", 
            "+        service.addParameter(\"param1\", \"value1\");\n", 
            "+\n", 
            "+        Map<String, String> paramMap =\n", 
            "+                AMQPTransportUtils.getServiceStringParameters(service.getParameters());\n", 
            "+        assertEquals(\"In valid parameter for key param1\", \"value1\", paramMap.get(\"param1\"));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testGetOptionalStringParameter() throws Exception {\n", 
            "+        assertEquals(\n", 
            "+                \"In valid value received\",\n", 
            "+                svcMap.get(AMQPTransportConstant.PARAMETER_EXCHANGE_NAME),\n", 
            "+                AMQPTransportUtils.getOptionalStringParameter(\n", 
            "+                        AMQPTransportConstant.PARAMETER_EXCHANGE_NAME, svcMap, cfMap));\n", 
            "+\n", 
            "+        assertEquals(\n", 
            "+                \"In valid value received\",\n", 
            "+                cfMap.get(AMQPTransportConstant.PARAMETER_EXCHANGE_TYPE),\n", 
            "+                AMQPTransportUtils.getOptionalStringParameter(\n", 
            "+                        AMQPTransportConstant.PARAMETER_EXCHANGE_TYPE, svcMap, cfMap));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testGetOptionalBooleanParameter() throws Exception {\n", 
            "+        assertEquals(\"Invalid value\",\n", 
            "+                Boolean.valueOf(svcMap.get(AMQPTransportConstant.PARAMETER_EXCHANGE_INTERNAL)),\n", 
            "+                AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                        AMQPTransportConstant.PARAMETER_EXCHANGE_INTERNAL, svcMap, cfMap));\n", 
            "+\n", 
            "+        assertEquals(\"Invalid value\",\n", 
            "+                Boolean.valueOf(cfMap.get(AMQPTransportConstant.PARAMETER_QUEUE_DURABLE)),\n", 
            "+                AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                        AMQPTransportConstant.PARAMETER_QUEUE_DURABLE, svcMap, cfMap));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testGetOptionalIntParameter() throws Exception {\n", 
            "+        assertEquals(\"Invalid value\",\n", 
            "+                Integer.parseInt(cfMap.get(AMQPTransportConstant.PARAMETER_INITIAL_RE_CONNECTION_DURATION)),\n", 
            "+                AMQPTransportUtils.getOptionalIntParameter(\n", 
            "+                        AMQPTransportConstant.PARAMETER_INITIAL_RE_CONNECTION_DURATION, svcMap, cfMap).intValue());\n", 
            "+\n", 
            "+        assertEquals(\"Invalid value\",\n", 
            "+                Integer.parseInt(svcMap.get(AMQPTransportConstant.PARAMETER_NO_OF_CONCURRENT_CONSUMERS)),\n", 
            "+                AMQPTransportUtils.getOptionalIntParameter(\n", 
            "+                        AMQPTransportConstant.PARAMETER_NO_OF_CONCURRENT_CONSUMERS, svcMap, cfMap).intValue());\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testGetBindingKeys() throws Exception {\n", 
            "+        String keys[] = AMQPTransportUtils.split(\"ERROR,WARN,DEBUG\", \",\");\n", 
            "+        assertEquals(\"Invalid value\", \"ERROR\", keys[0]);\n", 
            "+        assertEquals(\"Invalid value\", \"WARN\", keys[1]);\n", 
            "+        assertEquals(\"Invalid value\", \"DEBUG\", keys[2]);\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testGetAddressArray() throws Exception {\n", 
            "+        try {\n", 
            "+            Address[] addresses1 = AMQPTransportUtils.getAddressArray(\n", 
            "+                    \"wso2.org:443,rajika.org:25\", \",\", ':');\n", 
            "+            assertEquals(\"Invalid value\", \"wso2.org\", addresses1[0].getHost());\n", 
            "+            assertEquals(\"Invalid value\", 25, addresses1[1].getPort());\n", 
            "+            assertEquals(\"Invalid value\", \"rajika.org\", addresses1[1].getHost());\n", 
            "+        } catch (NumberFormatException e) {\n", 
            "+            fail(\"Should not throw an exception, \" + e.getMessage());\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            AMQPTransportUtils.getAddressArray(\n", 
            "+                    \"hostName1:443,hostName2:25,hostName3:invalidPort\", \",\", ':');\n", 
            "+            fail(\"Should not come here because above should throw an exception\");\n", 
            "+        } catch (NumberFormatException e) {\n", 
            "+            // expected\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testParseAMQPUri() throws Exception {\n", 
            "+        String url = \"amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer&transport.amqp.QueueName=producer\" ;\n", 
            "+        Map<String, String> uriParam = AMQPTransportUtils.parseAMQPUri(url);\n", 
            "+        assertEquals(\"Invalid value\", \"producer\", uriParam.get(AMQPTransportConstant.PARAMETER_QUEUE_NAME));\n", 
            "+\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPTransportUtilsTest.java", 
      "from": "java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPTransportUtilsTest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,109", 
          "lines": [
            "+/*\n", 
            "+ * ====================================================================\n", 
            "+ * Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ * or more contributor license agreements.  See the NOTICE file\n", 
            "+ * distributed with this work for additional information\n", 
            "+ * regarding copyright ownership.  The ASF licenses this file\n", 
            "+ * to you under the Apache License, Version 2.0 (the\n", 
            "+ * \"License\"); you may not use this file except in compliance\n", 
            "+ * with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing,\n", 
            "+ * software distributed under the License is distributed on an\n", 
            "+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ * KIND, either express or implied.  See the License for the\n", 
            "+ * specific language governing permissions and limitations\n", 
            "+ * under the License.\n", 
            "+ * ====================================================================\n", 
            "+ *\n", 
            "+ * This software consists of voluntary contributions made by many\n", 
            "+ * individuals on behalf of the Apache Software Foundation.  For more\n", 
            "+ * information on the Apache Software Foundation, please see\n", 
            "+ * <http://www.apache.org/>.\n", 
            "+ *\n", 
            "+ */\n", 
            "+package org.apache.synapse.tranport.amqp;\n", 
            "+\n", 
            "+import com.rabbitmq.client.*;\n", 
            "+\n", 
            "+import java.io.IOException;\n", 
            "+\n", 
            "+/**\n", 
            "+ * A request/response producer client\n", 
            "+ * author : rajika.kumarasiri@gmail.com\n", 
            "+ */\n", 
            "+public class AMQPTwoWayProducerClient {\n", 
            "+\n", 
            "+    private static final String MESSAGE =\n", 
            "+            \"<?xml version='1.0' encoding='UTF-8'?>\\n\" +\n", 
            "+                    \"   <soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\">\\n\" +\n", 
            "+                    \"      <soapenv:Header xmlns:wsa=\\\"http://www.w3.org/2005/08/addressing\\\">\\n\" +\n", 
            "+                    \"         <wsa:To>http://localhost:8281/services/StockQuoteProxy</wsa:To>\\n\" +\n", 
            "+                    \"         <wsa:MessageID>urn:uuid:44d578a8-20e9-4ee4-8407-9b0a0768e5a8</wsa:MessageID>\\n\" +\n", 
            "+                    \"         <wsa:Action>urn:getQuote</wsa:Action>\\n\" +\n", 
            "+                    \"      </soapenv:Header>\\n\" +\n", 
            "+                    \"      <soapenv:Body>\\n\" +\n", 
            "+                    \"         <m0:getQuote xmlns:m0=\\\"http://services.samples\\\">\\n\" +\n", 
            "+                    \"            <m0:request>\\n\" +\n", 
            "+                    \"               <m0:symbol>IBM</m0:symbol>\\n\" +\n", 
            "+                    \"            </m0:request>\\n\" +\n", 
            "+                    \"         </m0:getQuote>\\n\" +\n", 
            "+                    \"      </soapenv:Body>\\n\" +\n", 
            "+                    \"   </soapenv:Envelope>\";\n", 
            "+\n", 
            "+    private static final String MESSAGE2 =\n", 
            "+            \"<?xml version='1.0' encoding='UTF-8'?>\\n\" +\n", 
            "+                    \"         <m0:getQuote xmlns:m0=\\\"http://services.samples\\\">\\n\" +\n", 
            "+                    \"            <m0:request>\\n\" +\n", 
            "+                    \"               <m0:symbol>IBM</m0:symbol>\\n\" +\n", 
            "+                    \"            </m0:request>\\n\" +\n", 
            "+                    \"         </m0:getQuote>\";\n", 
            "+\n", 
            "+    public static void main(String[] args) throws IOException, InterruptedException {\n", 
            "+\n", 
            "+        ConnectionFactory factory = new ConnectionFactory();\n", 
            "+        factory.setHost(\"localhost\");\n", 
            "+        Connection connection = factory.newConnection();\n", 
            "+\n", 
            "+        Channel channel = connection.createChannel();\n", 
            "+\n", 
            "+        AMQPTwoWayProducerClient.produceAndConsume(\n", 
            "+                MESSAGE2, channel, \"consumer\", \"consumerReply\");\n", 
            "+\n", 
            "+        channel.close();\n", 
            "+        connection.close();\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    private static void produceAndConsume(\n", 
            "+            String message,\n", 
            "+            Channel channel,\n", 
            "+            String requestQueueName,\n", 
            "+            String replyQueueName) throws IOException, InterruptedException {\n", 
            "+\n", 
            "+        AMQP.BasicProperties.Builder builder = new\n", 
            "+                AMQP.BasicProperties().builder();\n", 
            "+        String restCoID = Math.random() + \"\";\n", 
            "+        builder.correlationId(restCoID);\n", 
            "+        System.out.println(\"Request correlation Id : \" + restCoID);\n", 
            "+        builder.replyTo(replyQueueName);\n", 
            "+        channel.basicPublish(\"\", requestQueueName, builder.build(), message.getBytes());\n", 
            "+        System.out.println(\"[x] sent to '\" + requestQueueName + \"' the message '\\n\" + message + \"'\");\n", 
            "+\n", 
            "+        channel.queueDeclare(replyQueueName, false, false, false, null);\n", 
            "+        QueueingConsumer consumer = new QueueingConsumer(channel);\n", 
            "+        channel.basicConsume(replyQueueName, true, consumer);\n", 
            "+        System.out.println(\"Waiting for message on queue '\" + replyQueueName + \"'\");\n", 
            "+        while (true) {\n", 
            "+            QueueingConsumer.Delivery delivery = consumer.nextDelivery();\n", 
            "+            String replyMessage = new String(delivery.getBody());\n", 
            "+            System.out.println(\"[x] received '\" + replyMessage + \"'\");\n", 
            "+            System.out.println(\"Response correlation Id : \" + delivery.getProperties().getCorrelationId());\n", 
            "+            break;\n", 
            "+\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPTwoWayProducerClient.java", 
      "from": "java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPTwoWayProducerClient.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,75", 
          "lines": [
            "+package org.apache.synapse.tranport.amqp;\n", 
            "+\n", 
            "+import com.rabbitmq.client.Channel;\n", 
            "+import com.rabbitmq.client.Connection;\n", 
            "+import com.rabbitmq.client.ConnectionFactory;\n", 
            "+\n", 
            "+import java.io.IOException;\n", 
            "+\n", 
            "+/**\n", 
            "+ * The producer for AMQP transport.\n", 
            "+ */\n", 
            "+public class AMQPProducerClient {\n", 
            "+\n", 
            "+    //    private static final String QUEUE_NAME = \"ConsumerTxProxy\";\n", 
            "+//    private static final String QUEUE_NAME = \"worker-queue\";\n", 
            "+    private static final String QUEUE_NAME = \"ProducerProxy\";\n", 
            "+\n", 
            "+    private static final String MESSAGE =\n", 
            "+            \"<?xml version='1.0' encoding='UTF-8'?>\\n\" +\n", 
            "+                    \"   <soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\">\\n\" +\n", 
            "+                    \"      <soapenv:Header xmlns:wsa=\\\"http://www.w3.org/2005/08/addressing\\\">\\n\" +\n", 
            "+                    \"         <wsa:To>http://localhost:8281/services/StockQuoteProxy</wsa:To>\\n\" +\n", 
            "+                    \"         <wsa:MessageID>urn:uuid:44d578a8-20e9-4ee4-8407-9b0a0768e5a8</wsa:MessageID>\\n\" +\n", 
            "+                    \"         <wsa:Action>urn:getQuote</wsa:Action>\\n\" +\n", 
            "+                    \"      </soapenv:Header>\\n\" +\n", 
            "+                    \"      <soapenv:Body>\\n\" +\n", 
            "+                    \"         <m0:getQuote xmlns:m0=\\\"http://services.samples\\\">\\n\" +\n", 
            "+                    \"            <m0:request>\\n\" +\n", 
            "+                    \"               <m0:symbol>IBM</m0:symbol>\\n\" +\n", 
            "+                    \"            </m0:request>\\n\" +\n", 
            "+                    \"         </m0:getQuote>\\n\" +\n", 
            "+                    \"      </soapenv:Body>\\n\" +\n", 
            "+                    \"   </soapenv:Envelope>\";\n", 
            "+\n", 
            "+    private static final String MESSAGE2 =\n", 
            "+            \"<?xml version='1.0' encoding='UTF-8'?>\\n\" +\n", 
            "+                    \"         <m0:getQuote xmlns:m0=\\\"http://services.samples\\\">\\n\" +\n", 
            "+                    \"            <m0:request>\\n\" +\n", 
            "+                    \"               <m0:symbol>IBM</m0:symbol>\\n\" +\n", 
            "+                    \"            </m0:request>\\n\" +\n", 
            "+                    \"         </m0:getQuote>\";\n", 
            "+\n", 
            "+    public static void main(String[] args) throws IOException {\n", 
            "+\n", 
            "+        ConnectionFactory factory = new ConnectionFactory();\n", 
            "+        factory.setHost(\"localhost\");\n", 
            "+        Connection connection = factory.newConnection();\n", 
            "+\n", 
            "+        Channel channel = connection.createChannel();\n", 
            "+\n", 
            "+        //channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n", 
            "+        AMQPProducerClient.produce(MESSAGE2, channel, QUEUE_NAME);\n", 
            "+//        AMQPProducerClient.publish(MESSAGE2, channel, \"subscriber-exchange\");\n", 
            "+//        AMQPProducerClient.route(MESSAGE2, channel, \"route-exchange\", \"fatal\");\n", 
            "+//        AMQPProducerClient.route(MESSAGE2, channel, \"topic-exchange\", \"kern.critical\");\n", 
            "+\n", 
            "+        channel.close();\n", 
            "+        connection.close();\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    private static void produce(String message, Channel channel, String queueName) throws IOException {\n", 
            "+        channel.basicPublish(\"\", queueName, null, message.getBytes());\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void publish(String message, Channel channel, String exchangeName) throws IOException {\n", 
            "+        channel.basicPublish(exchangeName, \"\", null, message.getBytes());\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void route(String message, Channel channel, String exchangeName, String routeKey) throws IOException {\n", 
            "+        channel.basicPublish(exchangeName, routeKey, null, message.getBytes());\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPProducerClient.java", 
      "from": "java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPProducerClient.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,173", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp;\n", 
            "+\n", 
            "+import com.rabbitmq.client.BasicProperties;\n", 
            "+import com.rabbitmq.client.Envelope;\n", 
            "+import com.rabbitmq.client.QueueingConsumer;\n", 
            "+import org.apache.axis2.transport.base.BaseConstants;\n", 
            "+\n", 
            "+import java.util.Date;\n", 
            "+import java.util.Map;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Represent a AMQP message transfer between the broker and the consumer/producer.\n", 
            "+ */\n", 
            "+public class AMQPTransportMessage {\n", 
            "+\n", 
            "+    private String soapAction;\n", 
            "+\n", 
            "+    private String messageId;\n", 
            "+\n", 
            "+    private String contentType;\n", 
            "+\n", 
            "+    private String contentEncoding;\n", 
            "+\n", 
            "+    private Integer deliveryMode;\n", 
            "+\n", 
            "+    private Integer priority;\n", 
            "+\n", 
            "+    private String correlationId;\n", 
            "+\n", 
            "+    private String replyTo;\n", 
            "+\n", 
            "+    private String expiration;\n", 
            "+\n", 
            "+    private Date timestamp;\n", 
            "+\n", 
            "+    private String type;\n", 
            "+\n", 
            "+    private String userId;\n", 
            "+\n", 
            "+    private String appId;\n", 
            "+\n", 
            "+    private String clusterId;\n", 
            "+\n", 
            "+    private Map<String, Object> headers;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Keeps a reference to the AMQP message.\n", 
            "+     */\n", 
            "+    private byte[] body;\n", 
            "+\n", 
            "+    private Envelope envelope;\n", 
            "+\n", 
            "+    private BasicProperties basicProperties;\n", 
            "+\n", 
            "+    private QueueingConsumer.Delivery delivery;\n", 
            "+\n", 
            "+    public AMQPTransportMessage(QueueingConsumer.Delivery delivery) {\n", 
            "+        this.delivery = delivery;\n", 
            "+        this.body = delivery.getBody();\n", 
            "+        this.envelope = delivery.getEnvelope();\n", 
            "+        this.basicProperties = delivery.getProperties();\n", 
            "+        this.messageId = delivery.getProperties().getMessageId();\n", 
            "+        this.contentType = delivery.getProperties().getContentType();\n", 
            "+        this.contentEncoding = delivery.getProperties().getContentEncoding();\n", 
            "+        this.deliveryMode = delivery.getProperties().getDeliveryMode();\n", 
            "+        this.priority = delivery.getProperties().getPriority();\n", 
            "+        this.correlationId = delivery.getProperties().getCorrelationId();\n", 
            "+        this.replyTo = delivery.getProperties().getReplyTo();\n", 
            "+        this.expiration = delivery.getProperties().getExpiration();\n", 
            "+        this.timestamp = delivery.getProperties().getTimestamp();\n", 
            "+        this.type = delivery.getProperties().getType();\n", 
            "+        this.userId = delivery.getProperties().getUserId();\n", 
            "+        this.appId = delivery.getProperties().getAppId();\n", 
            "+        this.clusterId = delivery.getProperties().getClusterId();\n", 
            "+        this.headers = delivery.getProperties().getHeaders();\n", 
            "+\n", 
            "+        if (delivery.getProperties().getHeaders() != null) {\n", 
            "+            this.soapAction = (String) delivery.getProperties().getHeaders().get(BaseConstants.SOAPACTION);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public AMQPTransportMessage(BasicProperties basicProperties, byte[] message) {\n", 
            "+        this.body = message;\n", 
            "+        this.basicProperties = basicProperties;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getSoapAction() {\n", 
            "+        return soapAction;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getMessageId() {\n", 
            "+        return messageId;\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    public String getContentType() {\n", 
            "+        return contentType;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getContentEncoding() {\n", 
            "+        return contentEncoding;\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    public Integer getDeliveryMode() {\n", 
            "+        return deliveryMode;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Integer getPriority() {\n", 
            "+        return priority;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getCorrelationId() {\n", 
            "+        return correlationId;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getReplyTo() {\n", 
            "+        return replyTo;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getExpiration() {\n", 
            "+        return expiration;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Date getTimestamp() {\n", 
            "+        return timestamp;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getType() {\n", 
            "+        return type;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getUserId() {\n", 
            "+        return userId;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getAppId() {\n", 
            "+        return appId;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getClusterId() {\n", 
            "+        return clusterId;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Map<String, Object> getHeaders() {\n", 
            "+        return headers;\n", 
            "+    }\n", 
            "+\n", 
            "+    public byte[] getBody() {\n", 
            "+        return body;\n", 
            "+    }\n", 
            "+\n", 
            "+    public QueueingConsumer.Delivery getDelivery() {\n", 
            "+        return delivery;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Envelope getEnvelope() {\n", 
            "+        return envelope;\n", 
            "+    }\n", 
            "+}\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportMessage.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportMessage.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,118", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp;\n", 
            "+\n", 
            "+import org.apache.axis2.AxisFault;\n", 
            "+import org.apache.axis2.transport.base.AbstractTransportListenerEx;\n", 
            "+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactory;\n", 
            "+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactoryManager;\n", 
            "+import org.apache.synapse.transport.amqp.pollingtask.AMQPTransportPollingTask;\n", 
            "+\n", 
            "+import java.util.concurrent.ExecutorService;\n", 
            "+import java.util.concurrent.Executors;\n", 
            "+import java.util.concurrent.ScheduledExecutorService;\n", 
            "+\n", 
            "+/**\n", 
            "+ * The AMQP transport receiver implementation.\n", 
            "+ */\n", 
            "+public class AMQPTransportListener extends AbstractTransportListenerEx<AMQPTransportEndpoint> {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The worker pool for polling tasks\n", 
            "+     */\n", 
            "+    private ScheduledExecutorService workerPool;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The connection factories defined in axis2.xml for transport receiver section.\n", 
            "+     */\n", 
            "+    private AMQPTransportConnectionFactoryManager connectionFactoryManager;\n", 
            "+\n", 
            "+    private ExecutorService connectionFactoryES;\n", 
            "+\n", 
            "+    @Override\n", 
            "+    protected void doInit() throws AxisFault {\n", 
            "+\n", 
            "+        // pass a custom executor service instance into the AMQP connection factory for better\n", 
            "+        // control see http://www.rabbitmq.com/api-guide.html\n", 
            "+        connectionFactoryES = Executors.newFixedThreadPool(\n", 
            "+                AMQPTransportUtils.getIntProperty(\n", 
            "+                        AMQPTransportConstant.PARAM_CONNECTION_FACTORY_POOL_SIZE,\n", 
            "+                        AMQPTransportConstant.CONNECTION_FACTORY_POOL_DEFAULT));\n", 
            "+\n", 
            "+        connectionFactoryManager = new AMQPTransportConnectionFactoryManager();\n", 
            "+        connectionFactoryManager.addConnectionFactories(\n", 
            "+                getTransportInDescription(), connectionFactoryES);\n", 
            "+\n", 
            "+        workerPool = Executors.newScheduledThreadPool(\n", 
            "+                AMQPTransportUtils.getIntProperty(AMQPTransportConstant.PARAM_WORKER_POOL_SIZE,\n", 
            "+                        AMQPTransportConstant.WORKER_POOL_DEFAULT));\n", 
            "+\n", 
            "+        log.info(\"AMQP transport listener initializing..\");\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    protected AMQPTransportEndpoint createEndpoint() {\n", 
            "+        return new AMQPTransportEndpoint(workerPool, this);\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    protected void startEndpoint(AMQPTransportEndpoint endpoint) throws AxisFault {\n", 
            "+        AMQPTransportPollingTask ptm = endpoint.getPollingTask();\n", 
            "+        try {\n", 
            "+            ptm.start();\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            throw new AxisFault(e.getMessage(), e);\n", 
            "+        }\n", 
            "+\n", 
            "+        log.info(\"AMQP transport polling task started listen for service '\" +\n", 
            "+                ptm.getServiceName() + \"'\");\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    protected void stopEndpoint(AMQPTransportEndpoint endpoint) {\n", 
            "+        AMQPTransportPollingTask ptm = endpoint.getPollingTask();\n", 
            "+        ptm.stop();\n", 
            "+\n", 
            "+        log.info(\"AMQP transport polling task stopped listen for service '\" +\n", 
            "+                ptm.getServiceName() + \"'\");\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public void stop() throws AxisFault {\n", 
            "+        super.stop();\n", 
            "+        workerPool.shutdown();\n", 
            "+        try {\n", 
            "+            connectionFactoryManager.shutDownConnectionFactories();\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            log.error(\"Error while shutting down connection factories, continue anyway...\", e);\n", 
            "+        }\n", 
            "+        connectionFactoryES.shutdown();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the connection factory with this name.\n", 
            "+     *\n", 
            "+     * @param name Name of the connection factory.\n", 
            "+     * @return The connection factory with this name.\n", 
            "+     * @throws AMQPTransportException throws in case of an error.\n", 
            "+     */\n", 
            "+    public AMQPTransportConnectionFactory getConnectionFactory(final String name)\n", 
            "+            throws AMQPTransportException {\n", 
            "+        if (connectionFactoryManager.getConnectionFactory(name) != null) {\n", 
            "+            return connectionFactoryManager.getConnectionFactory(name);\n", 
            "+        }\n", 
            "+        return connectionFactoryManager.getConnectionFactory(\n", 
            "+                AMQPTransportConstant.DEFAULT_CONNECTION_FACTORY_NAME);\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportListener.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportListener.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,154", 
          "lines": [
            "+/*\n", 
            "+ * ====================================================================\n", 
            "+ * Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ * or more contributor license agreements.  See the NOTICE file\n", 
            "+ * distributed with this work for additional information\n", 
            "+ * regarding copyright ownership.  The ASF licenses this file\n", 
            "+ * to you under the Apache License, Version 2.0 (the\n", 
            "+ * \"License\"); you may not use this file except in compliance\n", 
            "+ * with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing,\n", 
            "+ * software distributed under the License is distributed on an\n", 
            "+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ * KIND, either express or implied.  See the License for the\n", 
            "+ * specific language governing permissions and limitations\n", 
            "+ * under the License.\n", 
            "+ * ====================================================================\n", 
            "+ *\n", 
            "+ * This software consists of voluntary contributions made by many\n", 
            "+ * individuals on behalf of the Apache Software Foundation.  For more\n", 
            "+ * information on the Apache Software Foundation, please see\n", 
            "+ * <http://www.apache.org/>.\n", 
            "+ *\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp.sendertask;\n", 
            "+\n", 
            "+import com.rabbitmq.client.Channel;\n", 
            "+import org.apache.axis2.AxisFault;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportConstant;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportException;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportUtils;\n", 
            "+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactory;\n", 
            "+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactoryManager;\n", 
            "+\n", 
            "+import java.io.IOException;\n", 
            "+import java.util.Map;\n", 
            "+\n", 
            "+public class AMQPSenderFactory {\n", 
            "+\n", 
            "+    private static Log log = LogFactory.getLog(AMQPSenderFactory.class);\n", 
            "+\n", 
            "+    public synchronized static AMQPSender createAMQPSender(\n", 
            "+            AMQPTransportConnectionFactoryManager connectionFactoryManager,\n", 
            "+            Map<String, String> params) throws IOException {\n", 
            "+\n", 
            "+        boolean isQueueDurable = false;\n", 
            "+\n", 
            "+        boolean isQueueRestricted = false;\n", 
            "+\n", 
            "+        boolean isQueueAutoDelete = true;\n", 
            "+\n", 
            "+        String exchangeType;\n", 
            "+\n", 
            "+        boolean isExchangeDurable = false;\n", 
            "+\n", 
            "+        boolean isExchangeAutoDelete = true;\n", 
            "+\n", 
            "+        boolean isInternalExchange = false;\n", 
            "+\n", 
            "+        String exchangeName;\n", 
            "+\n", 
            "+        Channel channel;\n", 
            "+\n", 
            "+        AMQPSender as = new AMQPSender();\n", 
            "+\n", 
            "+        AMQPTransportConnectionFactory connFac;\n", 
            "+\n", 
            "+        try {\n", 
            "+            connFac = connectionFactoryManager.getConnectionFactory(\n", 
            "+                    params.get(AMQPTransportConstant.PARAMETER_CONNECTION_FACTORY_NAME));\n", 
            "+            channel = connFac.getChannel();\n", 
            "+            as.setChannel(channel);\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            throw new AxisFault(\"Could not retrieve the channel\", e);\n", 
            "+        }\n", 
            "+\n", 
            "+        exchangeName = params.get(AMQPTransportConstant.PARAMETER_EXCHANGE_NAME);\n", 
            "+        if (exchangeName != null) {\n", 
            "+            as.setExchangeName(exchangeName);\n", 
            "+        }\n", 
            "+        exchangeType = params.get(AMQPTransportConstant.PARAMETER_EXCHANGE_TYPE);\n", 
            "+        if (exchangeType == null) {\n", 
            "+            exchangeType = \"direct\";\n", 
            "+        }\n", 
            "+\n", 
            "+        Map<String, String> conFacParam = connFac.getParameters();\n", 
            "+\n", 
            "+        Boolean value;\n", 
            "+        value = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_EXCHANGE_IS_DURABLE, params, conFacParam);\n", 
            "+        if (value != null) {\n", 
            "+            isExchangeDurable = value.booleanValue();\n", 
            "+        }\n", 
            "+\n", 
            "+        value = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_EXCHANGE_IS_AUTO_DELETE, params, conFacParam);\n", 
            "+        if (value != null) {\n", 
            "+            isExchangeAutoDelete = value.booleanValue();\n", 
            "+        }\n", 
            "+\n", 
            "+        value = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_EXCHANGE_INTERNAL, params, conFacParam);\n", 
            "+        if (value != null) {\n", 
            "+            isInternalExchange = value.booleanValue();\n", 
            "+        }\n", 
            "+\n", 
            "+        String queueName = params.get(AMQPTransportConstant.PARAMETER_QUEUE_NAME);\n", 
            "+        as.setQueueName(queueName);\n", 
            "+\n", 
            "+        String routingKey = AMQPTransportUtils.getOptionalStringParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_ROUTING_KEY, params, conFacParam);\n", 
            "+        if (routingKey != null) {\n", 
            "+            as.setRoutingKey(routingKey);\n", 
            "+        }\n", 
            "+\n", 
            "+        value = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_QUEUE_DURABLE, params, conFacParam);\n", 
            "+        if (value != null) {\n", 
            "+            isQueueDurable = value.booleanValue();\n", 
            "+        }\n", 
            "+\n", 
            "+        value = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_QUEUE_RESTRICTED, params, conFacParam);\n", 
            "+        if (value != null) {\n", 
            "+            isQueueRestricted = value.booleanValue();\n", 
            "+        }\n", 
            "+\n", 
            "+        value = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_QUEUE_AUTO_DELETE, params, conFacParam);\n", 
            "+        if (value != null) {\n", 
            "+            isQueueAutoDelete = value.booleanValue();\n", 
            "+        }\n", 
            "+\n", 
            "+        /* use available, otherwise declare\n", 
            "+        if (exchangeName != null) {\n", 
            "+            channel.exchangeDeclare(\n", 
            "+                    exchangeName,\n", 
            "+                    exchangeType,\n", 
            "+                    isExchangeDurable,\n", 
            "+                    isExchangeAutoDelete,\n", 
            "+                    isInternalExchange,\n", 
            "+                    null);\n", 
            "+        } else {\n", 
            "+            channel.queueDeclare(queueName, isQueueDurable, isQueueRestricted, isQueueAutoDelete, null);\n", 
            "+        }\n", 
            "+        */\n", 
            "+\n", 
            "+        return as;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSenderFactory.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSenderFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,195", 
          "lines": [
            "+/*\n", 
            "+ * ====================================================================\n", 
            "+ * Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ * or more contributor license agreements.  See the NOTICE file\n", 
            "+ * distributed with this work for additional information\n", 
            "+ * regarding copyright ownership.  The ASF licenses this file\n", 
            "+ * to you under the Apache License, Version 2.0 (the\n", 
            "+ * \"License\"); you may not use this file except in compliance\n", 
            "+ * with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing,\n", 
            "+ * software distributed under the License is distributed on an\n", 
            "+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ * KIND, either express or implied.  See the License for the\n", 
            "+ * specific language governing permissions and limitations\n", 
            "+ * under the License.\n", 
            "+ * ====================================================================\n", 
            "+ *\n", 
            "+ * This software consists of voluntary contributions made by many\n", 
            "+ * individuals on behalf of the Apache Software Foundation.  For more\n", 
            "+ * information on the Apache Software Foundation, please see\n", 
            "+ * <http://www.apache.org/>.\n", 
            "+ *\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp.sendertask;\n", 
            "+\n", 
            "+import com.rabbitmq.client.AMQP;\n", 
            "+import com.rabbitmq.client.Channel;\n", 
            "+import org.apache.axiom.om.OMOutputFormat;\n", 
            "+import org.apache.axis2.AxisFault;\n", 
            "+import org.apache.axis2.Constants;\n", 
            "+import org.apache.axis2.context.MessageContext;\n", 
            "+import org.apache.axis2.transport.MessageFormatter;\n", 
            "+import org.apache.axis2.transport.base.BaseUtils;\n", 
            "+import org.apache.axis2.util.MessageProcessorSelector;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportConstant;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportException;\n", 
            "+\n", 
            "+import java.io.ByteArrayOutputStream;\n", 
            "+import java.io.IOException;\n", 
            "+import java.util.Date;\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.Map;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Performs the actual sending of the AMQP message, this class is designed to be cached\n", 
            "+ * ,so it accepts the message context from out side rather than from the constructor.\n", 
            "+ *\n", 
            "+ */\n", 
            "+public class AMQPSender {\n", 
            "+\n", 
            "+    private Channel channel = null;\n", 
            "+\n", 
            "+    private String queueName = null;\n", 
            "+\n", 
            "+    private String exchangeName = null;\n", 
            "+\n", 
            "+    private String routingKey = null;\n", 
            "+\n", 
            "+    public void setChannel(Channel channel) {\n", 
            "+        this.channel = channel;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setExchangeName(String exchangeName) {\n", 
            "+        this.exchangeName = exchangeName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setRoutingKey(String routingKey) {\n", 
            "+        this.routingKey = routingKey;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setQueueName(String queueName) {\n", 
            "+        this.queueName = queueName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Channel getChannel() {\n", 
            "+        return channel;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void sendAMQPMessage(MessageContext mc, String correlationId, String replyTo)\n", 
            "+            throws AMQPTransportException, IOException {\n", 
            "+\n", 
            "+        OMOutputFormat format = BaseUtils.getOMOutputFormat(mc);\n", 
            "+        MessageFormatter formatter;\n", 
            "+        try {\n", 
            "+            formatter = MessageProcessorSelector.getMessageFormatter(mc);\n", 
            "+        } catch (AxisFault axisFault) {\n", 
            "+            throw new AxisFault(\"Unable to get the message formatter to use\");\n", 
            "+        }\n", 
            "+\n", 
            "+        AMQP.BasicProperties.Builder builder = new\n", 
            "+                AMQP.BasicProperties().builder();\n", 
            "+\n", 
            "+        String msgId = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_MESSAGE_ID);\n", 
            "+        if (msgId == null) {\n", 
            "+            msgId = mc.getMessageID();\n", 
            "+        }\n", 
            "+        builder.messageId(msgId);\n", 
            "+\n", 
            "+        String contentType = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_CONTENT_TYPE);\n", 
            "+        if (contentType == null) {\n", 
            "+            contentType = getProperty(mc, Constants.Configuration.CONTENT_TYPE);\n", 
            "+        }\n", 
            "+        if (contentType != null) {\n", 
            "+            builder.contentType(contentType);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (correlationId != null) {\n", 
            "+            builder.correlationId(correlationId);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (replyTo != null) {\n", 
            "+            builder.replyTo(replyTo);\n", 
            "+        }\n", 
            "+\n", 
            "+        String encoding = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_CONTENT_ENCODING);\n", 
            "+        if (encoding == null) {\n", 
            "+            encoding = getProperty(mc, Constants.Configuration.CHARACTER_SET_ENCODING);\n", 
            "+        }\n", 
            "+        if (encoding != null) {\n", 
            "+            builder.contentEncoding(encoding);\n", 
            "+        }\n", 
            "+\n", 
            "+        String deliverMode = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_DELIVER_MODE);\n", 
            "+        if (deliverMode != null) {\n", 
            "+            builder.deliveryMode(Integer.parseInt(deliverMode));\n", 
            "+        }\n", 
            "+\n", 
            "+        String priority = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_PRIORITY);\n", 
            "+        if (priority != null) {\n", 
            "+            builder.priority(Integer.parseInt(priority));\n", 
            "+        }\n", 
            "+\n", 
            "+\n", 
            "+        String expiration = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_EXPIRATION);\n", 
            "+        if (expiration != null) {\n", 
            "+            builder.expiration(expiration);\n", 
            "+        }\n", 
            "+\n", 
            "+        String timeStamp = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_TIME_STAMP);\n", 
            "+        if (timeStamp != null) {\n", 
            "+            builder.timestamp(new Date(Long.parseLong(timeStamp)));\n", 
            "+        }\n", 
            "+\n", 
            "+        String type = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_TYPE);\n", 
            "+        if (type != null) {\n", 
            "+            builder.type(type);\n", 
            "+        }\n", 
            "+\n", 
            "+        String userId = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_USER_ID);\n", 
            "+        if (userId != null) {\n", 
            "+            builder.type(userId);\n", 
            "+        }\n", 
            "+\n", 
            "+        String appId = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_APP_ID);\n", 
            "+        if (appId != null) {\n", 
            "+            builder.appId(appId);\n", 
            "+        }\n", 
            "+\n", 
            "+        String clusterId = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_CLUSTER_ID);\n", 
            "+        if (clusterId != null) {\n", 
            "+            builder.clusterId(clusterId);\n", 
            "+        }\n", 
            "+\n", 
            "+        // add any custom properties set with AMQP_HEADER_* as headers\n", 
            "+        Map<String, Object> headers = new HashMap<String, Object>();\n", 
            "+        Map<String, Object> prop = mc.getProperties();\n", 
            "+        for (String key : prop.keySet()) {\n", 
            "+            if (key.contains(AMQPTransportConstant.AMQP_HEADER)) {\n", 
            "+                headers.put(key, prop.get(key));\n", 
            "+            }\n", 
            "+        }\n", 
            "+        builder.headers(headers);\n", 
            "+\n", 
            "+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n", 
            "+        formatter.writeTo(mc, format, out, false);\n", 
            "+        byte[] msg = out.toByteArray();\n", 
            "+\n", 
            "+        if (exchangeName != null) {\n", 
            "+            if (routingKey != null) {\n", 
            "+                channel.basicPublish(exchangeName, routingKey, builder.build(), msg);\n", 
            "+            } else {\n", 
            "+                channel.basicPublish(exchangeName, \"\", builder.build(), msg);\n", 
            "+            }\n", 
            "+        } else {\n", 
            "+            channel.basicPublish(\"\", queueName, builder.build(), msg);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private String getProperty(MessageContext mc, String key) {\n", 
            "+        return (String) mc.getProperty(key);\n", 
            "+    }\n", 
            "+}\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSender.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSender.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,62", 
          "lines": [
            "+/*\n", 
            "+ * ====================================================================\n", 
            "+ * Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ * or more contributor license agreements.  See the NOTICE file\n", 
            "+ * distributed with this work for additional information\n", 
            "+ * regarding copyright ownership.  The ASF licenses this file\n", 
            "+ * to you under the Apache License, Version 2.0 (the\n", 
            "+ * \"License\"); you may not use this file except in compliance\n", 
            "+ * with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing,\n", 
            "+ * software distributed under the License is distributed on an\n", 
            "+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ * KIND, either express or implied.  See the License for the\n", 
            "+ * specific language governing permissions and limitations\n", 
            "+ * under the License.\n", 
            "+ * ====================================================================\n", 
            "+ *\n", 
            "+ * This software consists of voluntary contributions made by many\n", 
            "+ * individuals on behalf of the Apache Software Foundation.  For more\n", 
            "+ * information on the Apache Software Foundation, please see\n", 
            "+ * <http://www.apache.org/>.\n", 
            "+ *\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp.sendertask;\n", 
            "+\n", 
            "+import java.util.concurrent.ConcurrentMap;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Simple cache for caching AMQP senders\n", 
            "+ *\n", 
            "+ */\n", 
            "+public class AMQPSenderCache {\n", 
            "+\n", 
            "+    private ConcurrentMap<Integer, AMQPSender> cache;\n", 
            "+\n", 
            "+    public AMQPSenderCache(ConcurrentMap<Integer, AMQPSender> cache) {\n", 
            "+        this.cache = cache;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean hit(Integer hashKey) {\n", 
            "+        return cache.containsKey(hashKey);\n", 
            "+    }\n", 
            "+\n", 
            "+    public void add(Integer hashKey, AMQPSender entry) {\n", 
            "+        cache.put(hashKey, entry);\n", 
            "+    }\n", 
            "+\n", 
            "+    public void remove(Integer hashKey) {\n", 
            "+        cache.remove(hashKey);\n", 
            "+    }\n", 
            "+\n", 
            "+    public AMQPSender get(Integer hashKey) {\n", 
            "+        return cache.get(hashKey);\n", 
            "+    }\n", 
            "+\n", 
            "+    public void clean() {\n", 
            "+        cache.clear();\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSenderCache.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSenderCache.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,346", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Constant decelerations for the AMQP transport.\n", 
            "+ */\n", 
            "+public final class AMQPTransportConstant {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The transport prefix for AMQP transport.\n", 
            "+     */\n", 
            "+    public static final String AMQP_TRANSPORT_PREFIX = \"amqp://\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The default connection factory name.\n", 
            "+     */\n", 
            "+    public static final String DEFAULT_CONNECTION_FACTORY_NAME = \"default\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The parameter to specify the Uri of the form amqp://userName:password@hostName:portNumber/virtualHost.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_CONNECTION_URI = \"transport.amqp.Uri\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The list of broker of the form, host1:port1,host2:port2... which will be used as the address array in AMQP\n", 
            "+     * connection to the broker.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_BROKER_LIST = \"transport.amqp.BrokerList\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The name of the exchange to be used.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_EXCHANGE_NAME = \"transport.amqp.ExchangeName\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The durability of the exchange. One of durable, transient or auto-deleted.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_EXCHANGE_IS_DURABLE = \"transport.amqp.IsExchangeDurable\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Should the exchange be deleted if it is no longer in use\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_EXCHANGE_IS_AUTO_DELETE = \"transport.amqp.IsExchangeAutoDelete\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The channel pre fetch size for fair dispatch\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_CHANNEL_PREFETCH_SIZE = \"transport.amqp.ChannelPreFetchSize\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The channel prefetch count for fair dispatch\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_CHANNEL_PREFETCH_COUNT = \"transport.amqp.ChannelPreFetchCountSize\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Should the configuration be used in globally ?\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_CHANNEL_QOS_GLOBAL = \"transport.amqp.IsQoSGlobally\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The type of the exchange. One of fanout, direct, header or topic.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_EXCHANGE_TYPE = \"transport.amqp.ExchangeType\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Should the exchange be declared as internal? One of true of false.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_EXCHANGE_INTERNAL = \"transport.amqp.ExchangeInternal\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The name of the exchange that the publisher/consumer should publish/consume message to.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_BIND_EXCHANGE = \"transport.amqp.BindExchange\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The comma separated binding keys this queue should be bound into exchange.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_BINDING_KEYS = \"transport.amqp.BindingKeys\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The routing key to be used by the publisher\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_ROUTING_KEY = \"transport.amqp.RoutingKey\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * True if requesting a mandatory publishing.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_PUBLISHER_MANDATORY_PUBLISH = \"transport.amqp.MandatoryPublish\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * True if requesting an immediate publishing.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_PUBLISHER_IMMEDIATE_PUBLISH = \"transport.amqp.ImmediatePublish\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Use transactions at consumer side if set to true. By default this will be considered false\n", 
            "+     * and explicit acknowledgement will be done\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_CONSUMER_TX = \"transport.amqp.ConsumerTx\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Use transactions at producer side, possible values are lwpc(light weight publisher confirm),\n", 
            "+     * tx(transaction). tx should be able to set per message basis\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_PRODUCER_TX = \"AMQP_PRODUCER_TX\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The name of the queue\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_QUEUE_NAME = \"transport.amqp.QueueName\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * True if the queue is durable\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_QUEUE_DURABLE = \"transport.amqp.IsQueueDurable\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * True of the queue is restricted(only within this connection)\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_QUEUE_RESTRICTED = \"transport.amqp.IsQueueRestricted\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * True if the queue should be auto deleted\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_QUEUE_AUTO_DELETE = \"transport.amqp.IsQueueAutoDelete\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * True if the polling task should wait until the she processed the accepted message. This can be used\n", 
            "+     * in conjunction with a single thread polling task(in the whole transport, i.e. only a single AMQP proxy per flow)\n", 
            "+     * to achieve in order delivery.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_OPERATE_ON_BLOCKING_MODE = \"transport.amqp.OperateOnBlockingMode\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * If a polling task encounter an exception due to some reason(most probably due to broker outage) the number of\n", 
            "+     * milliseconds it should be suspended before next re-try.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_INITIAL_RE_CONNECTION_DURATION = \"transport.amqp.InitialReconnectDuration\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * If the polling task fails again after the initial re-connection duration\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_INITIAL_RE_CONNECTION_DURATION}\n", 
            "+     * next suspend duration will be calculated using this\n", 
            "+     * (PARAMETER_RE_CONNECTION_PROGRESSION_FACTOR * PARAMETER_INITIAL_RE_CONNECTION_DURATION).\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_RE_CONNECTION_PROGRESSION_FACTOR = \"transport.amqp.ReconnectionProgressionFactor\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The maximum duration to suspend the polling task in case of an error. The current suspend duration will reach this\n", 
            "+     * value by following the series,\n", 
            "+     * PARAMETER_RE_CONNECTION_PROGRESSION_FACTOR * PARAMETER_INITIAL_RE_CONNECTION_DURATION. This upper bound is there\n", 
            "+     * because nobody wants to wait a long time until the next re-try if the broker is alive.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_MAX_RE_CONNECTION_DURATION = \"transport.amqp.MaximumReconnectionDuration\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The connection factory to be used either with consumer or producer.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_CONNECTION_FACTORY_NAME = \"transport.amqp.ConnectionFactoryName\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * In a two-way scenario which connection factory of the senders' should be used to send the response\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_RESPONSE_CONNECTION_FACTORY_NAME =\n", 
            "+            \"transport.amqp.ResponseConnectionFactoryName\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The initial delay(in milliseconds) that the polling task should delay before initial attempt.\n", 
            "+     * http://docs.oracle.com/javase/6/docs/api/index.html?java/util/concurrent/ScheduledExecutorService.html\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_SCHEDULED_TASK_INITIAL_DELAY =\n", 
            "+            \"transport.amqp.ScheduledTaskInitialDelay\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The delay(in milliseconds) that the polling task should delay before next attempt.\n", 
            "+     * http://docs.oracle.com/javase/6/docs/api/index.html?java/util/concurrent/ScheduledExecutorService.html\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_SCHEDULED_TASK_DELAY = \"transport.amqp.ScheduledTaskDelay\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The time unit which should use to calculate,\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_SCHEDULED_TASK_INITIAL_DELAY} and\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_SCHEDULED_TASK_DELAY}.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_SCHEDULED_TASK_TIME_UNIT = \"transport.amqp.ScheduledTaskTimeUnit\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Number of concurrent consumers per polling task.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_NO_OF_CONCURRENT_CONSUMERS = \"transport.amqp.NoOfConcurrentConsumers\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Number of dispatching task to use any request messages to actual processing task.\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_DISPATCHING_TASK_SIZE = \"transport.amqp.NoOfDispatchingTask\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Use the given channel number if possible. See\n", 
            "+     * http://www.rabbitmq.com/releases/rabbitmq-java-client/v3.0.1/rabbitmq-java-client-javadoc-3.0.1/com/rabbitmq/client/Connection.html#createChannel(int)\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_AMQP_CHANNEL_NUMBER = \"transport.amqp.ChannelNumber\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Configure the content type as a service parameter\n", 
            "+     */\n", 
            "+    public static final String PARAMETER_CONFIGURED_CONTENT_TYPE = \"transport.amqp.ContentType\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the AMQP message content type.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_CONTENT_TYPE = \"AMQP_CONTENT_TYPE\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the AMQP message encoding.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_CONTENT_ENCODING = \"AMQP_CONTENT_ENCODING\";\n", 
            "+\n", 
            "+\n", 
            "+    public static final String AMQP_HEADER = \"AMQP_HEADER\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the AMQP message delivery mode.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_DELIVER_MODE = \"AMQP_DELIVERY_MODE\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the AMQP message priority.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_PRIORITY = \"AMQP_PRIORITY\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the AMQP message correlation id.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_CORRELATION_ID = \"AMQP_CORRELATION_ID\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the AMQP message reply to header.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_REPLY_TO = \"AMQP_REPLY_TO\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the AMQP expiration.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_EXPIRATION = \"AMQP_EXPIRATION\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the message id of the AMQP message.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_MESSAGE_ID = \"AMQP_MESSAGE_ID\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the timestamp of the AMQP message.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_TIME_STAMP = \"AMQP_TIME_STAMP\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the type of the AMQP message.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_TYPE = \"AMQP_TYPE\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the AMQP user id.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_USER_ID = \"AMQP_USER_ID\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the AMQP app id.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_APP_ID = \"AMQP_APP_ID\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Message context property to set the AMQP cluster id.\n", 
            "+     */\n", 
            "+    public static final String PROPERTY_AMQP_CLUSTER_ID = \"AMQP_CLUSTER_ID\";\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Configure the executor service worker pool size.\n", 
            "+     */\n", 
            "+\n", 
            "+    public static final String PARAM_CONNECTION_FACTORY_POOL_SIZE = \"connection-factory-pool-size\";\n", 
            "+\n", 
            "+    public static final int CONNECTION_FACTORY_POOL_DEFAULT = 20;\n", 
            "+\n", 
            "+    public static final String PARAM_RESPONSE_HANDLING_POOL_SIZE = \"response-handling-pool-size\";\n", 
            "+\n", 
            "+    public static final int RESPONSE_HANDLING_POOL_DEFAULT = 20;\n", 
            "+\n", 
            "+    public static final String PARAM_WORKER_POOL_SIZE = \"worker-pool-size\";\n", 
            "+\n", 
            "+    public static final int WORKER_POOL_DEFAULT = 1000;\n", 
            "+\n", 
            "+    public static final String PARAM_SEMAPHORE_TIME_OUT = \"semaphore-time-out\";\n", 
            "+\n", 
            "+    public static final String AMQP_CORRELATION_ID = \"AMQP_CORRELATION_ID\";\n", 
            "+\n", 
            "+    public static final String AMQP_TRANSPORT_BUFFER_KEY = \"AMQP_TRANSPORT_BUFFER_KEY\";\n", 
            "+\n", 
            "+    public static final String AMQP_USE_TX = \"tx\";\n", 
            "+\n", 
            "+    public static final String AMQP_USE_LWPC = \"lwpc\";\n", 
            "+\n", 
            "+    public static final String DEFAULT_CONTENT_TYPE = \"application/xml\";\n", 
            "+\n", 
            "+    public static final String ROUTING_KEY_DELIMITER = \",\";\n", 
            "+\n", 
            "+    public static final String RESPONSE_CONNECTION_FACTORY_NAME = \"RESPONSE_CONNECTION_FACTORY_NAME\";\n", 
            "+\n", 
            "+}\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportConstant.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportConstant.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,115", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp.connectionfactory;\n", 
            "+\n", 
            "+import org.apache.axis2.description.Parameter;\n", 
            "+import org.apache.axis2.description.ParameterInclude;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportException;\n", 
            "+\n", 
            "+import java.io.IOException;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.concurrent.ConcurrentHashMap;\n", 
            "+import java.util.concurrent.ExecutorService;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Holds a list of {@link AMQPTransportConnectionFactory}.\n", 
            "+ */\n", 
            "+public class AMQPTransportConnectionFactoryManager {\n", 
            "+\n", 
            "+    private static Log log = LogFactory.getLog(AMQPTransportConnectionFactoryManager.class);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Keeps the list of connection factories defined.\n", 
            "+     */\n", 
            "+    private ConcurrentHashMap<String, AMQPTransportConnectionFactory> factories =\n", 
            "+            new ConcurrentHashMap<String, AMQPTransportConnectionFactory>();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Add the list of defined connection factories definition.\n", 
            "+     *\n", 
            "+     * @param transportInDescription The connection factory definition in axis2.xml\n", 
            "+     * @param es An instance of java.util.concurrent.ExecutorService to use with AMQP connection\n", 
            "+     *           factory\n", 
            "+     */\n", 
            "+    public void addConnectionFactories(ParameterInclude transportInDescription, ExecutorService es) {\n", 
            "+        for (Parameter p : transportInDescription.getParameters()) {\n", 
            "+            try {\n", 
            "+                addConnectionFactory(p, es);\n", 
            "+            } catch (AMQPTransportException e) {\n", 
            "+                log.error(\"Error whiling adding the connection factory with name '\" + p.getName() +\n", 
            "+                        \"'. \", e);\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Add a connection factory definition into store.\n", 
            "+     */\n", 
            "+    public void addConnectionFactory(Parameter parameter, ExecutorService es)\n", 
            "+            throws AMQPTransportException {\n", 
            "+        factories.put(parameter.getName(), new AMQPTransportConnectionFactory(parameter, es));\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Get the connection factory with this name.\n", 
            "+     *\n", 
            "+     * @param name connection factory name.\n", 
            "+     * @return the connection factory with this name.\n", 
            "+     * @throws AMQPTransportException throws in case of an error.\n", 
            "+     */\n", 
            "+    public AMQPTransportConnectionFactory getConnectionFactory(final String name)\n", 
            "+            throws AMQPTransportException {\n", 
            "+        if (factories.containsKey(name)) {\n", 
            "+            return factories.get(name);\n", 
            "+        }\n", 
            "+        throw new AMQPTransportException(\"No connection factory found with the name '\" + name + \"'\");\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Remove and return the connection factory with this name.\n", 
            "+     *\n", 
            "+     * @param name connection factory name.\n", 
            "+     * @throws AMQPTransportException throws in case of an error.\n", 
            "+     */\n", 
            "+    public void removeConnectionFactory(final String name) throws AMQPTransportException {\n", 
            "+        if (factories.containsKey(name)) {\n", 
            "+            try {\n", 
            "+                // shutdown and remove\n", 
            "+                AMQPTransportConnectionFactory factory = factories.remove(name);\n", 
            "+                factory.shutDownChannel();\n", 
            "+                factory.shutDownConnection();\n", 
            "+            } catch (IOException e) {\n", 
            "+                throw new AMQPTransportException(\"Could not remove the connection '\" + name + \"'\", e);\n", 
            "+            }\n", 
            "+        }\n", 
            "+        throw new AMQPTransportException(\"No connection factory found with the name '\" + name + \"'\");\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Shutdown the open connections to the broker via the connection factory\n", 
            "+     */\n", 
            "+    public void shutDownConnectionFactories() throws AMQPTransportException {\n", 
            "+        try {\n", 
            "+            for (Map.Entry<String, AMQPTransportConnectionFactory> entry : factories.entrySet()) {\n", 
            "+                AMQPTransportConnectionFactory connectionFactory = entry.getValue();\n", 
            "+                connectionFactory.shutDownChannel();\n", 
            "+                connectionFactory.shutDownConnection();\n", 
            "+            }\n", 
            "+        } catch (IOException e) {\n", 
            "+            throw new AMQPTransportException(\"Error occurred whiling shutting down connections\", e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/connectionfactory/AMQPTransportConnectionFactoryManager.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/connectionfactory/AMQPTransportConnectionFactoryManager.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,228", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp.connectionfactory;\n", 
            "+\n", 
            "+import com.rabbitmq.client.Address;\n", 
            "+import com.rabbitmq.client.Channel;\n", 
            "+import com.rabbitmq.client.Connection;\n", 
            "+import com.rabbitmq.client.ConnectionFactory;\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axis2.AxisFault;\n", 
            "+import org.apache.axis2.description.Parameter;\n", 
            "+import org.apache.axis2.description.ParameterIncludeImpl;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportConstant;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportException;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportUtils;\n", 
            "+\n", 
            "+import java.io.IOException;\n", 
            "+import java.util.Hashtable;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.concurrent.ExecutorService;\n", 
            "+\n", 
            "+/**\n", 
            "+ * This wrap the connection factory definition in axis2.xml. See below for an example definition.\n", 
            "+ * <pre>\n", 
            "+ * {@code\n", 
            "+ * <transportReceiver name=\"amqp\" class=\"org.wso2.carbon.transports.amqp.AMQPTransportListener\">\n", 
            "+ * <parameter name=\"example-connection-factory1\" locked=\"false\">\n", 
            "+ *      <parameter name=\"transport.amqp.Uri\" locked=\"false\">amqp://userName:password@hostName:portNumber/virtualHost</parameter>\n", 
            "+ *      <parameter name=\"transport.amqp.BrokerList\" locked=\"false\">hostName1:portNumber1,hostName2:portNumber2,hostName3:portNumber3</parameter>\n", 
            "+ * </parameter>\n", 
            "+ *\n", 
            "+ * <parameter name=\"example-connection-factory2\" locked=\"false\">\n", 
            "+ *     <parameter name=\"example-connection-factory1\" locked=\"false\">\n", 
            "+ *     <parameter name=\"transport.amqp.Uri\" locked=\"false\">amqp://userName:password@hostName:portNumber/virtualHost</parameter>\n", 
            "+ *     <parameter name=\"transport.amqp.BrokerList\" locked=\"false\">hostName1:portNumber1,hostName2:portNumber2,hostName3:portNumber3</parameter>\n", 
            "+ * </parameter>\n", 
            "+ *\n", 
            "+ * <parameter name=\"default\" locked=\"false\">\n", 
            "+ *     <parameter name=\"example-connection-factory1\" locked=\"false\">\n", 
            "+ *     <parameter name=\"transport.amqp.Uri\" locked=\"false\">amqp://userName:password@hostName:portNumber/virtualHost</parameter>\n", 
            "+ *     <parameter name=\"transport.amqp.BrokerList\" locked=\"false\">hostName1:portNumber1,hostName2:portNumber2,hostName3:portNumber3</parameter>\n", 
            "+ * </parameter>\n", 
            "+ * </transportReceiver>\n", 
            "+ * }\n", 
            "+ * </pre>\n", 
            "+ */\n", 
            "+public class AMQPTransportConnectionFactory {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The name of the connection factory definition.\n", 
            "+     */\n", 
            "+    private String name = null;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The list of parameters(see above) in the connection factory definition.\n", 
            "+     */\n", 
            "+    private Hashtable<String, String> parameters = new Hashtable<String, String>();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The AMQP connection to the broker maintain per connection factory.\n", 
            "+     */\n", 
            "+    private Connection connection = null;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The AMQP channel for this connection, maintains per connection.\n", 
            "+     */\n", 
            "+    private Channel channel = null;\n", 
            "+\n", 
            "+\n", 
            "+    public AMQPTransportConnectionFactory(Parameter parameter, ExecutorService es)\n", 
            "+            throws AMQPTransportException {\n", 
            "+        try {\n", 
            "+            this.name = parameter.getName();\n", 
            "+\n", 
            "+            ParameterIncludeImpl pi = new ParameterIncludeImpl();\n", 
            "+\n", 
            "+            if (!(parameter.getValue() instanceof OMElement)) {\n", 
            "+                throw new AMQPTransportException(\"The connection factory '\" + parameter.getName() +\n", 
            "+                        \"' is in valid. It's required to have the least connection factory definition with '\" +\n", 
            "+                        AMQPTransportConstant.PARAMETER_CONNECTION_URI + \"' parameter. Example: \\n\" +\n", 
            "+                        \"\\n<transportReceiver name=\\\"amqp\\\" class=\\\"org.wso2.carbon.transports.amqp.AMQPTransportListener\\\">\\n\" +\n", 
            "+                        \"   <parameter name=\\\"default\\\" locked=\\\"false\\\">\\n\" +\n", 
            "+                        \"      <parameter name=\\\"transport.amqp.Uri\\\" locked=\\\"false\\\">amqp://rajika:rajika123@localhost:5672/default</parameter>\\n\" +\n", 
            "+                        \"   </parameter>\\n\" +\n", 
            "+                        \"</transportReceiver>\\n\");\n", 
            "+            }\n", 
            "+            try {\n", 
            "+                pi.deserializeParameters(parameter.getParameterElement());\n", 
            "+            } catch (AxisFault axisFault) {\n", 
            "+                throw new AMQPTransportException(\"Error reading connection factory configuration from '\" +\n", 
            "+                        parameter.getName() + \"'\", axisFault);\n", 
            "+            }\n", 
            "+\n", 
            "+            for (Parameter entry : pi.getParameters()) {\n", 
            "+                parameters.put(entry.getName(), (String) entry.getValue());\n", 
            "+            }\n", 
            "+\n", 
            "+            ConnectionFactory connectionFactory = new ConnectionFactory();\n", 
            "+            connectionFactory.setUri(parameters.get(AMQPTransportConstant.PARAMETER_CONNECTION_URI));\n", 
            "+\n", 
            "+            if (parameters.get(AMQPTransportConstant.PARAMETER_BROKER_LIST) != null) {\n", 
            "+                Address[] addresses = AMQPTransportUtils.getAddressArray(\n", 
            "+                        parameters.get(AMQPTransportConstant.PARAMETER_BROKER_LIST), \",\", ':');\n", 
            "+                connection = connectionFactory.newConnection(es, addresses);\n", 
            "+            } else {\n", 
            "+                connection = connectionFactory.newConnection(es);\n", 
            "+            }\n", 
            "+\n", 
            "+            if (parameters.get(AMQPTransportConstant.PARAMETER_AMQP_CHANNEL_NUMBER) != null) {\n", 
            "+                int index = 0;\n", 
            "+                try {\n", 
            "+                    index = Integer.parseInt(parameters.get(\n", 
            "+                            AMQPTransportConstant.PARAMETER_AMQP_CHANNEL_NUMBER));\n", 
            "+                } catch (NumberFormatException e) {\n", 
            "+                    index = 1; // assume default,\n", 
            "+                    // fair dispatch see http://www.rabbitmq.com/tutorials/tutorial-two-java.html\n", 
            "+                }\n", 
            "+                channel = connection.createChannel(index);\n", 
            "+\n", 
            "+            } else {\n", 
            "+                channel = connection.createChannel();\n", 
            "+            }\n", 
            "+\n", 
            "+\n", 
            "+            int prefetchSize = 1024;\n", 
            "+            if (parameters.get(AMQPTransportConstant.PARAMETER_CHANNEL_PREFETCH_SIZE) != null) {\n", 
            "+                try {\n", 
            "+                    prefetchSize = Integer.parseInt(\n", 
            "+                            parameters.get(AMQPTransportConstant.PARAMETER_CHANNEL_PREFETCH_SIZE));\n", 
            "+                } catch (NumberFormatException e) {\n", 
            "+                    prefetchSize = 1024; // assume default\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+            int prefetchCount = 0;\n", 
            "+            if (parameters.get(AMQPTransportConstant.PARAMETER_CHANNEL_PREFETCH_COUNT) != null) {\n", 
            "+                try {\n", 
            "+                    prefetchCount = Integer.parseInt(\n", 
            "+                            parameters.get(AMQPTransportConstant.PARAMETER_CHANNEL_PREFETCH_COUNT));\n", 
            "+                    channel.basicQos(prefetchCount);\n", 
            "+                } catch (NumberFormatException e) {\n", 
            "+                    prefetchCount = 0; // assume default\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+            boolean useGlobally = false;\n", 
            "+            if (parameters.get(AMQPTransportConstant.PARAMETER_CHANNEL_QOS_GLOBAL) != null) {\n", 
            "+                useGlobally = Boolean.parseBoolean(parameters.get(\n", 
            "+                        AMQPTransportConstant.PARAMETER_CHANNEL_QOS_GLOBAL));\n", 
            "+            }\n", 
            "+\n", 
            "+\n", 
            "+        } catch (Exception e) {\n", 
            "+            throw new AMQPTransportException(\"\" +\n", 
            "+                    \"Could not initialize the connection factory '\" + parameter.getName() + \"'\", e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Shutdown this connection.\n", 
            "+     *\n", 
            "+     * @throws IOException\n", 
            "+     */\n", 
            "+    public void shutDownConnection() throws IOException {\n", 
            "+        if (connection != null && connection.isOpen()) {\n", 
            "+            connection.close();\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Shutdown this channel.\n", 
            "+     *\n", 
            "+     * @throws IOException\n", 
            "+     */\n", 
            "+    public void shutDownChannel() throws IOException {\n", 
            "+        if (channel != null && channel.isOpen()) {\n", 
            "+            channel.close();\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Get the channel in this connection.\n", 
            "+     *\n", 
            "+     * @return channel associated with this\n", 
            "+     */\n", 
            "+    public Channel getChannel() {\n", 
            "+        return channel;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Return the name of this connection factory(the name given in axis2.xml)\n", 
            "+     *\n", 
            "+     * @return name of this connection factory\n", 
            "+     */\n", 
            "+    public String getName() {\n", 
            "+        return name;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the value of parameter.\n", 
            "+     *\n", 
            "+     * @param parameterName name of the parameter.\n", 
            "+     * @return the value of the parameter.\n", 
            "+     */\n", 
            "+    public String getParameterValue(final String parameterName) {\n", 
            "+        return parameters.get(parameterName);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the list of all parameters in this connection factory.\n", 
            "+     *\n", 
            "+     * @return the list of parameters.\n", 
            "+     */\n", 
            "+    public Map<String, String> getParameters() {\n", 
            "+        return parameters;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/connectionfactory/AMQPTransportConnectionFactory.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/connectionfactory/AMQPTransportConnectionFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,707", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp.pollingtask;\n", 
            "+\n", 
            "+import com.rabbitmq.client.AMQP;\n", 
            "+import com.rabbitmq.client.Channel;\n", 
            "+import com.rabbitmq.client.QueueingConsumer;\n", 
            "+import org.apache.axiom.om.OMAbstractFactory;\n", 
            "+import org.apache.axiom.om.OMDocument;\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axiom.soap.*;\n", 
            "+import org.apache.axis2.AxisFault;\n", 
            "+import org.apache.axis2.Constants;\n", 
            "+import org.apache.axis2.builder.Builder;\n", 
            "+import org.apache.axis2.builder.BuilderUtil;\n", 
            "+import org.apache.axis2.context.MessageContext;\n", 
            "+import org.apache.axis2.engine.AxisEngine;\n", 
            "+import org.apache.axis2.transport.TransportUtils;\n", 
            "+import org.apache.axis2.transport.http.HTTPTransportUtils;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.transport.amqp.*;\n", 
            "+\n", 
            "+import java.io.ByteArrayInputStream;\n", 
            "+import java.io.ByteArrayOutputStream;\n", 
            "+import java.io.IOException;\n", 
            "+import java.io.InputStream;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.concurrent.ExecutorService;\n", 
            "+import java.util.concurrent.ScheduledExecutorService;\n", 
            "+import java.util.concurrent.ScheduledFuture;\n", 
            "+import java.util.concurrent.TimeUnit;\n", 
            "+\n", 
            "+/**\n", 
            "+ * The polling task deploy for each services exposed on AMQP transport. This task\n", 
            "+ */\n", 
            "+public class AMQPTransportPollingTask {\n", 
            "+\n", 
            "+    private static Log log = LogFactory.getLog(AMQPTransportPollingTask.class);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * State of the current polling task.\n", 
            "+     */\n", 
            "+    private enum TASK_STATE {\n", 
            "+        STOPPED, STARTED, FAILURE\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The name of the service this polling task belongs to.\n", 
            "+     */\n", 
            "+    private String serviceName;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The exchange of this polling task belongs to.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_EXCHANGE_NAME}\n", 
            "+     */\n", 
            "+    private String exchangeName = null;\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The durability of this exchange. Default non durable(i.e. transient).\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_EXCHANGE_IS_DURABLE}\n", 
            "+     */\n", 
            "+    private boolean isExchangeDurable = false;\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Should the exchange that will be declared by this polling task should be auto deleted ?\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_EXCHANGE_IS_AUTO_DELETE}\n", 
            "+     */\n", 
            "+    private boolean isExchangeAutoDelete = true;\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The type of the exchange. Default to direct type.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_EXCHANGE_TYPE}\n", 
            "+     */\n", 
            "+    private String exchangeType = \"direct\";\n", 
            "+\n", 
            "+    /**\n", 
            "+     * True if this is an internal exchange.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_EXCHANGE_INTERNAL}\n", 
            "+     */\n", 
            "+    private boolean isInternalExchange = false;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The name of the exchange to which the consumer should bind into.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_BIND_EXCHANGE} at consumer side.\n", 
            "+     */\n", 
            "+    private String consumerExchangeName = null;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The list of binding keys at consumer side.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_BINDING_KEYS}\n", 
            "+     */\n", 
            "+    private String[] bindingsKeys = null;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Should this task manager be participated in a tx(not distributed)?, by default this is false\n", 
            "+     * and auto acknowledgment will be used\n", 
            "+     */\n", 
            "+    private boolean isUseTx = false;\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The name of the queue this consumer should bind to.{@link AMQPTransportConstant#PARAMETER_QUEUE_NAME}\n", 
            "+     */\n", 
            "+    private String queueName = null;\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * True if this queue should be durable. {@link AMQPTransportConstant#PARAMETER_QUEUE_DURABLE}\n", 
            "+     */\n", 
            "+    private boolean isQueueDurable = false;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * True if this queue should be restricted.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_QUEUE_RESTRICTED}\n", 
            "+     */\n", 
            "+    private boolean isQueueRestricted = false;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * True if this queue should be deleted automatically.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_QUEUE_AUTO_DELETE}\n", 
            "+     */\n", 
            "+    private boolean isQueueAutoDelete = true;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Should this polling task should wait until processed the current message.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_OPERATE_ON_BLOCKING_MODE}\n", 
            "+     */\n", 
            "+    private boolean isBlockingMode = false;\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Number of concurrent consumers per this polling task.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_NO_OF_CONCURRENT_CONSUMERS}\n", 
            "+     */\n", 
            "+    private int noOfConcurrentConsumers = 2;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Initial duration(in milliseconds) to suspend the polling task in case of an error.\n", 
            "+     * {@link org.apache.synapse.transport.amqp.AMQPTransportConstant#PARAMETER_INITIAL_RE_CONNECTION_DURATION}.\n", 
            "+     */\n", 
            "+    private int initialReconnectDuration = 1000;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The progression factor for next re-try calculation.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_RE_CONNECTION_PROGRESSION_FACTOR}\n", 
            "+     */\n", 
            "+    private double reconnectionFactor = 2.0;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The maximum duration to suspend the polling task. This is to make sure there is an upper\n", 
            "+     * bound for the suspending the polling task in case of an error.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_MAX_RE_CONNECTION_DURATION}\n", 
            "+     */\n", 
            "+    private int maxReconnectionDuration = 1000 * 60 * 10;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The name of the connectionFactory this service is bound to.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_CONNECTION_FACTORY_NAME}\n", 
            "+     */\n", 
            "+    private String connectionFactoryName;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The name of the connection factory that this service should be using to send\n", 
            "+     * the response in a two way scenario. Default to null\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_RESPONSE_CONNECTION_FACTORY_NAME}\n", 
            "+     */\n", 
            "+    private String responseConnectionFactory = null;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The initial delay the scheduled task should wait. Don't wait by default.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_SCHEDULED_TASK_INITIAL_DELAY}\n", 
            "+     */\n", 
            "+    private long scheduledTaskInitialDelay = 0;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The delay that the scheduled task should wait.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_SCHEDULED_TASK_DELAY}\n", 
            "+     */\n", 
            "+    private long scheduledTaskDelay = 1;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The time unit for scheduled task delay.\n", 
            "+     * {@link AMQPTransportConstant#PARAMETER_SCHEDULED_TASK_TIME_UNIT}.\n", 
            "+     */\n", 
            "+    private TimeUnit scheduledTaskTimeUnit = TimeUnit.MILLISECONDS;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The number of tasks per deployed service for dispatching request messages into worker tasks.\n", 
            "+     */\n", 
            "+    private int noOfDispatchingTask = 2;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The worker pool for I/O, dispatching and actual processing.\n", 
            "+     */\n", 
            "+    private ScheduledExecutorService pollingTaskScheduler = null;\n", 
            "+\n", 
            "+    private AMQPTransportEndpoint endpoint = null;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The buffers which keeps request/response messages until pick by processing/response tasks.\n", 
            "+     */\n", 
            "+    private AMQPTransportBuffers buffers = null;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The AMQP channel to use.\n", 
            "+     */\n", 
            "+    private Channel channel;\n", 
            "+\n", 
            "+    private String configuredContentType = AMQPTransportConstant.DEFAULT_CONTENT_TYPE;\n", 
            "+\n", 
            "+    private ScheduledFuture<?> pollingTaskFuture;\n", 
            "+\n", 
            "+    public void setUseTx(boolean useTx) {\n", 
            "+        isUseTx = useTx;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setChannel(Channel channel) {\n", 
            "+        this.channel = channel;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setConfiguredContentType(String configuredContentType) {\n", 
            "+        this.configuredContentType = configuredContentType;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setBuffers(AMQPTransportBuffers buffers) {\n", 
            "+        this.buffers = buffers;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setEndpoint(AMQPTransportEndpoint endpoint) {\n", 
            "+        this.endpoint = endpoint;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setServiceName(String serviceName) {\n", 
            "+        this.serviceName = serviceName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setExchangeName(String exchangeName) {\n", 
            "+        this.exchangeName = exchangeName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setExchangeDurable(boolean isExchangeDurable) {\n", 
            "+        this.isExchangeDurable = isExchangeDurable;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setExchangeAutoDelete(boolean exchangeAutoDelete) {\n", 
            "+        isExchangeAutoDelete = exchangeAutoDelete;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setExchangeType(String exchangeType) {\n", 
            "+        this.exchangeType = exchangeType;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setInternalExchange(boolean internalExchange) {\n", 
            "+        isInternalExchange = internalExchange;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setConsumerExchangeName(String consumerExchangeName) {\n", 
            "+        this.consumerExchangeName = consumerExchangeName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setBindingsKeys(String[] bindingsKeys) {\n", 
            "+        this.bindingsKeys = bindingsKeys;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setQueueName(String queueName) {\n", 
            "+        this.queueName = queueName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setQueueDurable(boolean queueDurable) {\n", 
            "+        isQueueDurable = queueDurable;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setQueueRestricted(boolean queueRestricted) {\n", 
            "+        isQueueRestricted = queueRestricted;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setQueueAutoDelete(boolean queueAutoDelete) {\n", 
            "+        isQueueAutoDelete = queueAutoDelete;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setBlockingMode(boolean blockingMode) {\n", 
            "+        isBlockingMode = blockingMode;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setNoOfConcurrentConsumers(int noOfConcurrentConsumers) {\n", 
            "+        this.noOfConcurrentConsumers = noOfConcurrentConsumers;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setInitialReconnectDuration(int initialReconnectDuration) {\n", 
            "+        this.initialReconnectDuration = initialReconnectDuration;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setReconnectionFactor(double reconnectionFactor) {\n", 
            "+        this.reconnectionFactor = reconnectionFactor;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setMaxReconnectionDuration(int maxReconnectionDuration) {\n", 
            "+        this.maxReconnectionDuration = maxReconnectionDuration;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setConnectionFactoryName(String connectionFactoryName) {\n", 
            "+        this.connectionFactoryName = connectionFactoryName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setScheduledTaskInitialDelay(int scheduledTaskInitialDelay) {\n", 
            "+        this.scheduledTaskInitialDelay = scheduledTaskInitialDelay;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setScheduledTaskDelay(int scheduledTaskDelay) {\n", 
            "+        this.scheduledTaskDelay = scheduledTaskDelay;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setScheduledTaskTimeUnit(TimeUnit scheduledTaskTimeUnit) {\n", 
            "+        this.scheduledTaskTimeUnit = scheduledTaskTimeUnit;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setNoOfDispatchingTask(int noOfDispatchingTask) {\n", 
            "+        this.noOfDispatchingTask = noOfDispatchingTask;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setPollingTaskScheduler(ScheduledExecutorService pollingTaskScheduler) {\n", 
            "+        this.pollingTaskScheduler = pollingTaskScheduler;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getServiceName() {\n", 
            "+        return serviceName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getExchangeName() {\n", 
            "+        return exchangeName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isExchangeDurable() {\n", 
            "+        return isExchangeDurable;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isExchangeAutoDelete() {\n", 
            "+        return isExchangeAutoDelete;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getExchangeType() {\n", 
            "+        return exchangeType;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isInternalExchange() {\n", 
            "+        return isInternalExchange;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getConsumerExchangeName() {\n", 
            "+        return consumerExchangeName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String[] getBindingsKeys() {\n", 
            "+        return bindingsKeys;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getQueueName() {\n", 
            "+        return queueName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isQueueDurable() {\n", 
            "+        return isQueueDurable;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isQueueRestricted() {\n", 
            "+        return isQueueRestricted;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isQueueAutoDelete() {\n", 
            "+        return isQueueAutoDelete;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isBlockingMode() {\n", 
            "+        return isBlockingMode;\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getNoOfConcurrentConsumers() {\n", 
            "+        return noOfConcurrentConsumers;\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getInitialReconnectDuration() {\n", 
            "+        return initialReconnectDuration;\n", 
            "+    }\n", 
            "+\n", 
            "+    public double getReconnectionFactor() {\n", 
            "+        return reconnectionFactor;\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getMaxReconnectionDuration() {\n", 
            "+        return maxReconnectionDuration;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getConnectionFactoryName() {\n", 
            "+        return connectionFactoryName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public TimeUnit getScheduledTaskTimeUnit() {\n", 
            "+        return scheduledTaskTimeUnit;\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getNoOfDispatchingTask() {\n", 
            "+        return noOfDispatchingTask;\n", 
            "+    }\n", 
            "+\n", 
            "+    public ExecutorService getPollingTaskScheduler() {\n", 
            "+        return pollingTaskScheduler;\n", 
            "+    }\n", 
            "+\n", 
            "+    public AMQPTransportEndpoint getEndpoint() {\n", 
            "+        return endpoint;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setResponseConnectionFactory(String responseConnectionFactory) {\n", 
            "+        this.responseConnectionFactory = responseConnectionFactory;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Start the polling task for this service\n", 
            "+     */\n", 
            "+    public synchronized void start() throws AMQPTransportException {\n", 
            "+\n", 
            "+        try {\n", 
            "+            if (exchangeName != null) {\n", 
            "+\n", 
            "+                channel.exchangeDeclare(\n", 
            "+                        exchangeName,\n", 
            "+                        exchangeType,\n", 
            "+                        isExchangeDurable,\n", 
            "+                        isExchangeAutoDelete,\n", 
            "+                        isInternalExchange,\n", 
            "+                        null);\n", 
            "+\n", 
            "+                String newQueueName = channel.queueDeclare().getQueue();\n", 
            "+                log.info(\"QueueName is set to '\" + newQueueName + \"' for service '\" + serviceName + \"'\");\n", 
            "+                queueName = newQueueName; // when there is an exchange, it generates a queue name for us\n", 
            "+\n", 
            "+                if (bindingsKeys != null) {\n", 
            "+                    // routing\n", 
            "+                    for (String bindingKey : bindingsKeys) {\n", 
            "+                        channel.queueBind(queueName, exchangeName, bindingKey);\n", 
            "+                    }\n", 
            "+                } else {\n", 
            "+                    // subscriber\n", 
            "+                    channel.queueBind(queueName, exchangeName, \"\");\n", 
            "+                }\n", 
            "+\n", 
            "+            } else {\n", 
            "+                // assume default exchange and bindings - simple consumer\n", 
            "+                channel.queueDeclare(queueName, isQueueDurable, isQueueRestricted, isQueueAutoDelete, null);\n", 
            "+\n", 
            "+            }\n", 
            "+        } catch (IOException e) {\n", 
            "+            handleException(e.getMessage(), e);\n", 
            "+        }\n", 
            "+\n", 
            "+        // schedule dispatching tasks to handover messages from the internal buffer to actual processing task\n", 
            "+        for (int i = 0; i < noOfDispatchingTask; i++) {\n", 
            "+            pollingTaskScheduler.execute(new MessageDispatchTask(buffers));\n", 
            "+        }\n", 
            "+\n", 
            "+        // schedule IO task to pull messages from the broker\n", 
            "+        for (int i = 0; i < noOfConcurrentConsumers; i++) {\n", 
            "+            // only channels are thread safe, so create consumer per thread\n", 
            "+            try {\n", 
            "+                QueueingConsumer consumer = new QueueingConsumer(channel);\n", 
            "+                boolean isAutoAck = isUseTx == true ? false : true; // increase readability\n", 
            "+                channel.basicConsume(queueName, isAutoAck, consumer);\n", 
            "+                pollingTaskFuture = pollingTaskScheduler.scheduleWithFixedDelay(\n", 
            "+                        new MessageIOTask(consumer, buffers, isUseTx),\n", 
            "+                        scheduledTaskInitialDelay,\n", 
            "+                        scheduledTaskDelay,\n", 
            "+                        scheduledTaskTimeUnit);\n", 
            "+            } catch (IOException e) {\n", 
            "+                handleException(e.getMessage(), e);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"A polling task started listening on the queue '\" + queueName + \"' on behalf of the service '\" +\n", 
            "+                    serviceName + \"'\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Stop the polling task\n", 
            "+     */\n", 
            "+    public synchronized void stop() {\n", 
            "+        pollingTaskFuture.cancel(false);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The message dispatch task which dispatch messages from the source buffers to actual\n", 
            "+     * processing logic\n", 
            "+     */\n", 
            "+    private final class MessageIOTask implements Runnable {\n", 
            "+\n", 
            "+        private AMQPTransportBuffers buffers;\n", 
            "+        private QueueingConsumer queueingConsumer;\n", 
            "+        private boolean isUseTx;\n", 
            "+\n", 
            "+        private MessageIOTask(QueueingConsumer queueingConsumer,\n", 
            "+                              AMQPTransportBuffers buffers,\n", 
            "+                              boolean isAutoAck) {\n", 
            "+            this.queueingConsumer = queueingConsumer;\n", 
            "+            this.buffers = buffers;\n", 
            "+            this.isUseTx = isAutoAck;\n", 
            "+        }\n", 
            "+\n", 
            "+        public void run() {\n", 
            "+            try {\n", 
            "+                if (isUseTx) {\n", 
            "+                    channel.txSelect();\n", 
            "+                }\n", 
            "+                QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();\n", 
            "+                if (delivery != null) {\n", 
            "+                    buffers.addRequestMessage(new AMQPTransportMessage(delivery));\n", 
            "+                    if (isUseTx) {\n", 
            "+                        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);\n", 
            "+                        channel.txCommit();\n", 
            "+                    }\n", 
            "+                } else {\n", 
            "+                    if (isUseTx) {\n", 
            "+                        channel.txRollback();\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            } catch (InterruptedException e) {\n", 
            "+                log.error(\"Polling task was interrupted for service '\" + serviceName + \"'\", e);\n", 
            "+                Thread.currentThread().interrupt();\n", 
            "+            } catch (IOException e) {\n", 
            "+                log.error(\"I/O error occurs for the polling tasks for service '\" + serviceName +\n", 
            "+                        \"'\", e);\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The message dispatch task which dispatch messages from the source buffers to actual\n", 
            "+     * processing logic\n", 
            "+     */\n", 
            "+    private final class MessageDispatchTask implements Runnable {\n", 
            "+        private AMQPTransportBuffers buffers;\n", 
            "+\n", 
            "+        private MessageDispatchTask(AMQPTransportBuffers buffers) {\n", 
            "+            this.buffers = buffers;\n", 
            "+        }\n", 
            "+\n", 
            "+        public void run() {\n", 
            "+            while (true) {\n", 
            "+                AMQPTransportMessage msg = buffers.getRequestMessage();\n", 
            "+                if (msg != null) {\n", 
            "+                    pollingTaskScheduler.execute(new MessageProcessingTask(msg, buffers));\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Process any request messages\n", 
            "+     */\n", 
            "+    private final class MessageProcessingTask implements Runnable {\n", 
            "+\n", 
            "+        private AMQPTransportMessage message;\n", 
            "+        private AMQPTransportBuffers buffers;\n", 
            "+        private boolean isSOAP11;\n", 
            "+\n", 
            "+        private MessageProcessingTask(\n", 
            "+                AMQPTransportMessage message,\n", 
            "+                AMQPTransportBuffers buffers) {\n", 
            "+\n", 
            "+            this.message = message;\n", 
            "+            this.buffers = buffers;\n", 
            "+        }\n", 
            "+\n", 
            "+        public void run() {\n", 
            "+            try {\n", 
            "+                handleIncomingMessage(message, buffers);\n", 
            "+            } catch (AxisFault axisFault) {\n", 
            "+                // there seems to be a fault while trying to execute the back end service\n", 
            "+                // send a fault to the client\n", 
            "+                try {\n", 
            "+                    handleFaultMessage(message, buffers, axisFault);\n", 
            "+                } catch (Exception e) {\n", 
            "+                    // do not let the task die\n", 
            "+                    log.error(\"Error while sending the fault message to the client. Client will not\" +\n", 
            "+                            \" receive any errors!\", e);\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        private boolean handleIncomingMessage(AMQPTransportMessage message,\n", 
            "+                                              AMQPTransportBuffers buffers) throws AxisFault {\n", 
            "+            if (message == null) {\n", 
            "+                throw new AxisFault(\"A null message received!\");\n", 
            "+            } else {\n", 
            "+                try {\n", 
            "+                    MessageContext msgContext = endpoint.createMessageContext();\n", 
            "+                    String msgId = message.getMessageId();\n", 
            "+                    msgContext.setMessageID(msgId);\n", 
            "+                    msgContext.setProperty(AMQPTransportConstant.AMQP_CORRELATION_ID,\n", 
            "+                            message.getCorrelationId());\n", 
            "+                    msgContext.setProperty(AMQPTransportConstant.AMQP_TRANSPORT_BUFFER_KEY, buffers);\n", 
            "+\n", 
            "+                    String contentType = message.getContentType();\n", 
            "+                    if (contentType == null) {\n", 
            "+                        // use the configured value for content type\n", 
            "+                        contentType = configuredContentType;\n", 
            "+                    }\n", 
            "+\n", 
            "+                    Map<String, Object> trpHeaders = message.getHeaders();\n", 
            "+\n", 
            "+                    if (message.getReplyTo() != null) {\n", 
            "+                        // this may not be the optimal way to check if this message should send a reply\n", 
            "+                        // a one way message can be send with 'reply to' set\n", 
            "+                        msgContext.setProperty(Constants.OUT_TRANSPORT_INFO,\n", 
            "+                                new AMQPOutTransportInfo(contentType, responseConnectionFactory,\n", 
            "+                                        message.getReplyTo()));\n", 
            "+                        msgContext.setProperty(AMQPTransportConstant.PROPERTY_AMQP_REPLY_TO,\n", 
            "+                                message.getReplyTo());\n", 
            "+                        // cache the connection factory so that it can be used for sending the response\n", 
            "+                        msgContext.setProperty(AMQPTransportConstant.RESPONSE_CONNECTION_FACTORY_NAME,\n", 
            "+                                responseConnectionFactory);\n", 
            "+                    }\n", 
            "+\n", 
            "+                    HTTPTransportUtils.initializeMessageContext(\n", 
            "+                            msgContext,\n", 
            "+                            message.getSoapAction(),\n", 
            "+                            null,\n", 
            "+                            contentType);\n", 
            "+\n", 
            "+                    ByteArrayInputStream inputStream = new ByteArrayInputStream(message.getBody());\n", 
            "+\n", 
            "+                    msgContext.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);\n", 
            "+                    msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, trpHeaders);\n", 
            "+\n", 
            "+                    Builder builder = BuilderUtil.getBuilderFromSelector(contentType, msgContext);\n", 
            "+                    InputStream gzipInputStream = HTTPTransportUtils.handleGZip(msgContext, inputStream);\n", 
            "+                    OMElement documentElement = builder.processDocument(gzipInputStream, contentType, msgContext);\n", 
            "+                    msgContext.setEnvelope(TransportUtils.createSOAPEnvelope(documentElement));\n", 
            "+                    isSOAP11 = msgContext.isSOAP11();\n", 
            "+\n", 
            "+                    AxisEngine.receive(msgContext);\n", 
            "+\n", 
            "+                    return true;\n", 
            "+\n", 
            "+                } catch (IOException e) {\n", 
            "+                    throw new AxisFault(e.getMessage(), e);\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        private void handleFaultMessage(AMQPTransportMessage originalMsg,\n", 
            "+                                        AMQPTransportBuffers buffers,\n", 
            "+                                        AxisFault axisFault) throws Exception {\n", 
            "+\n", 
            "+            SOAPFactory factory = (isSOAP11 ?\n", 
            "+                    OMAbstractFactory.getSOAP11Factory() : OMAbstractFactory.getSOAP12Factory());\n", 
            "+            OMDocument soapFaultDocument = factory.createOMDocument();\n", 
            "+            SOAPEnvelope faultEnvelope = factory.getDefaultFaultEnvelope();\n", 
            "+            soapFaultDocument.addChild(faultEnvelope);\n", 
            "+\n", 
            "+            // create the fault element  if it is needed\n", 
            "+            SOAPFault fault = faultEnvelope.getBody().getFault();\n", 
            "+            if (fault == null) {\n", 
            "+                fault = factory.createSOAPFault();\n", 
            "+            }\n", 
            "+            SOAPFaultCode code = factory.createSOAPFaultCode();\n", 
            "+            code.setText(axisFault.getMessage());\n", 
            "+            fault.setCode(code);\n", 
            "+\n", 
            "+            SOAPFaultReason reason = factory.createSOAPFaultReason();\n", 
            "+            reason.setText(axisFault.getMessage());\n", 
            "+            fault.setReason(reason);\n", 
            "+\n", 
            "+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n", 
            "+            faultEnvelope.serialize(out);\n", 
            "+            AMQPTransportMessage msg = new AMQPTransportMessage(\n", 
            "+                    new AMQP.BasicProperties(), out.toByteArray());\n", 
            "+            try {\n", 
            "+                buffers.addResponseMessage(msg);\n", 
            "+            } catch (InterruptedException e) {\n", 
            "+                Thread.currentThread().interrupt();\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    private void handleException(String msg, Throwable t) throws AMQPTransportException {\n", 
            "+        log.error(msg, t);\n", 
            "+        throw new AMQPTransportException(msg, t);\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPTransportPollingTask.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPTransportPollingTask.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,110", 
          "lines": [
            "+/*\n", 
            "+ * ====================================================================\n", 
            "+ * Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ * or more contributor license agreements.  See the NOTICE file\n", 
            "+ * distributed with this work for additional information\n", 
            "+ * regarding copyright ownership.  The ASF licenses this file\n", 
            "+ * to you under the Apache License, Version 2.0 (the\n", 
            "+ * \"License\"); you may not use this file except in compliance\n", 
            "+ * with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing,\n", 
            "+ * software distributed under the License is distributed on an\n", 
            "+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ * KIND, either express or implied.  See the License for the\n", 
            "+ * specific language governing permissions and limitations\n", 
            "+ * under the License.\n", 
            "+ * ====================================================================\n", 
            "+ *\n", 
            "+ * This software consists of voluntary contributions made by many\n", 
            "+ * individuals on behalf of the Apache Software Foundation.  For more\n", 
            "+ * information on the Apache Software Foundation, please see\n", 
            "+ * <http://www.apache.org/>.\n", 
            "+ *\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp.pollingtask;\n", 
            "+\n", 
            "+import com.rabbitmq.client.Channel;\n", 
            "+import com.rabbitmq.client.QueueingConsumer;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.transport.amqp.AMQPTransportMessage;\n", 
            "+\n", 
            "+import java.io.IOException;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.concurrent.ExecutorService;\n", 
            "+import java.util.concurrent.Semaphore;\n", 
            "+\n", 
            "+public class AMQPSimpleConsumerTask {\n", 
            "+\n", 
            "+    private static Log log = LogFactory.getLog(AMQPSimpleConsumerTask.class);\n", 
            "+\n", 
            "+    private Channel channel;\n", 
            "+\n", 
            "+    private String queueName;\n", 
            "+\n", 
            "+    private Map<String, Semaphore> responseTracker;\n", 
            "+\n", 
            "+    private Map<String, AMQPTransportMessage> responseMessage;\n", 
            "+\n", 
            "+    private ExecutorService workerPool;\n", 
            "+\n", 
            "+    public AMQPSimpleConsumerTask(\n", 
            "+            ExecutorService workerPool,\n", 
            "+            Channel channel,\n", 
            "+            String queueName,\n", 
            "+            Map<String, Semaphore> responseTracker,\n", 
            "+            Map<String, AMQPTransportMessage> responseMessage) {\n", 
            "+        this.workerPool = workerPool;\n", 
            "+        this.channel = channel;\n", 
            "+        this.queueName = queueName;\n", 
            "+        this.responseTracker = responseTracker;\n", 
            "+        this.responseMessage = responseMessage;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void consume() {\n", 
            "+        workerPool.submit(new Consumer(channel, queueName, responseTracker, responseMessage));\n", 
            "+    }\n", 
            "+\n", 
            "+    private static class Consumer implements Runnable {\n", 
            "+        Channel channel;\n", 
            "+        String queueName;\n", 
            "+        Map<String, Semaphore> responseTracker;\n", 
            "+        Map<String, AMQPTransportMessage> responseMessage;\n", 
            "+\n", 
            "+\n", 
            "+        private Consumer(\n", 
            "+                Channel channel,\n", 
            "+                String queueName,\n", 
            "+                Map<String, Semaphore> responseTracker,\n", 
            "+                Map<String, AMQPTransportMessage> responseMessage) {\n", 
            "+            this.channel = channel;\n", 
            "+            this.queueName = queueName;\n", 
            "+            this.responseTracker = responseTracker;\n", 
            "+            this.responseMessage = responseMessage;\n", 
            "+        }\n", 
            "+\n", 
            "+        @Override\n", 
            "+        public void run() {\n", 
            "+            try {\n", 
            "+                channel.queueDeclare(queueName, false, false, false, null);\n", 
            "+                QueueingConsumer queueingConsumer = new QueueingConsumer(channel);\n", 
            "+                channel.basicConsume(queueName, true, queueingConsumer);\n", 
            "+\n", 
            "+                QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();\n", 
            "+                AMQPTransportMessage msg = new AMQPTransportMessage(delivery);\n", 
            "+                responseMessage.put(msg.getCorrelationId(), msg);\n", 
            "+                Semaphore semaphore = responseTracker.get(msg.getCorrelationId());\n", 
            "+                semaphore.release();\n", 
            "+\n", 
            "+            } catch (IOException e) {\n", 
            "+                log.error(\"I/O error occurred while retrieving the\", e);\n", 
            "+            } catch (InterruptedException e) {\n", 
            "+                log.error(\"Retrieving task was interrupted\", e);\n", 
            "+                Thread.currentThread().interrupt();\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPSimpleConsumerTask.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPSimpleConsumerTask.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,272", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp.pollingtask;\n", 
            "+\n", 
            "+import org.apache.axis2.AxisFault;\n", 
            "+import org.apache.axis2.description.AxisService;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.transport.amqp.*;\n", 
            "+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactory;\n", 
            "+\n", 
            "+import java.util.Map;\n", 
            "+import java.util.concurrent.ScheduledExecutorService;\n", 
            "+import java.util.concurrent.TimeUnit;\n", 
            "+\n", 
            "+/**\n", 
            "+ * The factory implementation for {@link AMQPTransportPollingTask}. Polling task(with multiple)\n", 
            "+ * consumers will be deployed for each deployed service.\n", 
            "+ */\n", 
            "+public class AMQPTransportPollingTaskFactory {\n", 
            "+\n", 
            "+    private static Log log = LogFactory.getLog(AMQPTransportPollingTaskFactory.class);\n", 
            "+\n", 
            "+    public static AMQPTransportPollingTask createPollingTaskForService(\n", 
            "+            AxisService service,\n", 
            "+            ScheduledExecutorService pool,\n", 
            "+            AMQPTransportEndpoint endpoint,\n", 
            "+            AMQPTransportConnectionFactory connectionFactory) throws AxisFault {\n", 
            "+\n", 
            "+        Map<String, String> svcParam =\n", 
            "+                AMQPTransportUtils.getServiceStringParameters(service.getParameters());\n", 
            "+        Map<String, String> conFacParam = connectionFactory.getParameters();\n", 
            "+\n", 
            "+\n", 
            "+        AMQPTransportPollingTask pt = new AMQPTransportPollingTask();\n", 
            "+\n", 
            "+        pt.setServiceName(service.getName());\n", 
            "+        pt.setEndpoint(endpoint);\n", 
            "+        pt.setPollingTaskScheduler(pool);\n", 
            "+\n", 
            "+        // set buffers to hold request/response messages for this task\n", 
            "+        pt.setBuffers(new AMQPTransportBuffers());\n", 
            "+\n", 
            "+        String exchangeName = AMQPTransportUtils.getOptionalStringParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_EXCHANGE_NAME, svcParam, conFacParam);\n", 
            "+        pt.setExchangeName(exchangeName);\n", 
            "+\n", 
            "+        Boolean isDurable = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_EXCHANGE_IS_DURABLE, svcParam, conFacParam);\n", 
            "+        if (isDurable != null) {\n", 
            "+            pt.setExchangeDurable(isDurable);\n", 
            "+        }\n", 
            "+\n", 
            "+        Boolean isAutoDelete = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_EXCHANGE_IS_AUTO_DELETE, svcParam, conFacParam);\n", 
            "+        if (isAutoDelete != null) {\n", 
            "+            pt.setExchangeAutoDelete(isAutoDelete);\n", 
            "+        }\n", 
            "+\n", 
            "+        String exchangeType = AMQPTransportUtils.getOptionalStringParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_EXCHANGE_TYPE, svcParam, conFacParam);\n", 
            "+        if (exchangeType != null) {\n", 
            "+            if (exchangeName == null) {\n", 
            "+                throw new AxisFault(\"Possible configuration error. No exchange name provided but \" +\n", 
            "+                        \"exchange type is set to '\" + exchangeType + \"'\");\n", 
            "+            }\n", 
            "+\n", 
            "+            pt.setExchangeType(exchangeType);\n", 
            "+        }\n", 
            "+\n", 
            "+        Boolean isInternalExchange = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_EXCHANGE_INTERNAL, svcParam, conFacParam);\n", 
            "+        if (isInternalExchange != null) {\n", 
            "+            if (exchangeName == null) {\n", 
            "+                throw new AxisFault(\"Possible configuration error. No exchange name provided but \" +\n", 
            "+                        \"exchange restricted as \" + (isInternalExchange ? \"internal.\" : \"external.\"));\n", 
            "+            }\n", 
            "+            pt.setInternalExchange(isInternalExchange);\n", 
            "+        }\n", 
            "+\n", 
            "+\n", 
            "+        pt.setChannel(connectionFactory.getChannel());\n", 
            "+        pt.setConnectionFactoryName(connectionFactory.getName());\n", 
            "+\n", 
            "+        String responseConFac = AMQPTransportUtils.getOptionalStringParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_RESPONSE_CONNECTION_FACTORY_NAME, svcParam, conFacParam);\n", 
            "+        if (responseConFac != null) {\n", 
            "+            pt.setResponseConnectionFactory(responseConFac);\n", 
            "+        }\n", 
            "+\n", 
            "+        String consumerExchange = AMQPTransportUtils.getOptionalStringParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_BIND_EXCHANGE, svcParam, conFacParam);\n", 
            "+        if (consumerExchange != null) {\n", 
            "+            if (exchangeName != null && !consumerExchange.equals(exchangeName)) {\n", 
            "+                log.warn(\"Possible configuration error? Exchange name is set to '\" +\n", 
            "+                        exchangeName + \"' and consumer's exchange name is set to '\" +\n", 
            "+                        consumerExchange + \"'\");\n", 
            "+            }\n", 
            "+            pt.setConsumerExchangeName(consumerExchange);\n", 
            "+        }\n", 
            "+\n", 
            "+        String bindingKeyString = AMQPTransportUtils.getOptionalStringParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_BINDING_KEYS, svcParam, conFacParam);\n", 
            "+\n", 
            "+        if (bindingKeyString != null) {\n", 
            "+            pt.setBindingsKeys(AMQPTransportUtils.split(\n", 
            "+                    bindingKeyString, AMQPTransportConstant.ROUTING_KEY_DELIMITER));\n", 
            "+        }\n", 
            "+\n", 
            "+        String queueName = AMQPTransportUtils.getOptionalStringParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_QUEUE_NAME, svcParam, conFacParam);\n", 
            "+        if (queueName == null) {\n", 
            "+            queueName = service.getName(); // set the service name as the queue name for default.\n", 
            "+        }\n", 
            "+        pt.setQueueName(queueName);\n", 
            "+\n", 
            "+        String configuredContentType = AMQPTransportUtils.getOptionalStringParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_CONFIGURED_CONTENT_TYPE, svcParam, conFacParam);\n", 
            "+        if (configuredContentType != null) {\n", 
            "+            pt.setConfiguredContentType(configuredContentType);\n", 
            "+        }\n", 
            "+\n", 
            "+        Boolean isQueueDurable = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_QUEUE_DURABLE, svcParam, conFacParam);\n", 
            "+        if (isDurable != null) {\n", 
            "+            pt.setQueueDurable(isQueueDurable);\n", 
            "+        }\n", 
            "+\n", 
            "+        Boolean isQueueRestricted = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_QUEUE_RESTRICTED, svcParam, conFacParam);\n", 
            "+        if (isQueueRestricted != null) {\n", 
            "+            pt.setQueueRestricted(isQueueRestricted);\n", 
            "+        }\n", 
            "+\n", 
            "+        Boolean isQueueAutoDelete = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_QUEUE_AUTO_DELETE, svcParam, conFacParam);\n", 
            "+        if (isQueueAutoDelete != null) {\n", 
            "+            pt.setQueueAutoDelete(isQueueAutoDelete);\n", 
            "+        }\n", 
            "+\n", 
            "+        Boolean isBlockingMode = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_OPERATE_ON_BLOCKING_MODE, svcParam, conFacParam);\n", 
            "+        if (isBlockingMode != null) {\n", 
            "+            pt.setBlockingMode(isBlockingMode);\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            Integer noOfConsumers = AMQPTransportUtils.getOptionalIntParameter(\n", 
            "+                    AMQPTransportConstant.PARAMETER_NO_OF_CONCURRENT_CONSUMERS, svcParam, conFacParam);\n", 
            "+            if (noOfConsumers != null) {\n", 
            "+                pt.setNoOfConcurrentConsumers(noOfConsumers);\n", 
            "+            }\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            throw new AxisFault(\"Could not assign the number of concurrent consumers\", e);\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            Integer initialReconectionDuration = AMQPTransportUtils.getOptionalIntParameter(\n", 
            "+                    AMQPTransportConstant.PARAMETER_INITIAL_RE_CONNECTION_DURATION, svcParam, conFacParam);\n", 
            "+            if (initialReconectionDuration != null) {\n", 
            "+                pt.setInitialReconnectDuration(initialReconectionDuration);\n", 
            "+            }\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            throw new AxisFault(\"Could not assign the initial re-connection duration\", e);\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            Integer reconnectionFactor = AMQPTransportUtils.getOptionalIntParameter(\n", 
            "+                    AMQPTransportConstant.PARAMETER_RE_CONNECTION_PROGRESSION_FACTOR, svcParam, conFacParam);\n", 
            "+            if (reconnectionFactor != null) {\n", 
            "+                pt.setReconnectionFactor(reconnectionFactor);\n", 
            "+            }\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            throw new AxisFault(\"Could not assign reconnection factor\", e);\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            Integer dispatchingTask = AMQPTransportUtils.getOptionalIntParameter(\n", 
            "+                    AMQPTransportConstant.PARAMETER_DISPATCHING_TASK_SIZE, svcParam, conFacParam);\n", 
            "+            if (dispatchingTask != null) {\n", 
            "+                pt.setNoOfDispatchingTask(dispatchingTask);\n", 
            "+            }\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            throw new AxisFault(\"Could not assign number of dispatching task value\", e);\n", 
            "+        }\n", 
            "+\n", 
            "+        Boolean isUseTx = AMQPTransportUtils.getOptionalBooleanParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_CONSUMER_TX, svcParam, conFacParam);\n", 
            "+        if (isUseTx != null) {\n", 
            "+            pt.setUseTx(isUseTx);\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            Integer initialDelay = AMQPTransportUtils.getOptionalIntParameter(\n", 
            "+                    AMQPTransportConstant.PARAMETER_SCHEDULED_TASK_INITIAL_DELAY, svcParam, conFacParam);\n", 
            "+            if (initialDelay != null) {\n", 
            "+                pt.setScheduledTaskInitialDelay(initialDelay.intValue());\n", 
            "+            }\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            throw new AxisFault(\"Could not assign the scheduled task initial delay value\", e);\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            Integer delay = AMQPTransportUtils.getOptionalIntParameter(\n", 
            "+                    AMQPTransportConstant.PARAMETER_SCHEDULED_TASK_INITIAL_DELAY, svcParam, conFacParam);\n", 
            "+            if (delay != null) {\n", 
            "+                pt.setScheduledTaskDelay(delay.intValue());\n", 
            "+            }\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            throw new AxisFault(\"Could not assign the scheduled task delay value\", e);\n", 
            "+        }\n", 
            "+\n", 
            "+        String timeUnit = AMQPTransportUtils.getOptionalStringParameter(\n", 
            "+                AMQPTransportConstant.PARAMETER_SCHEDULED_TASK_TIME_UNIT, svcParam, conFacParam);\n", 
            "+\n", 
            "+        if (timeUnit != null) {\n", 
            "+            pt.setScheduledTaskTimeUnit(getTimeUnit(timeUnit));\n", 
            "+        }\n", 
            "+\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"A polling task for the service '\" + service.getName() + \"' was produced with \" +\n", 
            "+                    \"following parameters.\\n\" +\n", 
            "+                    \"Exchange Name: '\" + pt.getExchangeName() + \"'\\n\" +\n", 
            "+                    \"Exchange Type: '\" + pt.getExchangeType() + \"'\\n\" +\n", 
            "+                    \"Exchange Durable?: '\" + pt.isExchangeDurable() + \"'\\n\" +\n", 
            "+                    \"Exchange AutoDelete?: '\" + pt.isExchangeAutoDelete() + \"\\n\" +\n", 
            "+                    \"Is internal exchange: '\" + pt.isInternalExchange() + \"'\\n\" +\n", 
            "+                    \"Consumer Exchange: \" + pt.getConsumerExchangeName() + \"'\\n\" +\n", 
            "+                    \"Routing Keys: '\" + bindingKeyString + \"'\\n\" +\n", 
            "+                    \"QueueName: '\" + pt.getQueueName() + \"'\\n\" +\n", 
            "+                    \"Is queue durable: '\" + pt.isQueueDurable() + \"'\\n\" +\n", 
            "+                    \"Is queue restricted: '\" + pt.isQueueRestricted() + \"'\\n\" +\n", 
            "+                    \"Is queue auto deleted: '\" + pt.isQueueAutoDelete() + \"'\\n\" +\n", 
            "+                    \"Is blocking mode: '\" + pt.isBlockingMode() + \"'\\n\" +\n", 
            "+                    \"Initial re-connection duration: '\" + pt.getInitialReconnectDuration() + \"(ms)'\\n\" +\n", 
            "+                    \"Re-connection progression factor: '\" + pt.getReconnectionFactor() + \"'\\n\" +\n", 
            "+                    \"Maximum re-connection duration: '\" + pt.getMaxReconnectionDuration() + \"'\\n\" +\n", 
            "+                    \"Number of concurrent consumers: '\" + pt.getNoOfConcurrentConsumers() + \"'\\n\" +\n", 
            "+                    \"Number of dispatching task: '\" + pt.getNoOfDispatchingTask() + \"'\");\n", 
            "+        }\n", 
            "+\n", 
            "+        return pt;\n", 
            "+    }\n", 
            "+\n", 
            "+    private static TimeUnit getTimeUnit(String timeUnit) {\n", 
            "+\n", 
            "+        if (\"days\".equals(timeUnit)) {\n", 
            "+            return TimeUnit.DAYS;\n", 
            "+        } else if (\"hours\".equals(timeUnit)) {\n", 
            "+            return TimeUnit.HOURS;\n", 
            "+        } else if (\"minutes\".equals(timeUnit)) {\n", 
            "+            return TimeUnit.MINUTES;\n", 
            "+        } else if (\"seconds\".equals(timeUnit)) {\n", 
            "+            return TimeUnit.SECONDS;\n", 
            "+        } else if (\"milliseconds\".equals(timeUnit)) {\n", 
            "+            return TimeUnit.MILLISECONDS;\n", 
            "+        } else {\n", 
            "+            return TimeUnit.MICROSECONDS;\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPTransportPollingTaskFactory.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPTransportPollingTaskFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,101", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp;\n", 
            "+\n", 
            "+import org.apache.axis2.AxisFault;\n", 
            "+\n", 
            "+import java.util.ArrayList;\n", 
            "+import java.util.List;\n", 
            "+import java.util.concurrent.BlockingQueue;\n", 
            "+import java.util.concurrent.LinkedBlockingQueue;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Keeps the request/response messages until pick by the processing/response dispatching tasks.\n", 
            "+ * These buffers(an instance of\n", 
            "+ * http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/BlockingQueue.html) are used in\n", 
            "+ * order to define an asynchronous architecture between the polling tak and actual processing which\n", 
            "+ * will lead to higher performance.\n", 
            "+ */\n", 
            "+public class AMQPTransportBuffers {\n", 
            "+    /**\n", 
            "+     * The request message buffer which holds the request messages\n", 
            "+     */\n", 
            "+    private BlockingQueue<AMQPTransportMessage> requestBuffer =\n", 
            "+            new LinkedBlockingQueue<AMQPTransportMessage>();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The response message buffer which holds the responses for processed messages\n", 
            "+     */\n", 
            "+    private BlockingQueue<AMQPTransportMessage> responseBuffer =\n", 
            "+            new LinkedBlockingQueue<AMQPTransportMessage>();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the response messages as a list\n", 
            "+     *\n", 
            "+     * @param blockSize the block blockSize of the response message list\n", 
            "+     * @return the block of the response messages of blockSize\n", 
            "+     * @throws AMQPTransportException in case of an error\n", 
            "+     */\n", 
            "+    public List<AMQPTransportMessage> getResponseMessageList(final int blockSize) throws AMQPTransportException {\n", 
            "+        List<AMQPTransportMessage> msgList = new ArrayList<AMQPTransportMessage>();\n", 
            "+        if (responseBuffer.size() > 0) {\n", 
            "+            AMQPTransportUtils.moveElements(responseBuffer, msgList, blockSize);\n", 
            "+        }\n", 
            "+        return msgList;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Add a response message to the response buffer\n", 
            "+     *\n", 
            "+     * @param msg the response message\n", 
            "+     * @throws InterruptedException throws in case of an error\n", 
            "+     */\n", 
            "+    public void addResponseMessage(AMQPTransportMessage msg) throws InterruptedException {\n", 
            "+        // it's ok to block here until space available,\n", 
            "+        responseBuffer.put(msg);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns the request message buffer in transport\n", 
            "+     *\n", 
            "+     * @return the request message buffer\n", 
            "+     */\n", 
            "+    public BlockingQueue<AMQPTransportMessage> getRequestMessageBuffer() {\n", 
            "+        return requestBuffer;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Add a message to the request message buffer\n", 
            "+     *\n", 
            "+     * @param msg the message to add into the buffer\n", 
            "+     */\n", 
            "+    public void addRequestMessage(AMQPTransportMessage msg) {\n", 
            "+        requestBuffer.add(msg);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Returns a request message from the request message buffer\n", 
            "+     *\n", 
            "+     * @return the request message\n", 
            "+     */\n", 
            "+    public AMQPTransportMessage getRequestMessage() {\n", 
            "+        try {\n", 
            "+            // block if there is no messages\n", 
            "+            return requestBuffer.take();\n", 
            "+        } catch (InterruptedException e) {\n", 
            "+            // ignore\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+}\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportBuffers.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportBuffers.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,32", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Defines an exception class for AMQP transport\n", 
            "+ */\n", 
            "+public class AMQPTransportException extends Exception {\n", 
            "+\n", 
            "+    public AMQPTransportException(final String message) {\n", 
            "+        super(message);\n", 
            "+    }\n", 
            "+\n", 
            "+    public AMQPTransportException(final String message, Throwable t) {\n", 
            "+        super(message, t);\n", 
            "+    }\n", 
            "+\n", 
            "+    public AMQPTransportException(Throwable t) {\n", 
            "+        super(t);\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportException.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportException.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,69", 
          "lines": [
            "+/*\n", 
            "+ * ====================================================================\n", 
            "+ * Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ * or more contributor license agreements.  See the NOTICE file\n", 
            "+ * distributed with this work for additional information\n", 
            "+ * regarding copyright ownership.  The ASF licenses this file\n", 
            "+ * to you under the Apache License, Version 2.0 (the\n", 
            "+ * \"License\"); you may not use this file except in compliance\n", 
            "+ * with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing,\n", 
            "+ * software distributed under the License is distributed on an\n", 
            "+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ * KIND, either express or implied.  See the License for the\n", 
            "+ * specific language governing permissions and limitations\n", 
            "+ * under the License.\n", 
            "+ * ====================================================================\n", 
            "+ *\n", 
            "+ * This software consists of voluntary contributions made by many\n", 
            "+ * individuals on behalf of the Apache Software Foundation.  For more\n", 
            "+ * information on the Apache Software Foundation, please see\n", 
            "+ * <http://www.apache.org/>.\n", 
            "+ *\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp.tx;\n", 
            "+\n", 
            "+import com.rabbitmq.client.Channel;\n", 
            "+\n", 
            "+import java.io.IOException;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Wrap the normal transaction API and the light weight publisher confirm apis'.\n", 
            "+ * See http://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/,\n", 
            "+ *\n", 
            "+ */\n", 
            "+public class AMQPTransportProducerTx {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Use light weight publisher confirm to handle transaction ? Default is\n", 
            "+     * set to true for high performance\n", 
            "+     */\n", 
            "+    private boolean isLightWeightPublisherConfirm = true;\n", 
            "+\n", 
            "+    private Channel channel;\n", 
            "+\n", 
            "+    public AMQPTransportProducerTx(boolean lightWeightPublisherConfirm,\n", 
            "+                                   Channel channel) {\n", 
            "+        isLightWeightPublisherConfirm = lightWeightPublisherConfirm;\n", 
            "+        this.channel = channel;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void start() throws IOException {\n", 
            "+        if (isLightWeightPublisherConfirm) {\n", 
            "+            channel.confirmSelect();\n", 
            "+        } else {\n", 
            "+            channel.txSelect();\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public void end() throws InterruptedException, IOException {\n", 
            "+        if (isLightWeightPublisherConfirm) {\n", 
            "+            channel.waitForConfirms();\n", 
            "+        } else {\n", 
            "+            channel.txCommit();\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/tx/AMQPTransportProducerTx.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/tx/AMQPTransportProducerTx.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,93", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp;\n", 
            "+\n", 
            "+import org.apache.axis2.AxisFault;\n", 
            "+import org.apache.axis2.addressing.EndpointReference;\n", 
            "+import org.apache.axis2.description.AxisService;\n", 
            "+import org.apache.axis2.description.ParameterInclude;\n", 
            "+import org.apache.axis2.transport.base.ProtocolEndpoint;\n", 
            "+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactory;\n", 
            "+import org.apache.synapse.transport.amqp.pollingtask.AMQPTransportPollingTask;\n", 
            "+import org.apache.synapse.transport.amqp.pollingtask.AMQPTransportPollingTaskFactory;\n", 
            "+\n", 
            "+import java.util.HashSet;\n", 
            "+import java.util.Set;\n", 
            "+import java.util.concurrent.ExecutorService;\n", 
            "+import java.util.concurrent.ScheduledExecutorService;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Represent and endpoint in AMQP transport implementation.\n", 
            "+ */\n", 
            "+public class AMQPTransportEndpoint extends ProtocolEndpoint {\n", 
            "+\n", 
            "+    private Set<EndpointReference> endpointReferences = new HashSet<EndpointReference>();\n", 
            "+\n", 
            "+    private ScheduledExecutorService workerPool;\n", 
            "+\n", 
            "+    private AMQPTransportPollingTask pollingTask;\n", 
            "+\n", 
            "+    private AMQPTransportListener transportReceiver;\n", 
            "+\n", 
            "+    public AMQPTransportEndpoint(ScheduledExecutorService workerPool,\n", 
            "+                                 AMQPTransportListener receiver) {\n", 
            "+        this.workerPool = workerPool;\n", 
            "+        this.transportReceiver = receiver;\n", 
            "+    }\n", 
            "+\n", 
            "+    public AMQPTransportPollingTask getPollingTask() {\n", 
            "+        return pollingTask;\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public boolean loadConfiguration(ParameterInclude params) throws AxisFault {\n", 
            "+        if (!(params instanceof AxisService)) {\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+        try {\n", 
            "+            AxisService service = (AxisService) params;\n", 
            "+\n", 
            "+            String conFacName;\n", 
            "+            if (service.getParameter(AMQPTransportConstant.PARAMETER_CONNECTION_FACTORY_NAME) != null) {\n", 
            "+                conFacName = (String) service.getParameter(\n", 
            "+                        AMQPTransportConstant.PARAMETER_CONNECTION_FACTORY_NAME).getValue();\n", 
            "+\n", 
            "+            } else {\n", 
            "+                conFacName = AMQPTransportConstant.DEFAULT_CONNECTION_FACTORY_NAME;\n", 
            "+            }\n", 
            "+\n", 
            "+            AMQPTransportConnectionFactory conFac =\n", 
            "+                    transportReceiver.getConnectionFactory(conFacName);\n", 
            "+            if (conFac == null) {\n", 
            "+                throw new AxisFault(\"No connection factory definition found\");\n", 
            "+            }\n", 
            "+\n", 
            "+            pollingTask = AMQPTransportPollingTaskFactory.createPollingTaskForService(\n", 
            "+                    service,\n", 
            "+                    workerPool,\n", 
            "+                    this,\n", 
            "+                    conFac);\n", 
            "+\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            throw new AxisFault(\"Could not load the AMQP endpoint configuration, \" + e.getMessage(), e);\n", 
            "+        }\n", 
            "+        return true;\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public EndpointReference[] getEndpointReferences(AxisService service, String ip)\n", 
            "+            throws AxisFault {\n", 
            "+        return endpointReferences.toArray(new EndpointReference[endpointReferences.size()]);\n", 
            "+    }\n", 
            "+}\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportEndpoint.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportEndpoint.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,343", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp;\n", 
            "+\n", 
            "+import org.apache.axiom.soap.SOAPEnvelope;\n", 
            "+import org.apache.axis2.AxisFault;\n", 
            "+import org.apache.axis2.Constants;\n", 
            "+import org.apache.axis2.builder.Builder;\n", 
            "+import org.apache.axis2.builder.BuilderUtil;\n", 
            "+import org.apache.axis2.context.ConfigurationContext;\n", 
            "+import org.apache.axis2.context.MessageContext;\n", 
            "+import org.apache.axis2.description.Parameter;\n", 
            "+import org.apache.axis2.description.TransportOutDescription;\n", 
            "+import org.apache.axis2.description.WSDL2Constants;\n", 
            "+import org.apache.axis2.engine.AxisEngine;\n", 
            "+import org.apache.axis2.transport.OutTransportInfo;\n", 
            "+import org.apache.axis2.transport.base.AbstractTransportSender;\n", 
            "+import org.apache.axis2.util.MessageContextBuilder;\n", 
            "+import org.apache.http.protocol.HTTP;\n", 
            "+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactoryManager;\n", 
            "+import org.apache.synapse.transport.amqp.pollingtask.AMQPSimpleConsumerTask;\n", 
            "+import org.apache.synapse.transport.amqp.sendertask.AMQPSender;\n", 
            "+import org.apache.synapse.transport.amqp.sendertask.AMQPSenderCache;\n", 
            "+import org.apache.synapse.transport.amqp.sendertask.AMQPSenderFactory;\n", 
            "+import org.apache.synapse.transport.amqp.tx.AMQPTransportProducerTx;\n", 
            "+\n", 
            "+import java.io.ByteArrayInputStream;\n", 
            "+import java.io.IOException;\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.UUID;\n", 
            "+import java.util.concurrent.*;\n", 
            "+\n", 
            "+/**\n", 
            "+ * The transport sender implementation for AMQP transport. A message can end up here as\n", 
            "+ * part of directly calling an AMQP endpoint or sending a response to a two way request message.\n", 
            "+ */\n", 
            "+public class AMQPTransportSender extends AbstractTransportSender {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * The connection factory definitions defined in axis2.xml for transport sender section\n", 
            "+     */\n", 
            "+    private AMQPTransportConnectionFactoryManager connectionFactoryManager;\n", 
            "+\n", 
            "+    private ExecutorService connectionFactoryES;\n", 
            "+\n", 
            "+    private AMQPSenderCache cache;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Keep tracks of the responses for two in/out messages\n", 
            "+     */\n", 
            "+    private Map<String, Semaphore> responseTracker;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Store the response messages for in/out messages until further process\n", 
            "+     */\n", 
            "+    private Map<String, AMQPTransportMessage> responseMessage;\n", 
            "+\n", 
            "+    private ExecutorService responseHandlingPool;\n", 
            "+\n", 
            "+    private long semaphoreTimeOut;\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public void init(ConfigurationContext cfgCtx, TransportOutDescription transportOut)\n", 
            "+            throws AxisFault {\n", 
            "+        super.init(cfgCtx, transportOut);\n", 
            "+\n", 
            "+        connectionFactoryES = Executors.newFixedThreadPool(AMQPTransportUtils.getIntProperty(\n", 
            "+                AMQPTransportConstant.PARAM_CONNECTION_FACTORY_POOL_SIZE,\n", 
            "+                AMQPTransportConstant.CONNECTION_FACTORY_POOL_DEFAULT));\n", 
            "+\n", 
            "+        responseHandlingPool = Executors.newFixedThreadPool(AMQPTransportUtils.getIntProperty(\n", 
            "+                AMQPTransportConstant.PARAM_RESPONSE_HANDLING_POOL_SIZE,\n", 
            "+                AMQPTransportConstant.RESPONSE_HANDLING_POOL_DEFAULT));\n", 
            "+\n", 
            "+        connectionFactoryManager = new AMQPTransportConnectionFactoryManager();\n", 
            "+        connectionFactoryManager.addConnectionFactories(transportOut, connectionFactoryES);\n", 
            "+\n", 
            "+        semaphoreTimeOut = AMQPTransportUtils.getLongProperty(\n", 
            "+                AMQPTransportConstant.PARAM_SEMAPHORE_TIME_OUT, 86400L);\n", 
            "+\n", 
            "+        cache = new AMQPSenderCache(new ConcurrentHashMap<Integer, AMQPSender>());\n", 
            "+        responseTracker = new ConcurrentHashMap<String, Semaphore>();\n", 
            "+        responseMessage = new ConcurrentHashMap<String, AMQPTransportMessage>();\n", 
            "+//        MBeanRegister.getInstance().registerMBean(\n", 
            "+//                new TransportView(null, this), \"Transport\", \"amqp-tx-receiver\");\n", 
            "+\n", 
            "+        log.info(\"AMQP transport sender initializing..\");\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public void stop() {\n", 
            "+        super.stop();\n", 
            "+        try {\n", 
            "+            connectionFactoryManager.shutDownConnectionFactories();\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            log.error(\"Error while shutting down connection factories, continue anyway...\", e);\n", 
            "+        }\n", 
            "+        cache.clean();\n", 
            "+        responseTracker.clear();\n", 
            "+        responseMessage.clear();\n", 
            "+        connectionFactoryES.shutdown();\n", 
            "+        responseHandlingPool.shutdown();\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public void sendMessage(MessageContext msgCtx,\n", 
            "+                            String targetEPR,\n", 
            "+                            OutTransportInfo outTransportInfo) throws AxisFault {\n", 
            "+\n", 
            "+        AMQPSender amqpSender;\n", 
            "+        Integer hashKey = null;\n", 
            "+        Map<String, String> params = null;\n", 
            "+        String replyTo = null;\n", 
            "+        AMQPTransportProducerTx tx;\n", 
            "+        MessageContext replyMsgCtx = msgCtx.getOperationContext().getMessageContext(\n", 
            "+                WSDL2Constants.MESSAGE_LABEL_IN);\n", 
            "+        if (replyMsgCtx != null) {\n", 
            "+            replyTo = (String) replyMsgCtx.getProperty(AMQPTransportConstant.PROPERTY_AMQP_REPLY_TO);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (replyTo != null) {\n", 
            "+            // this is a response for a request message(request/response semantic message)\n", 
            "+            hashKey = replyTo.hashCode();\n", 
            "+            params = new HashMap<String, String>();\n", 
            "+            params.put(AMQPTransportConstant.PARAMETER_QUEUE_NAME, replyTo);\n", 
            "+\n", 
            "+            String conFacName = (String) msgCtx.getOperationContext().\n", 
            "+                    getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN).\n", 
            "+                    getProperty(AMQPTransportConstant.RESPONSE_CONNECTION_FACTORY_NAME);\n", 
            "+            if (conFacName == null) {\n", 
            "+                throw new AxisFault(\"A message was received with 'reply to' set. But no reply \" +\n", 
            "+                        \"connection factory name found. Define the parameter '\" +\n", 
            "+                        AMQPTransportConstant.PARAMETER_RESPONSE_CONNECTION_FACTORY_NAME +\n", 
            "+                        \"' as a service parameter. This response message will be dropped!\");\n", 
            "+            } else {\n", 
            "+                params.put(AMQPTransportConstant.PARAMETER_CONNECTION_FACTORY_NAME, conFacName);\n", 
            "+            }\n", 
            "+        } else {\n", 
            "+            // this is a normal one way out message\n", 
            "+            if (targetEPR != null) {\n", 
            "+                hashKey = new Integer(targetEPR.hashCode());\n", 
            "+                try {\n", 
            "+                    params = AMQPTransportUtils.parseAMQPUri(targetEPR);\n", 
            "+                } catch (AMQPTransportException e) {\n", 
            "+                    throw new AxisFault(\"Error while parsing the AMQP epr '\" + targetEPR + \"'\", e);\n", 
            "+                }\n", 
            "+            } else if (outTransportInfo != null && outTransportInfo instanceof AMQPOutTransportInfo) {\n", 
            "+                AMQPOutTransportInfo info = (AMQPOutTransportInfo) outTransportInfo;\n", 
            "+                params = info.getParams();\n", 
            "+\n", 
            "+            } else {\n", 
            "+                throw new AxisFault(\"Could not determine the endpoint information to deliver the message\");\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        if (cache.hit(hashKey)) {\n", 
            "+            amqpSender = cache.get(hashKey);\n", 
            "+        } else {\n", 
            "+            try {\n", 
            "+                amqpSender = AMQPSenderFactory.createAMQPSender(connectionFactoryManager, params);\n", 
            "+                cache.add(hashKey, amqpSender);\n", 
            "+            } catch (IOException e) {\n", 
            "+                throw new AxisFault(\"Could not create the AMQP sender\", e);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            String correlationId = (String)\n", 
            "+                    msgCtx.getProperty(AMQPTransportConstant.PROPERTY_AMQP_CORRELATION_ID);\n", 
            "+            if (correlationId == null) {\n", 
            "+                correlationId = msgCtx.getMessageID();\n", 
            "+            }\n", 
            "+\n", 
            "+            boolean isInOut = waitForSynchronousResponse(msgCtx);\n", 
            "+            Semaphore available = null;\n", 
            "+            if (isInOut) {\n", 
            "+                replyTo = (String) msgCtx.getProperty(\n", 
            "+                        AMQPTransportConstant.PROPERTY_AMQP_REPLY_TO);\n", 
            "+                if (replyTo == null) {\n", 
            "+                    replyTo = UUID.randomUUID().toString();\n", 
            "+                }\n", 
            "+                available = new Semaphore(0, true);\n", 
            "+                responseTracker.put(correlationId, available);\n", 
            "+            }\n", 
            "+\n", 
            "+            String useTx = (String) msgCtx.getProperty(AMQPTransportConstant.PROPERTY_PRODUCER_TX);\n", 
            "+\n", 
            "+            if (AMQPTransportConstant.AMQP_USE_LWPC.equals(useTx)) {\n", 
            "+                tx = new AMQPTransportProducerTx(true, amqpSender.getChannel());\n", 
            "+            } else if (AMQPTransportConstant.AMQP_USE_TX.equals(useTx)) {\n", 
            "+                tx = new AMQPTransportProducerTx(false, amqpSender.getChannel());\n", 
            "+            } else {\n", 
            "+                tx = null;\n", 
            "+            }\n", 
            "+\n", 
            "+            if (tx != null) {\n", 
            "+                try {\n", 
            "+                    tx.start();\n", 
            "+                } catch (IOException e) {\n", 
            "+                    throw new AxisFault(\"Error while initiation tx for message '\" +\n", 
            "+                            msgCtx.getMessageID() + \"'\", e);\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+            amqpSender.sendAMQPMessage(msgCtx, correlationId, replyTo);\n", 
            "+\n", 
            "+            if (tx != null) {\n", 
            "+                try {\n", 
            "+                    tx.end();\n", 
            "+                } catch (IOException e) {\n", 
            "+                    throw new AxisFault(\"Error while terminating tx for message '\" +\n", 
            "+                            msgCtx.getMessageID() + \"'\", e);\n", 
            "+                } catch (InterruptedException e) {\n", 
            "+                    log.error(\"Error while terminating tx for message '\" +\n", 
            "+                            msgCtx.getMessageID() + \"'\", e);\n", 
            "+                    Thread.currentThread().interrupt();\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+            if (isInOut) {\n", 
            "+                // block and process the response\n", 
            "+                new AMQPSimpleConsumerTask(\n", 
            "+                        responseHandlingPool,\n", 
            "+                        amqpSender.getChannel(),\n", 
            "+                        replyTo,\n", 
            "+                        responseTracker,\n", 
            "+                        responseMessage).\n", 
            "+                        consume();\n", 
            "+                try {\n", 
            "+                    available.tryAcquire(semaphoreTimeOut, TimeUnit.SECONDS);\n", 
            "+                } catch (InterruptedException e) {\n", 
            "+                    Thread.currentThread().interrupt();\n", 
            "+                }\n", 
            "+\n", 
            "+                responseTracker.remove(correlationId);\n", 
            "+                AMQPTransportMessage msg = responseMessage.get(correlationId);\n", 
            "+                if (msg != null) {\n", 
            "+                    handleSyncResponse(msgCtx, msg, msg.getContentType());\n", 
            "+                } else {\n", 
            "+                    // we don't have a response yet, so send a fault to client\n", 
            "+                    log.warn(\"The semaphore with id '\" + correlationId + \"' was time out while \"\n", 
            "+                            + \"waiting for a response, sending a fault to client..\");\n", 
            "+                    sendFault(msgCtx,\n", 
            "+                            new Exception(\"Times out occurs while waiting for a response\"));\n", 
            "+                }\n", 
            "+            }\n", 
            "+        } catch (AMQPTransportException e) {\n", 
            "+            throw new AxisFault(\"Could not retrieve the connection factory information\", e);\n", 
            "+        } catch (IOException e) {\n", 
            "+            throw new AxisFault(\"Could not produce the message into the destination\", e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private void handleSyncResponse(\n", 
            "+            MessageContext requestMsgCtx,\n", 
            "+            AMQPTransportMessage message,\n", 
            "+            String requestContentType)\n", 
            "+            throws AxisFault {\n", 
            "+        try {\n", 
            "+            MessageContext responseMsgCtx = createResponseMessageContext(requestMsgCtx);\n", 
            "+            responseMsgCtx.setProperty(Constants.Configuration.MESSAGE_TYPE,\n", 
            "+                    requestMsgCtx.getProperty(Constants.Configuration.MESSAGE_TYPE));\n", 
            "+\n", 
            "+            responseMsgCtx.setProperty(Constants.Configuration.CONTENT_TYPE,\n", 
            "+                    requestMsgCtx.getProperty(Constants.Configuration.CONTENT_TYPE));\n", 
            "+\n", 
            "+            String contentType = message.getContentType();\n", 
            "+            if (contentType == null) {\n", 
            "+                contentType = inferContentType(requestContentType, responseMsgCtx);\n", 
            "+            }\n", 
            "+\n", 
            "+            ByteArrayInputStream inputStream = new ByteArrayInputStream(message.getBody());\n", 
            "+            Builder builder = BuilderUtil.getBuilderFromSelector(contentType, requestMsgCtx);\n", 
            "+            SOAPEnvelope envelope = (SOAPEnvelope) builder.processDocument(\n", 
            "+                    inputStream, contentType, responseMsgCtx);\n", 
            "+            responseMsgCtx.setEnvelope(envelope);\n", 
            "+\n", 
            "+            String charSetEnc = BuilderUtil.getCharSetEncoding(contentType);\n", 
            "+            if (charSetEnc == null) {\n", 
            "+                charSetEnc = MessageContext.DEFAULT_CHAR_SET_ENCODING;\n", 
            "+            }\n", 
            "+            responseMsgCtx.setProperty(\n", 
            "+                    Constants.Configuration.CHARACTER_SET_ENCODING,\n", 
            "+                    contentType.indexOf(HTTP.CHARSET_PARAM) > 0\n", 
            "+                            ? charSetEnc : MessageContext.DEFAULT_CHAR_SET_ENCODING);\n", 
            "+            responseMsgCtx.setProperty(\n", 
            "+                    MessageContext.TRANSPORT_HEADERS, message.getHeaders());\n", 
            "+\n", 
            "+            if (message.getSoapAction() != null) {\n", 
            "+                responseMsgCtx.setSoapAction(message.getSoapAction());\n", 
            "+            }\n", 
            "+            AxisEngine.receive(responseMsgCtx);\n", 
            "+\n", 
            "+        } catch (AxisFault axisFault) {\n", 
            "+            handleException(\"Could not handle the response message \", axisFault);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private void sendFault(MessageContext msgContext, Exception e) {\n", 
            "+        try {\n", 
            "+            MessageContext faultContext = MessageContextBuilder.createFaultMessageContext(\n", 
            "+                    msgContext, e);\n", 
            "+            faultContext.setProperty(\"ERROR_MESSAGE\", e.getMessage());\n", 
            "+            faultContext.setProperty(\"SENDING_FAULT\", Boolean.TRUE);\n", 
            "+            AxisEngine.sendFault(faultContext);\n", 
            "+        } catch (AxisFault axisFault) {\n", 
            "+            log.fatal(\"Could not create the fault message.\", axisFault);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private String inferContentType(String requestContentType, MessageContext responseMsgCtx) {\n", 
            "+        // Try to get the content type from the message context\n", 
            "+        Object cTypeProperty = responseMsgCtx.getProperty(Constants.Configuration.CONTENT_TYPE);\n", 
            "+        if (cTypeProperty != null) {\n", 
            "+            return cTypeProperty.toString();\n", 
            "+        }\n", 
            "+        // Try to get the content type from the axis configuration\n", 
            "+        Parameter cTypeParam = cfgCtx.getAxisConfiguration().getParameter(\n", 
            "+                Constants.Configuration.CONTENT_TYPE);\n", 
            "+        if (cTypeParam != null) {\n", 
            "+            return cTypeParam.getValue().toString();\n", 
            "+        }\n", 
            "+\n", 
            "+        if (requestContentType != null) {\n", 
            "+            return requestContentType;\n", 
            "+        }\n", 
            "+\n", 
            "+        // Unable to determine the content type - Return default value\n", 
            "+        return AMQPTransportConstant.DEFAULT_CONTENT_TYPE;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportSender.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportSender.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,288", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp;\n", 
            "+\n", 
            "+import com.rabbitmq.client.Address;\n", 
            "+import org.apache.axis2.description.Parameter;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+\n", 
            "+import java.io.File;\n", 
            "+import java.io.IOException;\n", 
            "+import java.io.InputStream;\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.List;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.Properties;\n", 
            "+import java.util.concurrent.BlockingQueue;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Contains some utility methods for the AMQP transport implementation\n", 
            "+ */\n", 
            "+public final class AMQPTransportUtils {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(AMQPTransportUtils.class);\n", 
            "+\n", 
            "+    private static Properties prop;\n", 
            "+\n", 
            "+    static {\n", 
            "+        prop = loadProperties(\"amqp-transport.properties\");\n", 
            "+    }\n", 
            "+\n", 
            "+    private static Properties loadProperties(String filePath) {\n", 
            "+        Properties properties = new Properties();\n", 
            "+        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n", 
            "+\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Loading a file '\" + filePath + \"' from classpath\");\n", 
            "+        }\n", 
            "+\n", 
            "+        InputStream in = cl.getResourceAsStream(filePath);\n", 
            "+        if (in == null) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Unable to load file  ' \" + filePath + \" '\");\n", 
            "+            }\n", 
            "+\n", 
            "+            filePath = \"repository/conf\" +\n", 
            "+                    File.separatorChar + filePath;\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Loading a file '\" + filePath + \"' from classpath\");\n", 
            "+            }\n", 
            "+\n", 
            "+            in = cl.getResourceAsStream(filePath);\n", 
            "+            if (in == null) {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Unable to load file  ' \" + filePath + \" '\");\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+        if (in != null) {\n", 
            "+            try {\n", 
            "+                properties.load(in);\n", 
            "+            } catch (IOException e) {\n", 
            "+                String msg = \"Error loading properties from a file at :\" + filePath;\n", 
            "+                log.error(msg, e);\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return properties;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Read the value of a string property.\n", 
            "+     *\n", 
            "+     * @param name name of the property.\n", 
            "+     * @param def  default value.\n", 
            "+     * @return the string value\n", 
            "+     * @throws NumberFormatException in case invalid property value.\n", 
            "+     */\n", 
            "+    public static String getStringProperty(String name, String def) throws NumberFormatException {\n", 
            "+        String val = System.getProperty(name);\n", 
            "+        return val == null ?\n", 
            "+                (prop.get(name) == null ? def : (String) prop.get(name)) :\n", 
            "+                val;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Read the value of a int property.\n", 
            "+     *\n", 
            "+     * @param name name of the property.\n", 
            "+     * @param def  default value if no value is found.\n", 
            "+     * @return the property value.\n", 
            "+     * @throws NumberFormatException in case of an invalid property value.\n", 
            "+     */\n", 
            "+    public static int getIntProperty(String name, int def) throws NumberFormatException {\n", 
            "+        String val = System.getProperty(name);\n", 
            "+        return val == null ?\n", 
            "+                (prop.get(name) == null ? def : Integer.parseInt((String) prop.get(name))) :\n", 
            "+                Integer.parseInt(val);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Read the value of a property of type long\n", 
            "+     *\n", 
            "+     * @param name name of the property\n", 
            "+     * @param def  value of the property\n", 
            "+     * @return value of property\n", 
            "+     * @throws NumberFormatException throws in case of an error.\n", 
            "+     */\n", 
            "+    public static long getLongProperty(String name, long def) throws NumberFormatException {\n", 
            "+        String val = System.getProperty(name);\n", 
            "+        return val == null ?\n", 
            "+                (prop.get(name) == null ? def : Long.parseLong((String) prop.get(name))) :\n", 
            "+                Long.parseLong(val);\n", 
            "+    }\n", 
            "+\n", 
            "+    public static double getDoubleProperty(String name, double def) throws NumberFormatException {\n", 
            "+        String val = System.getProperty(name);\n", 
            "+        return val == null ?\n", 
            "+                (prop.get(name) == null ? def : Double.parseDouble((String) prop.get(name))) :\n", 
            "+                Double.parseDouble(val);\n", 
            "+    }\n", 
            "+\n", 
            "+    public static Boolean getBooleanProperty(String name, boolean def) throws NumberFormatException {\n", 
            "+        String val = System.getProperty(name);\n", 
            "+        return val == null ?\n", 
            "+                (prop.get(name) == null ? def : Boolean.parseBoolean((String) prop.get(name))) :\n", 
            "+                Boolean.parseBoolean(val);\n", 
            "+    }\n", 
            "+\n", 
            "+    public static Map<String, String> getServiceStringParameters(List<Parameter> list) {\n", 
            "+        Map<String, String> map = new HashMap<String, String>();\n", 
            "+        for (Parameter p : list) {\n", 
            "+            if (p.getValue() instanceof String) {\n", 
            "+                map.put(p.getName(), (String) p.getValue());\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return map;\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getOptionalStringParameter(String key, Map<String, String> srcMap1,\n", 
            "+                                                    Map<String, String> srcMap2) {\n", 
            "+\n", 
            "+        String value = srcMap1.get(key);\n", 
            "+        if (value == null) {\n", 
            "+            value = srcMap2.get(key);\n", 
            "+        }\n", 
            "+        return value;\n", 
            "+    }\n", 
            "+\n", 
            "+    public static Boolean getOptionalBooleanParameter(String key, Map<String, String> srcMap1,\n", 
            "+                                                      Map<String, String> srcMap2) {\n", 
            "+        String value = srcMap1.get(key);\n", 
            "+        if (value == null) {\n", 
            "+            value = srcMap2.get(key);\n", 
            "+        }\n", 
            "+        if (value == null) {\n", 
            "+            return null;\n", 
            "+        } else {\n", 
            "+            return Boolean.valueOf(value);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public static Integer getOptionalIntParameter(String key,\n", 
            "+                                                  Map<String, String> srcMap1,\n", 
            "+                                                  Map<String, String> srcMap2)\n", 
            "+            throws AMQPTransportException {\n", 
            "+        String value = srcMap1.get(key);\n", 
            "+        if (value == null) {\n", 
            "+            value = srcMap2.get(key);\n", 
            "+        }\n", 
            "+        if (value != null) {\n", 
            "+            try {\n", 
            "+                return Integer.parseInt(value);\n", 
            "+            } catch (NumberFormatException e) {\n", 
            "+                throw new AMQPTransportException(\n", 
            "+                        \"Invalid value '\" + value + \"' for the key '\" + key + \"'\");\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    public static Double getOptionalDoubleParameter(String key,\n", 
            "+                                                    Map<String, String> srcMap1,\n", 
            "+                                                    Map<String, String> srcMap2)\n", 
            "+            throws AMQPTransportException {\n", 
            "+        String value = srcMap1.get(key);\n", 
            "+        if (value == null) {\n", 
            "+            value = srcMap2.get(key);\n", 
            "+        }\n", 
            "+        if (value != null) {\n", 
            "+            try {\n", 
            "+                return Double.parseDouble(value);\n", 
            "+            } catch (NumberFormatException e) {\n", 
            "+                throw new AMQPTransportException(\n", 
            "+                        \"Invalid value '\" + value + \"' for the key '\" + key + \"'\");\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String[] split(String src, final String delimiter) {\n", 
            "+        return src.split(delimiter);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Digest the address array in the form hostName1:portNumber1,hostName2:portNumber2,hostName3:portNumber3\n", 
            "+     *\n", 
            "+     * @param addressString Address array string\n", 
            "+     * @param regex         the first regex to split the string\n", 
            "+     * @param subRegex      the sub regex to split the string\n", 
            "+     * @return the address array\n", 
            "+     * @throws NumberFormatException in case an invalid port.\n", 
            "+     */\n", 
            "+    public static Address[] getAddressArray(String addressString,\n", 
            "+                                            final String regex,\n", 
            "+                                            final char subRegex) throws NumberFormatException {\n", 
            "+        String[] hosts = addressString.split(regex);\n", 
            "+        Address[] addresses = new Address[hosts.length];\n", 
            "+        for (int i = 0; i < hosts.length; i++) {\n", 
            "+            addresses[i] = new Address(\n", 
            "+                    hosts[i].substring(0, hosts[i].indexOf(subRegex)),\n", 
            "+                    Integer.parseInt(hosts[i].substring(hosts[i].indexOf(subRegex) + 1)));\n", 
            "+\n", 
            "+        }\n", 
            "+        return addresses;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Move elements between buffers. No need of additional synchronization locks,\n", 
            "+     * BlockingQueue#drainTo is thread safe, but not atomic, which is not a problem.\n", 
            "+     * See {@link BlockingQueue#drainTo(java.util.Collection, int)}\n", 
            "+     *\n", 
            "+     * @param src       source buffer\n", 
            "+     * @param dest      destination buffer\n", 
            "+     * @param blockSize blockSize of message bulk that need to move\n", 
            "+     * @throws AMQPTransportException in case of drains fails\n", 
            "+     */\n", 
            "+\n", 
            "+    public static void moveElements(BlockingQueue<AMQPTransportMessage> src,\n", 
            "+                                    List<AMQPTransportMessage> dest,\n", 
            "+                                    final int blockSize) throws AMQPTransportException {\n", 
            "+        try {\n", 
            "+            src.drainTo(dest, blockSize);\n", 
            "+        } catch (Exception e) {\n", 
            "+            throw new AMQPTransportException(e.getMessage(), e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public static Map<String, String> parseAMQPUri(String amqpUri) throws AMQPTransportException {\n", 
            "+        // amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer&amp;transport.amqp.QueueName=producer\n", 
            "+\n", 
            "+        // amqp epr has the following format\n", 
            "+        // amqp://[string]?key1=value1&key2=value2&key3=value*\n", 
            "+        // valid epr definitions\n", 
            "+        // amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer\n", 
            "+        // amqp://?transport.amqp.ConnectionFactoryName=producer&transport.amqp.QueueName=producer\n", 
            "+        // amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer&transport.amqp.QueueName=producer\n", 
            "+\n", 
            "+        // the parameter 'transport.amqp.QueueName' has high precedence over the value given between\n", 
            "+        // amqp:// and ?, if the parameter transport.amqp.QueueName is missing consider the value\n", 
            "+        // between amqp:// and ?, as the queue/exchange name\n", 
            "+\n", 
            "+        Map<String, String> params = new HashMap<String, String>();\n", 
            "+        String svcName = amqpUri.substring(7, amqpUri.indexOf('?'));\n", 
            "+        String kv = amqpUri.substring(amqpUri.indexOf('?') + 1);\n", 
            "+        String[] values = kv.split(\"&\");\n", 
            "+\n", 
            "+        for (String str : values) {\n", 
            "+            str  = str.trim();\n", 
            "+            params.put(str.substring(0, str.indexOf('=')), str.substring(str.indexOf('=') + 1));\n", 
            "+        }\n", 
            "+        if (!params.keySet().contains(AMQPTransportConstant.PARAMETER_QUEUE_NAME)) {\n", 
            "+            params.put(AMQPTransportConstant.PARAMETER_QUEUE_NAME, svcName);\n", 
            "+        }\n", 
            "+\n", 
            "+        return params;\n", 
            "+    }\n", 
            "+}\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportUtils.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportUtils.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,44", 
          "lines": [
            "+/*\n", 
            "+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n", 
            "+ * you may not use this file except in compliance with the License.\n", 
            "+ * You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ * http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ * Unless required by applicable law or agreed to in writing, software\n", 
            "+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n", 
            "+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", 
            "+ * See the License for the specific language governing permissions and\n", 
            "+ * limitations under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.transport.amqp;\n", 
            "+\n", 
            "+import org.apache.axis2.transport.OutTransportInfo;\n", 
            "+\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.Map;\n", 
            "+\n", 
            "+public class AMQPOutTransportInfo implements OutTransportInfo {\n", 
            "+\n", 
            "+    private String contentType;\n", 
            "+\n", 
            "+    private Map<String, String> params = new HashMap<String, String>();\n", 
            "+\n", 
            "+    public AMQPOutTransportInfo(String contentType, String connFacName, String queueName) {\n", 
            "+        this.contentType = contentType;\n", 
            "+        params.put(AMQPTransportConstant.PROPERTY_AMQP_REPLY_TO, queueName);\n", 
            "+        params.put(AMQPTransportConstant.RESPONSE_CONNECTION_FACTORY_NAME, connFacName);\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getContentType() {\n", 
            "+        return contentType;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setContentType(String contentType) {\n", 
            "+        this.contentType = contentType;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Map<String, String> getParams() {\n", 
            "+        return params;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPOutTransportInfo.java", 
      "from": "java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPOutTransportInfo.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,94", 
          "lines": [
            "+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n", 
            "+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n", 
            "+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n", 
            "+    <modelVersion>4.0.0</modelVersion>\n", 
            "+\n", 
            "+\t<parent>\n", 
            "+        <groupId>org.apache.synapse</groupId>\n", 
            "+        <artifactId>synapse-transports</artifactId>\n", 
            "+        <version>2.2.0-SNAPSHOT</version>\n", 
            "+        <relativePath>../../pom.xml</relativePath>\n", 
            "+    </parent>\n", 
            "+\n", 
            "+    <groupId>org.apache.synapse</groupId>\n", 
            "+    <artifactId>synapse-amqp-transport</artifactId>\n", 
            "+    <name>Apache Synapse - AMQP transport</name>\n", 
            "+    <packaging>bundle</packaging>\n", 
            "+    <url>http://maven.apache.org</url>\n", 
            "+\n", 
            "+    <properties>\n", 
            "+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n", 
            "+    </properties>\n", 
            "+\n", 
            "+\n", 
            "+\t<scm>\n", 
            "+        <connection>scm:svn:http://svn.apache.org/repos/asf/synapse/trunk/java/modules/transports/optional/amqp</connection>\n", 
            "+        <developerConnection>scm:svn:https://svn.apache.org/repos/asf/synapse/trunk/java/modules/transports/optional/amqp</developerConnection>\n", 
            "+        <url>http://svn.apache.org/viewvc/synapse/trunk/java/modules/transports/core/optional/amqp</url>\n", 
            "+    </scm>\n", 
            "+\n", 
            "+    <build>\n", 
            "+        <plugins>\n", 
            "+\n", 
            "+            <plugin>\n", 
            "+                <groupId>org.apache.maven.plugins</groupId>\n", 
            "+                <artifactId>maven-compiler-plugin</artifactId>\n", 
            "+                <version>2.3.2</version>\n", 
            "+                <configuration>\n", 
            "+                    <source>1.6</source>\n", 
            "+                    <target>1.6</target>\n", 
            "+                </configuration>\n", 
            "+            </plugin>\n", 
            "+\n", 
            "+            <plugin>\n", 
            "+                <groupId>org.apache.felix</groupId>\n", 
            "+                <artifactId>maven-bundle-plugin</artifactId>\n", 
            "+                <version>1.4.0</version>\n", 
            "+                <extensions>true</extensions>\n", 
            "+                <configuration>\n", 
            "+                    <instructions>\n", 
            "+                        <Bundle-SymbolicName>${project.artifactId}</Bundle-SymbolicName>\n", 
            "+                        <Bundle-Name>${project.artifactId}</Bundle-Name>\n", 
            "+                        <Private-Package></Private-Package>\n", 
            "+                        <Export-Package>org.apache.synapse.transport.amqp.*</Export-Package>\n", 
            "+                        <Import-Package>\n", 
            "+                            *;resolution:=optional\n", 
            "+                        </Import-Package>\n", 
            "+                        <DynamicImport-Package>*</DynamicImport-Package>\n", 
            "+                    </instructions>\n", 
            "+                </configuration>\n", 
            "+            </plugin>\n", 
            "+        </plugins>\n", 
            "+    </build>\n", 
            "+\n", 
            "+    <dependencies>\n", 
            "+        <dependency>\n", 
            "+            <groupId>junit</groupId>\n", 
            "+            <artifactId>junit</artifactId>\n", 
            "+            <version>3.8.1</version>\n", 
            "+            <scope>test</scope>\n", 
            "+        </dependency>\n", 
            "+        <dependency>\n", 
            "+            <groupId>com.rabbitmq</groupId>\n", 
            "+            <artifactId>amqp-client</artifactId>\n", 
            "+            <version>3.1.2</version>\n", 
            "+            <scope>compile</scope>\n", 
            "+            <!-- put a compile time dependency due to license -->\n", 
            "+        </dependency>\n", 
            "+        <dependency>\n", 
            "+            <groupId>org.apache.axis2</groupId>\n", 
            "+            <artifactId>axis2-transport-base</artifactId>\n", 
            "+            <version>${axis2.transport.version}</version>\n", 
            "+        </dependency>\n", 
            "+        <dependency>\n", 
            "+            <groupId>org.apache.axis2</groupId>\n", 
            "+            <artifactId>axis2-kernel</artifactId>\n", 
            "+            <version>${axis2.version}</version>\n", 
            "+        </dependency>\n", 
            "+        <dependency>\n", 
            "+            <groupId>org.apache.axis2</groupId>\n", 
            "+            <artifactId>axis2-transport-http</artifactId>\n", 
            "+            <version>${axis2.version}</version>\n", 
            "+        </dependency>\n", 
            "+    </dependencies>\n", 
            "+</project>\n"
          ]
        }
      ], 
      "to": "java/modules/transports/optional/amqp/pom.xml", 
      "from": "java/modules/transports/optional/amqp/pom.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-132,6 +132,10", 
          "lines": [
            "             <groupId>org.apache.synapse</groupId>\n", 
            "             <artifactId>synapse-vfs-transport</artifactId>\n", 
            "         </dependency>\n", 
            "+        <dependency>\n", 
            "+            <groupId>org.apache.synapse</groupId>\n", 
            "+            <artifactId>synapse-amqp-transport</artifactId>\n", 
            "+        </dependency>\n", 
            " \n", 
            "         <dependency>\n", 
            "             <groupId>com.oopsconsultancy</groupId>\n"
          ]
        }
      ], 
      "to": "java/modules/distribution/pom.xml", 
      "from": "java/modules/distribution/pom.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-392,6 +392,11", 
          "lines": [
            "                 <artifactId>synapse-vfs-transport</artifactId>\n", 
            "                 <version>${project.version}</version>\n", 
            "             </dependency>\n", 
            "+            <dependency>\n", 
            "+                <groupId>org.apache.synapse</groupId>\n", 
            "+                <artifactId>synapse-amqp-transport</artifactId>\n", 
            "+                <version>${project.version}</version>\n", 
            "+            </dependency>\n", 
            " \n", 
            "             <!-- Apache Axis2 -->\n", 
            "             <dependency>\n"
          ]
        }
      ], 
      "to": "java/pom.xml", 
      "from": "java/pom.xml"
    }
  ], 
  "id": "1507855"
}