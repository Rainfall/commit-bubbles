{
  "when": "2012-01-30T02:48:16-05:00", 
  "who": "uswick", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-93,6 +93,8", 
          "lines": [
            "     <deployer extension=\"xml\" directory=\"conf/synapse-config/message-stores\" class=\"org.apache.synapse.deployers.MessageStoreDeployer\"/>\n", 
            "     <deployer extension=\"xml\" directory=\"conf/synapse-config/message-processors\" class=\"org.apache.synapse.deployers.MessageProcessorDeployer\"/>\n", 
            "     <deployer extension=\"xml\" directory=\"conf/synapse-config/api\" class=\"org.apache.synapse.deployers.APIDeployer\"/>\n", 
            "+    <deployer extension=\"xml\" directory=\"conf/synapse-config/imports\" class=\"org.apache.synapse.deployers.ImportDeployer\"/>\n", 
            "+    <deployer extension=\"zip\" directory=\"conf/synapse-libs\" class=\"org.apache.synapse.deployers.LibraryArtifactDeployer\"/>\n", 
            " \n", 
            "     <!-- Following parameter will set the host name for the epr-->\n", 
            "     <!--<parameter name=\"hostname\" locked=\"true\">myhost.com</parameter>-->\n"
          ]
        }
      ], 
      "to": "java/repository/conf/axis2.xml", 
      "from": "java/repository/conf/axis2.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-28,7 +28,10", 
          "lines": [
            " import org.apache.synapse.config.xml.TemplateMediatorFactory;\n", 
            " import org.apache.synapse.config.xml.XMLToTemplateMapper;\n", 
            " import org.apache.synapse.config.xml.endpoints.TemplateFactory;\n", 
            "+import org.apache.synapse.libraries.imports.SynapseImport;\n", 
            "+import org.apache.synapse.libraries.model.Library;\n", 
            " import org.apache.synapse.endpoints.Template;\n", 
            "+import org.apache.synapse.libraries.util.LibDeployerUtils;\n", 
            " import org.apache.synapse.mediators.template.TemplateMediator;\n", 
            " import org.apache.synapse.message.processors.MessageProcessor;\n", 
            " import org.apache.synapse.message.store.MessageStore;\n"
          ]
        }, 
        {
          "locn": "-161,6 +164,15", 
          "lines": [
            "      */\n", 
            "     private SynapseArtifactDeploymentStore artifactDeploymentStore = new SynapseArtifactDeploymentStore();\n", 
            " \n", 
            "+    /**\n", 
            "+     * Holds synapse Libraries indexed by library qualified name\n", 
            "+     */\n", 
            "+    Map<String,Library> synapseLibraries = new ConcurrentHashMap<String,Library>();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Holds the library imports  currently being included into Synapse engine\n", 
            "+     */\n", 
            "+    Map<String,SynapseImport> synapseImports = new ConcurrentHashMap<String,SynapseImport>();\n", 
            "     private boolean allowHotUpdate = true;\n", 
            " \n", 
            "     /**\n"
          ]
        }, 
        {
          "locn": "-405,6 +417,11", 
          "lines": [
            "             }\n", 
            "         }\n", 
            " \n", 
            "+        //load from available libraries\n", 
            "+        TemplateMediator templateFromLib = LibDeployerUtils.getLibArtifact(synapseLibraries, key, TemplateMediator.class);\n", 
            "+        if (templateFromLib != null) {\n", 
            "+            return templateFromLib;\n", 
            "+        }\n", 
            "         return null;\n", 
            "     }\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-1596,6 +1613,75", 
          "lines": [
            "     }\n", 
            " \n", 
            "     /**\n", 
            "+     * Add Synapse library to configuration with given name\n", 
            "+     *\n", 
            "+     * @param name      of synapse lib\n", 
            "+     * @param library instance\n", 
            "+     */\n", 
            "+    public void addSynapseLibrary(String name, Library library) {\n", 
            "+        if (!(synapseLibraries.containsKey(name))) {\n", 
            "+            synapseLibraries.put(name, library);\n", 
            "+        } else {\n", 
            "+            handleException(\"Duplicate Synapse Library \" + name);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Get all Synapse libraries in the Synapse configuration\n", 
            "+     *\n", 
            "+     * @return Return Map that contains all the Synapse libraries\n", 
            "+     */\n", 
            "+    public Map<String, Library> getSynapseLibraries() {\n", 
            "+        return synapseLibraries;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * remove the Synapse library from the synapse configuration\n", 
            "+     *\n", 
            "+     * @param name of the lib\n", 
            "+     * @return Removed Synapse library instance\n", 
            "+     */\n", 
            "+    public Library removeSynapseLibrary(String name) {\n", 
            "+        return synapseLibraries.remove(name);\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Add Synapse Import to a configuration with given name\n", 
            "+     *\n", 
            "+     * @param name      of synapse lib\n", 
            "+     * @param synImport instance\n", 
            "+     */\n", 
            "+    public void addSynapseImport(String name, SynapseImport synImport) {\n", 
            "+        if (!(synapseImports.containsKey(name))) {\n", 
            "+            synapseImports.put(name, synImport);\n", 
            "+        } else {\n", 
            "+            handleException(\"Duplicate Synapse Library \" + name);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Get all Synapse libraries in the Synapse configuration\n", 
            "+     *\n", 
            "+     * @return Return Map that contains all the Synapse libraries\n", 
            "+     */\n", 
            "+    public Map<String, SynapseImport> getSynapseImports() {\n", 
            "+        return synapseImports;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * remove the Synapse library from the synapse configuration\n", 
            "+     *\n", 
            "+     * @param name of the lib\n", 
            "+     * @return Removed Synapse library instance\n", 
            "+     */\n", 
            "+    public SynapseImport removeSynapseImport(String name) {\n", 
            "+        return synapseImports.remove(name);\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "      * Sets the description of the configuration\n", 
            "      *\n", 
            "      * @param description tobe set to the artifact\n"
          ]
        }, 
        {
          "locn": "-1709,6 +1795,11", 
          "lines": [
            "                 }\n", 
            "             }\n", 
            "         }\n", 
            "+         //load from available libraries\n", 
            "+        Template templateFromLib = LibDeployerUtils.getLibArtifact(synapseLibraries, key, Template.class);\n", 
            "+        if (templateFromLib != null) {\n", 
            "+            return templateFromLib;\n", 
            "+        }\n", 
            " \n", 
            "         return null;\n", 
            "     }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-77,7 +77,7", 
          "lines": [
            "                 if (paramNameAttr != null) {\n", 
            "                     paramNames.add(paramNameAttr.getAttributeValue());\n", 
            "                 }\n", 
            "-                child.detach();\n", 
            "+//                child.detach();\n", 
            "             }\n", 
            "         }\n", 
            "         templateMediator.setParameters(paramNames);\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/TemplateMediatorFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/TemplateMediatorFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,21", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.config.xml;\n", 
            "+\n", 
            "+public class SynapseImportSerializer {\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseImportSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseImportSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-66,6 +66,7", 
          "lines": [
            "     public static final QName DESCRIPTION_ELT = new QName(SYNAPSE_NAMESPACE, \"description\");\n", 
            "     public static final QName SEQUENCE_ELT    = new QName(SYNAPSE_NAMESPACE, \"sequence\");\n", 
            "     public static final QName TEMPLATE_ELT    = new QName(SYNAPSE_NAMESPACE, \"template\");\n", 
            "+    public static final QName IMPORT_ELT    = new QName(SYNAPSE_NAMESPACE, \"import\");\n", 
            "     public static final QName ENDPOINT_ELT    = new QName(SYNAPSE_NAMESPACE, \"endpoint\");\n", 
            "     public static final QName ENTRY_ELT       = new QName(SYNAPSE_NAMESPACE, \"localEntry\");\n", 
            "     public static final QName REGISTRY_ELT    = new QName(SYNAPSE_NAMESPACE, \"registry\");\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/XMLConfigConstants.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/XMLConfigConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,78", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.config.xml;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMAttribute;\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.libraries.imports.SynapseImport;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+import java.util.Iterator;\n", 
            "+import java.util.Properties;\n", 
            "+\n", 
            "+public class SynapseImportFactory {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(SynapseImportFactory.class);\n", 
            "+\n", 
            "+    public static final QName NAME_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, \"name\");\n", 
            "+    public static final QName PACKAGE_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, \"package\");\n", 
            "+\n", 
            "+    public static final QName ARTIFACT_Q = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE,\n", 
            "+            \"artifact\");\n", 
            "+\n", 
            "+    @SuppressWarnings({\"UnusedDeclaration\"})\n", 
            "+    public static SynapseImport createImport(OMElement elem, Properties properties) {\n", 
            "+\n", 
            "+        OMAttribute pkgAtt = elem.getAttribute(PACKAGE_Q);\n", 
            "+        SynapseImport synapseImport = new SynapseImport();\n", 
            "+\n", 
            "+\n", 
            "+        OMAttribute nameAtt = elem.getAttribute(NAME_Q);\n", 
            "+\n", 
            "+        if (nameAtt != null) {\n", 
            "+            synapseImport.setLibName(nameAtt.getAttributeValue());\n", 
            "+        } else {\n", 
            "+            handleException(\"Synapse Import Target Library name is not specified\");\n", 
            "+        }\n", 
            "+\n", 
            "+        if (pkgAtt != null) {\n", 
            "+            synapseImport.setLibPackage(pkgAtt.getAttributeValue());\n", 
            "+        } else {\n", 
            "+            handleException(\"Synapse Import Target Library package is not specified\");\n", 
            "+        }\n", 
            "+\n", 
            "+        log.info(\"Successfully created Synapse Import: \" + nameAtt.getAttributeValue());\n", 
            "+        return synapseImport;\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+\n", 
            "+    private static void handleException(String msg) {\n", 
            "+        log.error(msg);\n", 
            "+        throw new SynapseException(msg);\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void handleException(String msg, Exception e) {\n", 
            "+        log.error(msg, e);\n", 
            "+        throw new SynapseException(msg, e);\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseImportFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseImportFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-29,6 +29,9", 
          "lines": [
            " import org.apache.synapse.config.xml.endpoints.TemplateFactory;\r\n", 
            " import org.apache.synapse.config.xml.rest.APIFactory;\r\n", 
            " import org.apache.synapse.endpoints.Template;\r\n", 
            "+import org.apache.synapse.libraries.imports.SynapseImport;\r\n", 
            "+import org.apache.synapse.libraries.model.Library;\r\n", 
            "+import org.apache.synapse.libraries.util.LibDeployerUtils;\r\n", 
            " import org.apache.synapse.mediators.template.TemplateMediator;\r\n", 
            " import org.apache.synapse.message.processors.MessageProcessor;\r\n", 
            " import org.apache.synapse.message.store.MessageStore;\r\n"
          ]
        }, 
        {
          "locn": "-79,6 +82,8", 
          "lines": [
            "                     }\r\n", 
            "                 } else if (XMLConfigConstants.TEMPLATE_ELT.equals(elt.getQName())) {\r\n", 
            "                     defineTemplate(config, elt, properties);\r\n", 
            "+                } else if (XMLConfigConstants.IMPORT_ELT.equals(elt.getQName())) {\r\n", 
            "+                    defineImport(config, elt, properties);\r\n", 
            "                 } else if (XMLConfigConstants.ENDPOINT_ELT.equals(elt.getQName())) {\r\n", 
            "                     defineEndpoint(config, elt, properties);\r\n", 
            "                 } else if (XMLConfigConstants.ENTRY_ELT.equals(elt.getQName())) {\r\n"
          ]
        }, 
        {
          "locn": "-286,6 +291,19", 
          "lines": [
            "         return processor;\r\n", 
            "     }\r\n", 
            " \r\n", 
            "+    public static SynapseImport defineImport(SynapseConfiguration config, OMElement elt, Properties properties) {\r\n", 
            "+        SynapseImport synImport = SynapseImportFactory.createImport(elt, properties);\r\n", 
            "+        String libIndexString = LibDeployerUtils.getQualifiedName(synImport);\r\n", 
            "+        config.addSynapseImport(libIndexString, synImport);\r\n", 
            "+\r\n", 
            "+        //get corresponding library for loading imports if available\r\n", 
            "+        Library synLib = config.getSynapseLibraries().get(libIndexString);\r\n", 
            "+        if (synLib != null) {\r\n", 
            "+            LibDeployerUtils.loadLibArtifacts(synImport, synLib);\r\n", 
            "+        }\r\n", 
            "+        return synImport;\r\n", 
            "+    }\r\n", 
            "+\r\n", 
            "     public static Template defineEndpointTemplate(SynapseConfiguration config,\r\n", 
            "                                                     OMElement elem, Properties properties) {\r\n", 
            " \r\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-29,6 +29,7", 
          "lines": [
            " import org.apache.synapse.Startup;\n", 
            " import org.apache.synapse.SynapseConstants;\n", 
            " import org.apache.synapse.endpoints.Template;\n", 
            "+import org.apache.synapse.libraries.imports.SynapseImport;\n", 
            " import org.apache.synapse.mediators.template.TemplateMediator;\n", 
            " import org.apache.synapse.SynapseException;\n", 
            " import org.apache.synapse.message.processors.MessageProcessor;\n"
          ]
        }, 
        {
          "locn": "-89,6 +90,7", 
          "lines": [
            "     public static final String MESSAGE_STORE_DIR        = \"message-stores\";\n", 
            "     public static final String MESSAGE_PROCESSOR_DIR    = \"message-processors\";\n", 
            "     public static final String REST_API_DIR             = \"api\";\n", 
            "+    public static final String SYNAPSE_IMPORTS_DIR   = \"imports\";\n", 
            " \n", 
            "     public static final String REGISTRY_FILE       = \"registry.xml\";\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-132,6 +134,7", 
          "lines": [
            "         createExecutors(synapseConfig, root, properties);\n", 
            "         createMessageStores(synapseConfig, root, properties);\n", 
            "         createMessageProcessors(synapseConfig, root, properties);\n", 
            "+        createSynapseImports(synapseConfig, root, properties);\n", 
            "         createAPIs(synapseConfig, root, properties);\n", 
            " \n", 
            "         return synapseConfig;\n"
          ]
        }, 
        {
          "locn": "-440,6 +443,29", 
          "lines": [
            "         }\n", 
            "     }\n", 
            " \n", 
            "+    private static void createSynapseImports(SynapseConfiguration synapseConfig, String root, Properties properties) {\n", 
            "+        File synImportsDir = new File(root, SYNAPSE_IMPORTS_DIR);\n", 
            "+        if (synImportsDir.exists()) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Loading Synapse Imports from :\" + synImportsDir.getPath());\n", 
            "+            }\n", 
            "+            Iterator synImports = FileUtils.iterateFiles(synImportsDir, extensions, false);\n", 
            "+            while (synImports.hasNext()) {\n", 
            "+                File file = (File) synImports.next();\n", 
            "+                OMElement document = getOMElement(file);\n", 
            "+                SynapseImport synImp = SynapseXMLConfigurationFactory.defineImport(\n", 
            "+                        synapseConfig, document, properties);\n", 
            "+                if (synImp != null) {\n", 
            "+                    synImp.setFileName(file.getName());\n", 
            "+                    synapseConfig.getArtifactDeploymentStore().addArtifact(file.getAbsolutePath(),\n", 
            "+                                                                           synImp.getName());\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "     private static void createAPIs(SynapseConfiguration synapseConfig,\n", 
            "                                             String rootDirPath, Properties properties) {\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MultiXMLConfigurationBuilder.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MultiXMLConfigurationBuilder.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,56", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.libraries.imports;\n", 
            "+\n", 
            "+import org.apache.synapse.libraries.util.LibDeployerUtils;\n", 
            "+\n", 
            "+public class SynapseImport {\n", 
            "+\n", 
            "+    private String importedLibName;\n", 
            "+    private String importedLibPackage;\n", 
            "+    private String fileName;\n", 
            "+\n", 
            "+    public String getLibName() {\n", 
            "+        return importedLibName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setLibName(String name) {\n", 
            "+        this.importedLibName = name;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getLibPackage() {\n", 
            "+        return importedLibPackage;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setLibPackage(String version) {\n", 
            "+        this.importedLibPackage = version;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getFileName() {\n", 
            "+        return fileName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setFileName(String fileName) {\n", 
            "+        this.fileName = fileName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getName() {\n", 
            "+        return LibDeployerUtils.getQualifiedName(this);\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/libraries/imports/SynapseImport.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/libraries/imports/SynapseImport.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,460", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.libraries.util;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMAttribute;\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axiom.om.impl.builder.StAXOMBuilder;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.deployers.SynapseArtifactDeploymentException;\n", 
            "+import org.apache.synapse.libraries.imports.SynapseImport;\n", 
            "+import org.apache.synapse.libraries.model.Library;\n", 
            "+import org.apache.synapse.libraries.model.LibraryArtifact;\n", 
            "+import org.apache.synapse.libraries.model.SynapseLibrary;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+import javax.xml.stream.XMLStreamException;\n", 
            "+import java.io.*;\n", 
            "+import java.util.*;\n", 
            "+import java.util.zip.ZipEntry;\n", 
            "+import java.util.zip.ZipFile;\n", 
            "+\n", 
            "+public class LibDeployerUtils {\n", 
            "+\n", 
            "+    public static final String APP_UNZIP_DIR;\n", 
            "+\n", 
            "+    static {\n", 
            "+        String javaTempDir = System.getProperty(\"java.io.tmpdir\");\n", 
            "+        APP_UNZIP_DIR = javaTempDir.endsWith(File.separator) ?\n", 
            "+                        javaTempDir + LibDeployerConstants.SYNAPSE_LIBS :\n", 
            "+                        javaTempDir + File.separator + LibDeployerConstants.SYNAPSE_LIBS;\n", 
            "+        createDir(APP_UNZIP_DIR);\n", 
            "+    }\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(LibDeployerUtils.class);\n", 
            "+\n", 
            "+\n", 
            "+\n", 
            "+    public static Library createSynapseLibrary(String libPath) {\n", 
            "+        String libFilePath = LibDeployerUtils.formatPath(libPath);\n", 
            "+        //extract\n", 
            "+        String extractPath = LibDeployerUtils.extractSynapseLib(libFilePath);\n", 
            "+        //create synapse lib metadata\n", 
            "+        SynapseLibrary synapseLib = LibDeployerUtils.populateDependencies(extractPath + LibDeployerConstants.ARTIFACTS_XML);\n", 
            "+        //resolve synapse lib artifacts\n", 
            "+        LibDeployerUtils.searchAndResolveDependencies(extractPath, synapseLib);\n", 
            "+        return synapseLib;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * populate Dependencies using main root artifacts.xml.. Schema for artifacts.xml is follwing\n", 
            "+     *\n", 
            "+     *<artifacts>\n", 
            "+         <artifact name=\"SampleLib\" package=\"synapse.sample\" >\n", 
            "+                <dependency artifact=\"templates1\" /> +\n", 
            "+                <description>sample synapse library</description> ?\n", 
            "+         </artifact>\n", 
            "+    </artifacts>\n", 
            "+     *\n", 
            "+     * @param libXmlPath\n", 
            "+     * @return\n", 
            "+     */\n", 
            "+    private static SynapseLibrary populateDependencies(String libXmlPath) {\n", 
            "+        File f = new File(libXmlPath);\n", 
            "+        if (!f.exists()) {\n", 
            "+            throw new SynapseException(\"artifacts.xml file not found at : \" + libXmlPath);\n", 
            "+        }\n", 
            "+        InputStream xmlInputStream = null;\n", 
            "+        try {\n", 
            "+            xmlInputStream = new FileInputStream(f);\n", 
            "+            OMElement documentElement = new StAXOMBuilder(xmlInputStream).getDocumentElement();\n", 
            "+            if (documentElement == null) {\n", 
            "+                throw new SynapseArtifactDeploymentException(\"Document element for artifacts.xml is \" +\n", 
            "+                                                             \"null. Can't build \" +\n", 
            "+                                                             \"the synapse library configuration\");\n", 
            "+            }\n", 
            "+            Iterator artifactItr = documentElement.getChildrenWithLocalName(LibDeployerConstants.ARTIFACT);\n", 
            "+            SynapseLibrary mainSynLibArtifact = null;\n", 
            "+            mainSynLibArtifact = createSynapseLibraryWithDeps(((OMElement) artifactItr.next()));\n", 
            "+            if (mainSynLibArtifact == null) {\n", 
            "+                throw new SynapseArtifactDeploymentException(\"artifacts.xml is invalid. <artifact> element\" +\n", 
            "+                                                             \" Not Found \");\n", 
            "+            }\n", 
            "+            return mainSynLibArtifact;\n", 
            "+        } catch (FileNotFoundException e) {\n", 
            "+            throw new SynapseArtifactDeploymentException(\"artifacts.xml File cannot be loaded from \" + libXmlPath, e);\n", 
            "+\n", 
            "+        } catch (XMLStreamException e) {\n", 
            "+            throw new SynapseArtifactDeploymentException(\"Error while parsing the artifacts.xml file \", e);\n", 
            "+        } finally {\n", 
            "+            if (xmlInputStream != null) {\n", 
            "+                try {\n", 
            "+                    xmlInputStream.close();\n", 
            "+                } catch (IOException e) {\n", 
            "+                    log.error(\"Error while closing input stream.\", e);\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Builds the Artifact object when an artifact element is given\n", 
            "+     *\n", 
            "+     * @param artifactEle - artifact OMElement\n", 
            "+     * @return created Artifact object\n", 
            "+     */\n", 
            "+    private static SynapseLibrary createSynapseLibraryWithDeps(OMElement artifactEle) {\n", 
            "+        if (artifactEle == null) {\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+        SynapseLibrary synLib = new SynapseLibrary(readAttribute(artifactEle, LibDeployerConstants.NAME),\n", 
            "+                                                   readAttribute(artifactEle, LibDeployerConstants.PACKAGE_ATTR));\n", 
            "+        synLib.setDescription(readChildText(artifactEle,LibDeployerConstants.DESCRIPTION_ELEMENT));\n", 
            "+        // read the dependencies\n", 
            "+        Iterator itr = artifactEle.getChildrenWithLocalName(LibDeployerConstants.DEPENDENCY);\n", 
            "+        while (itr.hasNext()) {\n", 
            "+            OMElement depElement = (OMElement) itr.next();\n", 
            "+            // create a synLib for each dependency and add to the root synLib\n", 
            "+            LibraryArtifact.Dependency dep = new LibraryArtifact.Dependency(readAttribute(depElement,\n", 
            "+                                                                     LibDeployerConstants.ARTIFACT));\n", 
            "+            synLib.addDependency(dep);\n", 
            "+        }\n", 
            "+\n", 
            "+        return synLib;\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Deploys all artifacts under a root artifact..\n", 
            "+     *\n", 
            "+     * @param rootDirPath - root dir of the extracted artifact\n", 
            "+     * @param library     - lib instance\n", 
            "+     */\n", 
            "+    private static void searchAndResolveDependencies(String rootDirPath,\n", 
            "+                                                    SynapseLibrary library) {\n", 
            "+        List<LibraryArtifact> libraryArtifacts = new ArrayList<LibraryArtifact>();\n", 
            "+        File extractedDir = new File(rootDirPath);\n", 
            "+        File[] allFiles = extractedDir.listFiles();\n", 
            "+        if (allFiles == null) {\n", 
            "+            return;\n", 
            "+        }\n", 
            "+\n", 
            "+\n", 
            "+        // search for all directories under the extracted path\n", 
            "+        for (File artifactDirectory : allFiles) {\n", 
            "+            if (!artifactDirectory.isDirectory()) {\n", 
            "+                continue;\n", 
            "+            }\n", 
            "+\n", 
            "+            String directoryPath = formatPath(artifactDirectory.getAbsolutePath());\n", 
            "+            String artifactXmlPath = directoryPath + File.separator + LibDeployerConstants.ARTIFACT_XML;\n", 
            "+\n", 
            "+            File f = new File(artifactXmlPath);\n", 
            "+            // if the artifact.xml not found, ignore this dir\n", 
            "+            if (!f.exists()) {\n", 
            "+                continue;\n", 
            "+            }\n", 
            "+\n", 
            "+            LibraryArtifact artifact = null;\n", 
            "+            InputStream xmlInputStream = null;\n", 
            "+            try {\n", 
            "+                xmlInputStream = new FileInputStream(f);\n", 
            "+                artifact = buildArtifact(library, xmlInputStream, directoryPath);\n", 
            "+            } catch (FileNotFoundException e) {\n", 
            "+                log.warn(\"Error while resolving synapse lib dir :\"\n", 
            "+                                                             + artifactDirectory.getName() +\n", 
            "+                                                             \" artifacts.xml File cannot be loaded \" +\n", 
            "+                                                             \"from \" + artifactXmlPath, e);\n", 
            "+            } catch (Exception e) {\n", 
            "+                log.warn(\"Error ocurred while resolving synapse lib dir :\"\n", 
            "+                                                             + artifactDirectory.getName() +\n", 
            "+                                                             \" for artifacts.xml path\" + artifactXmlPath, e);\n", 
            "+            } finally {\n", 
            "+                if (xmlInputStream != null) {\n", 
            "+                    try {\n", 
            "+                        xmlInputStream.close();\n", 
            "+                    } catch (IOException e) {\n", 
            "+                        log.error(\"Error while closing input stream.\", e);\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+            if (artifact == null) {\n", 
            "+                log.warn(\"Could not build lib artifact for path : \" + directoryPath + \" Synapse Library :\" +\n", 
            "+                         library.getQName() + \". Continue searching for other lib artifacts\");\n", 
            "+                continue;\n", 
            "+\n", 
            "+            }\n", 
            "+            libraryArtifacts.add(artifact);\n", 
            "+        }\n", 
            "+        boolean isDepsResolved = library.resolveDependencies(libraryArtifacts);\n", 
            "+        if (!isDepsResolved) {\n", 
            "+            throw new SynapseArtifactDeploymentException(\"Error when resolving Dependencies for lib : \" + library.toString());\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Builds the artifact from the given input steam and adds it as a dependency in the provided\n", 
            "+     *  parent Synapse library artifact\n", 
            "+     *\n", 
            "+     * @param library\n", 
            "+     * @param artifactXmlStream - xml input stream of the artifact.xml\n", 
            "+     * @param directoryPath\n", 
            "+     * @return - Artifact instance if successfull. otherwise null..\n", 
            "+     */\n", 
            "+    private static LibraryArtifact buildArtifact(SynapseLibrary library, InputStream artifactXmlStream, String directoryPath) {\n", 
            "+        LibraryArtifact artifact = null;\n", 
            "+        try {\n", 
            "+            OMElement artElement = new StAXOMBuilder(artifactXmlStream).getDocumentElement();\n", 
            "+\n", 
            "+            if (LibDeployerConstants.ARTIFACT.equals(artElement.getLocalName())) {\n", 
            "+                artifact = populateLibraryArtifact(artElement, directoryPath, null, library);\n", 
            "+            } else {\n", 
            "+                log.error(\"artifact.xml is invalid. Error occurred while resolving Synapse Library : \"\n", 
            "+                          + library.getQName());\n", 
            "+                return null;\n", 
            "+            }\n", 
            "+        } catch (XMLStreamException e) {\n", 
            "+            throw new SynapseArtifactDeploymentException(\"Error parsing artifact.xml for path : \" +\n", 
            "+                                                         directoryPath ,e);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (artifact == null || artifact.getName() == null) {\n", 
            "+            log.error(\"Invalid artifact found in Synapse Library : \"\n", 
            "+                      + library.getQName() );\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+        return artifact;\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Builds the Artifact object when an root artifact element is given . Schema for artifact.xml\n", 
            "+     * is as follows\n", 
            "+     * <artifact name=\"templates1\" type=\"synapse/template\" >\n", 
            "+\n", 
            "+        <subArtifacts>\n", 
            "+            <artifact name=\"greet_func1\" >\n", 
            "+                    <file>templ1_ns1.xml</file>\n", 
            "+                    <description>sample synapse library artifact Description</description> ?\n", 
            "+            </artifact> *\n", 
            "+        </subArtifacts> *\n", 
            "+\n", 
            "+        <description>sample synapse library artifact Description</description> ?\n", 
            "+    </artifact>\n", 
            "+     *\n", 
            "+     * @param artifactEle - artifact OMElement\n", 
            "+     * @return created Artifact object\n", 
            "+     */\n", 
            "+    private static LibraryArtifact populateLibraryArtifact(OMElement artifactEle, String artifactPath,\n", 
            "+                                                          LibraryArtifact parent , SynapseLibrary library) {\n", 
            "+        if (artifactEle == null || artifactPath == null ) {\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+\n", 
            "+        LibraryArtifact artifact = new LibraryArtifact(readAttribute(artifactEle, LibDeployerConstants.NAME));\n", 
            "+        artifact.setParent(parent);\n", 
            "+        artifact.setType(readAttribute(artifactEle, LibDeployerConstants.TYPE));\n", 
            "+        artifact.setPath(artifactPath);\n", 
            "+\n", 
            "+        artifact.setDescription(readChildText(artifactEle,LibDeployerConstants.DESCRIPTION_ELEMENT));\n", 
            "+        //add a description of this artifact(if availalbe) to Synapse Library\n", 
            "+        library.addArtifactDescription(artifact);\n", 
            "+        // read the subArtifacts\n", 
            "+        OMElement subArtifactsElement = artifactEle\n", 
            "+                .getFirstChildWithName(new QName(LibDeployerConstants.SUB_ARTIFACTS));\n", 
            "+        if (subArtifactsElement != null) {\n", 
            "+            Iterator subArtItr = subArtifactsElement.getChildrenWithLocalName(LibDeployerConstants.ARTIFACT);\n", 
            "+            while (subArtItr.hasNext()) {\n", 
            "+                // as this is also an artifact, use recursion\n", 
            "+                LibraryArtifact subArtifact = populateLibraryArtifact((OMElement) subArtItr.next(), artifactPath, artifact, library);\n", 
            "+                artifact.addSubArtifact(subArtifact);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        // read and check for files\n", 
            "+        Iterator fileItr = artifactEle.getChildrenWithLocalName(LibDeployerConstants.FILE);\n", 
            "+        while (fileItr.hasNext()) {\n", 
            "+            OMElement fileElement = (OMElement) fileItr.next();\n", 
            "+            artifact.setupFile(fileElement.getText());\n", 
            "+        }\n", 
            "+        return artifact;\n", 
            "+    }\n", 
            "+\n", 
            "+    public static void loadLibArtifacts(SynapseImport synImport, Library library) {\n", 
            "+        if (synImport.getLibName().equals(library.getQName().getLocalPart()) &&\n", 
            "+            synImport.getLibPackage().equals(library.getPackage())) {\n", 
            "+            library.loadLibrary();\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public static <T> T getLibArtifact(Map<String, Library> librarySet, String key, Class<T> type) {\n", 
            "+        for (Library synapseLibrary : librarySet.values()) {\n", 
            "+            try {\n", 
            "+                T artifact = (T) synapseLibrary.getArtifact(key);\n", 
            "+                if (artifact != null) {\n", 
            "+                    return artifact;\n", 
            "+                }\n", 
            "+            } catch (Exception e) {\n", 
            "+                //ignore\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getQualifiedName(SynapseImport synImport){\n", 
            "+        return new QName(synImport.getLibPackage(),synImport.getLibName()).toString();\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    ///////////////////////\n", 
            "+    ////////////////// Start Common Utility Methods\n", 
            "+    /**\n", 
            "+     * Reads an attribute in the given element and returns the value of that attribute\n", 
            "+     *\n", 
            "+     * @param element - Element to search\n", 
            "+     * @param attName - attribute name\n", 
            "+     * @return if the attribute found, return value. else null.\n", 
            "+     */\n", 
            "+    public static String readAttribute(OMElement element, String attName) {\n", 
            "+        if (element == null) {\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+        OMAttribute temp = element.getAttribute(new QName(attName));\n", 
            "+        if (temp != null) {\n", 
            "+            return temp.getAttributeValue();\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String readChildText(OMElement element, String ln) {\n", 
            "+        return readChildText(element, ln, null);\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Reads a text node which is in a child element of the given element and returns the text\n", 
            "+     * value.\n", 
            "+     *\n", 
            "+     * @param element - Element to search\n", 
            "+     * @param ln      - Child element name\n", 
            "+     * @param ns      - Child element namespace\n", 
            "+     * @return if the child text element found, return text value. else null.\n", 
            "+     */\n", 
            "+    public static String readChildText(OMElement element, String ln, String ns) {\n", 
            "+        if (element == null) {\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+        OMElement temp = element.getFirstChildWithName(new QName(ns, ln));\n", 
            "+        if (temp != null) {\n", 
            "+            return temp.getText();\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Extract the Synapse Library at the provided path to the java temp dir. Return the\n", 
            "+     * extracted location\n", 
            "+     *\n", 
            "+     * @param libPath - Absolute path of the Synapse Lib archive file\n", 
            "+     * @return - extracted location\n", 
            "+     * @throws SynapseException - error on extraction\n", 
            "+     */\n", 
            "+    public static String extractSynapseLib(String libPath) throws SynapseException {\n", 
            "+        libPath = formatPath(libPath);\n", 
            "+        String fileName = libPath.substring(libPath.lastIndexOf('/') + 1);\n", 
            "+        String dest = APP_UNZIP_DIR + File.separator + System.currentTimeMillis() +\n", 
            "+                      fileName + File.separator;\n", 
            "+        createDir(dest);\n", 
            "+\n", 
            "+        try {\n", 
            "+            extract(libPath, dest);\n", 
            "+        } catch (IOException e) {\n", 
            "+            throw new SynapseException(\"Error while extracting Synapse Library : \" + fileName, e);\n", 
            "+        }\n", 
            "+        return dest;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Format the string paths to match any platform.. windows, linux etc..\n", 
            "+     *\n", 
            "+     * @param path - input file path\n", 
            "+     * @return formatted file path\n", 
            "+     */\n", 
            "+    public static String formatPath(String path) {\n", 
            "+        // removing white spaces\n", 
            "+        path = path.replaceAll(\"\\\\b\\\\s+\\\\b\", \"%20\");\n", 
            "+        // replacing all \"\\\" with \"/\"\n", 
            "+        return path.replace('\\\\', '/');\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void extract(String sourcePath, String destPath) throws IOException {\n", 
            "+        Enumeration entries;\n", 
            "+        ZipFile zipFile;\n", 
            "+\n", 
            "+        zipFile = new ZipFile(sourcePath);\n", 
            "+        entries = zipFile.entries();\n", 
            "+\n", 
            "+        while (entries.hasMoreElements()) {\n", 
            "+            ZipEntry entry = (ZipEntry) entries.nextElement();\n", 
            "+            // we don't need to copy the META-INF dir\n", 
            "+            if (entry.getName().startsWith(\"META-INF/\")) {\n", 
            "+                continue;\n", 
            "+            }\n", 
            "+            // if the entry is a directory, create a new dir\n", 
            "+            if (entry.isDirectory()) {\n", 
            "+                createDir(destPath + entry.getName());\n", 
            "+                continue;\n", 
            "+            }\n", 
            "+            // if the entry is a file, write the file\n", 
            "+            copyInputStream(zipFile.getInputStream(entry),\n", 
            "+                            new BufferedOutputStream(new FileOutputStream(destPath + entry.getName())));\n", 
            "+        }\n", 
            "+        zipFile.close();\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    public static void createDir(String path) {\n", 
            "+        File temp = new File(path);\n", 
            "+        if (!temp.exists() && !temp.mkdir()) {\n", 
            "+            log.error(\"Error while creating directory : \" + path);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void copyInputStream(InputStream in, OutputStream out)\n", 
            "+            throws IOException {\n", 
            "+        byte[] buffer = new byte[40960];\n", 
            "+        int len;\n", 
            "+\n", 
            "+        while ((len = in.read(buffer)) >= 0) {\n", 
            "+            out.write(buffer, 0, len);\n", 
            "+        }\n", 
            "+\n", 
            "+        in.close();\n", 
            "+        out.close();\n", 
            "+    }\n", 
            "+\n", 
            "+    /////////////////// End Of Common Utility Methods\n", 
            "+\n", 
            "+\n", 
            "+    public static void main(String[] args) {\n", 
            "+        new SynapseLibrary(null, null).resolveDependencies(null);\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/libraries/util/LibDeployerUtils.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/libraries/util/LibDeployerUtils.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,39", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.libraries.util;\n", 
            "+\n", 
            "+public class LibDeployerConstants {\n", 
            "+\n", 
            "+    public static final String SYNAPSE_LIBS = \"libs\";\n", 
            "+    public static final String NAME = \"name\";\n", 
            "+    public static final String TYPE = \"type\";\n", 
            "+    public static final String VERSION = \"version\";\n", 
            "+\n", 
            "+    public static final String ARTIFACT_XML = \"artifact.xml\";\n", 
            "+\n", 
            "+    public static final String ARTIFACT = \"artifact\";\n", 
            "+    public static final String DEPENDENCY = \"dependency\";\n", 
            "+\n", 
            "+    public static final String SUB_ARTIFACTS = \"subArtifacts\";\n", 
            "+    public static final String FILE = \"file\";\n", 
            "+    public static final String PACKAGE_ATTR = \"package\";\n", 
            "+    public static final String DESCRIPTION_ELEMENT = \"description\";\n", 
            "+    public static final String ARTIFACTS_XML = \"artifacts.xml\";\n", 
            "+\n", 
            "+    public static final String SYNAPSE_LIB_FORMAT = \"zip\";\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/libraries/util/LibDeployerConstants.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/libraries/util/LibDeployerConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,71", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.libraries.model;\n", 
            "+\n", 
            "+import org.apache.synapse.SynapseArtifact;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+\n", 
            "+public interface Library extends SynapseArtifact {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * get Fully qualified Name of the Library\n", 
            "+     * @return returns the logical name of the Synapse library which constitutes of [package + library name]\n", 
            "+     */\n", 
            "+    public QName getQName();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * returns the package that this Library belongs to\n", 
            "+     * @return  package name\n", 
            "+     */\n", 
            "+    public String getPackage();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * return synapse lib artifact deployed by this library with the given artifact name\n", 
            "+     *\n", 
            "+     * @param artifacName\n", 
            "+     * @return\n", 
            "+     */\n", 
            "+    public Object getArtifact(String artifacName);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * gives the Artifact description for the given artifact name (if available)\n", 
            "+     * @param artifactName\n", 
            "+     * @return\n", 
            "+     */\n", 
            "+    public String getArtifactDescription(String  artifactName);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * load all library artifacts on this library for each and every namespace\n", 
            "+     * this should be called when a import is taking place\n", 
            "+     *\n", 
            "+     * @return success\n", 
            "+     */\n", 
            "+    public boolean loadLibrary();\n", 
            "+\n", 
            "+    /**\n", 
            "+     * unload all library artifacts on this library\n", 
            "+     * this should be called when a import is no longer valid/ non-existent or library being\n", 
            "+     * undeployed\n", 
            "+     *\n", 
            "+     * @return success\n", 
            "+     */\n", 
            "+    public boolean unLoadLibrary();\n", 
            "+\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/libraries/model/Library.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/libraries/model/Library.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,180", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.libraries.model;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+import java.util.ArrayList;\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.List;\n", 
            "+import java.util.Map;\n", 
            "+\n", 
            "+public class SynapseLibrary implements Library {\n", 
            "+    private String packageN = null;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * this is the logical name of the Synapse library which constitutes of [package + library name]\n", 
            "+     */\n", 
            "+    protected QName qualifiedName = null;\n", 
            "+\n", 
            "+    public List<LibraryArtifact.Dependency> dependencies;\n", 
            "+\n", 
            "+    private Map<String , LibraryArtifact> depNameToArtifactIndex = new HashMap<String , LibraryArtifact>();\n", 
            "+\n", 
            "+    private Map<String, Object> libComponentIndex = new HashMap<String, Object>();\n", 
            "+\n", 
            "+    private Map<String, String> libArtifactDetails = new HashMap<String, String >();\n", 
            "+\n", 
            "+    private String description;\n", 
            "+\n", 
            "+    private boolean isLoaded = false;\n", 
            "+\n", 
            "+    public SynapseLibrary(String name, String packageName) {\n", 
            "+        this.packageN = packageName;\n", 
            "+        if (packageName != null && !\"\".equals(packageName)) {\n", 
            "+            qualifiedName = new QName(packageName, name);\n", 
            "+        } else {\n", 
            "+            qualifiedName = new QName(name);\n", 
            "+        }\n", 
            "+        dependencies = new ArrayList<LibraryArtifact.Dependency>();\n", 
            "+    }\n", 
            "+\n", 
            "+    public QName getQName() {\n", 
            "+        return qualifiedName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getName() {\n", 
            "+        return qualifiedName.getLocalPart();\n", 
            "+    }\n", 
            "+\n", 
            "+    public void addDependency(LibraryArtifact.Dependency artifactDep) {\n", 
            "+        dependencies.add(artifactDep);\n", 
            "+    }\n", 
            "+\n", 
            "+    public void addComponent(String qualifiedName, Object libComponent) {\n", 
            "+        libComponentIndex.put(qualifiedName, libComponent);\n", 
            "+    }\n", 
            "+\n", 
            "+    public void addArtifactDescription(LibraryArtifact artifact){\n", 
            "+        libArtifactDetails.put(artifact.getName(),artifact.getDescription());\n", 
            "+    }\n", 
            "+\n", 
            "+    public String  getArtifactDescription(String  artifactName){\n", 
            "+        return libArtifactDetails.get(artifactName);\n", 
            "+    }\n", 
            "+\n", 
            "+    public void removeComponent(String qualifiedName) {\n", 
            "+        libComponentIndex.remove(qualifiedName);\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean resolveDependencies(List<LibraryArtifact> unresolvedPrincipalArtifactList) {\n", 
            "+        int unresolvedDeps = dependencies.size();\n", 
            "+        for (LibraryArtifact.Dependency dependency : dependencies) {\n", 
            "+            for (LibraryArtifact current : unresolvedPrincipalArtifactList) {\n", 
            "+                if (dependency.resolveWith(current)) {\n", 
            "+                    unresolvedDeps--;\n", 
            "+                    depNameToArtifactIndex.put(dependency.getName(), current);\n", 
            "+                    break;\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        if (unresolvedDeps == 0) {\n", 
            "+            dependencies.clear();\n", 
            "+            return true;\n", 
            "+        } else {\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * load all library artifacts on this library\n", 
            "+     * this should be called when a import is taking place\n", 
            "+     *\n", 
            "+     * @return success\n", 
            "+     */\n", 
            "+    public synchronized boolean loadLibrary() {\n", 
            "+        if (!isLoaded) {\n", 
            "+            for (String  artifactName : depNameToArtifactIndex.keySet()) {\n", 
            "+                loadLibrary(artifactName);\n", 
            "+            }\n", 
            "+        }\n", 
            "+        isLoaded = true;\n", 
            "+        return true;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * load all library artifacts on this library for the given QName\n", 
            "+     * this should be called when a import is taking place\n", 
            "+     *\n", 
            "+     * @return success\n", 
            "+     */\n", 
            "+    public synchronized void loadLibrary(String  artifactDependencyName) {\n", 
            "+        LibraryArtifact libAr = depNameToArtifactIndex.get(artifactDependencyName);\n", 
            "+        libAr.loadComponentsInto(this);\n", 
            "+\n", 
            "+        //TODO once all components are loaded iterate and initialize Lifecycle method #init() ?\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * unload all library artifacts on this library for the given QName\n", 
            "+     * this should be called when a import is no longer valid/ non-existent\n", 
            "+     *\n", 
            "+     * @return success\n", 
            "+     */\n", 
            "+    public synchronized boolean unLoadLibrary() {\n", 
            "+        //TODO when components are un-loaded iterate and execute Lifecycle method #destroy() ?\n", 
            "+        libComponentIndex.clear();\n", 
            "+        isLoaded = false;\n", 
            "+        return true;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void clear() {\n", 
            "+        depNameToArtifactIndex.clear();\n", 
            "+        libArtifactDetails.clear();\n", 
            "+        libComponentIndex.clear();\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * return synapse lib artifact deployed by this library with the given Local name\n", 
            "+     *\n", 
            "+     * @param artifacName\n", 
            "+     * @return\n", 
            "+     */\n", 
            "+    public Object getArtifact(String artifacName) {\n", 
            "+        if (libComponentIndex.containsKey(artifacName)) {\n", 
            "+            return libComponentIndex.get(artifacName);\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String toString() {\n", 
            "+        return qualifiedName.toString();\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getPackage() {\n", 
            "+        return packageN;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setDescription(String description) {\n", 
            "+        this.description = description;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getDescription() {\n", 
            "+        return description;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/libraries/model/SynapseLibrary.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/libraries/model/SynapseLibrary.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,66", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.libraries.model;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axiom.om.impl.builder.StAXOMBuilder;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.deployers.SynapseArtifactDeploymentException;\n", 
            "+\n", 
            "+import javax.xml.stream.XMLStreamException;\n", 
            "+import java.io.*;\n", 
            "+\n", 
            "+public abstract class ArtifactFile {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(ArtifactFile.class);\n", 
            "+\n", 
            "+    protected static String fileName;\n", 
            "+\n", 
            "+    protected OMElement configurationElement;\n", 
            "+\n", 
            "+    public abstract Object build();\n", 
            "+\n", 
            "+    public ArtifactFile(String fileXmlPath){\n", 
            "+        fileName = fileXmlPath;\n", 
            "+        File f = new File(fileXmlPath);\n", 
            "+        if (!f.exists()) {\n", 
            "+            throw new SynapseArtifactDeploymentException(\"file not found at : \" + fileXmlPath);\n", 
            "+        }\n", 
            "+        InputStream xmlInputStream = null;\n", 
            "+        try {\n", 
            "+            xmlInputStream = new FileInputStream(f);\n", 
            "+            configurationElement = new StAXOMBuilder(xmlInputStream).getDocumentElement();\n", 
            "+        } catch (FileNotFoundException e) {\n", 
            "+               throw new SynapseArtifactDeploymentException(\"file not found at : \" + fileXmlPath);\n", 
            "+        } catch (XMLStreamException e) {\n", 
            "+            throw new SynapseArtifactDeploymentException(\"Error while parsing the artifacts.xml file : \" + fileXmlPath , e);\n", 
            "+        } finally {\n", 
            "+            if (xmlInputStream != null) {\n", 
            "+                try {\n", 
            "+                    xmlInputStream.close();\n", 
            "+                } catch (IOException e) {\n", 
            "+                    log.error(\"Error while closing input stream for file artifact.\", e);\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/libraries/model/ArtifactFile.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/libraries/model/ArtifactFile.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,223", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.libraries.model;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.synapse.SynapseArtifact;\n", 
            "+import org.apache.synapse.SynapseConstants;\n", 
            "+import org.apache.synapse.config.xml.MediatorFactoryFinder;\n", 
            "+import org.apache.synapse.config.xml.XMLConfigConstants;\n", 
            "+import org.apache.synapse.config.xml.endpoints.TemplateFactory;\n", 
            "+import org.apache.synapse.deployers.SynapseArtifactDeploymentException;\n", 
            "+import org.apache.synapse.endpoints.Template;\n", 
            "+import org.apache.synapse.mediators.template.TemplateMediator;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+import java.io.File;\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.Properties;\n", 
            "+\n", 
            "+public class LibraryArtifact implements SynapseArtifact{\n", 
            "+\n", 
            "+    protected String name;\n", 
            "+    protected String type;\n", 
            "+    protected String description;\n", 
            "+\n", 
            "+    String extractedPath;\n", 
            "+    ArtifactFile file;\n", 
            "+    int unresolvedDeps = 0;\n", 
            "+\n", 
            "+    Map<String, LibraryArtifact> subArtifacts;\n", 
            "+\n", 
            "+    private LibraryArtifact parent;\n", 
            "+\n", 
            "+\n", 
            "+    public LibraryArtifact(String  name) {\n", 
            "+        this.name = name;\n", 
            "+        subArtifacts = new HashMap<String, LibraryArtifact>();\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+    public void setupFile(String filename) {\n", 
            "+        if (filename != null && !\"\".equals(filename)) {\n", 
            "+            if (\"synapse/template\".equals(getArtifactType())) {\n", 
            "+                file = this.new TemplateArtifactFile(filename);\n", 
            "+            } else {\n", 
            "+                throw new SynapseArtifactDeploymentException(\"Unsupported Type for synapse lib artifact.\");\n", 
            "+            }\n", 
            "+        } else {\n", 
            "+            throw new SynapseArtifactDeploymentException(\"Invalid file specified for lib artifact.\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private String getArtifactType() {\n", 
            "+        if (type != null) {\n", 
            "+            return type;\n", 
            "+        } else if (parent != null) {\n", 
            "+            return parent.getArtifactType();\n", 
            "+        }\n", 
            "+        return \"\";\n", 
            "+    }\n", 
            "+\n", 
            "+    public void addSubArtifact(LibraryArtifact artifact) {\n", 
            "+        if (artifact != null) {\n", 
            "+            subArtifacts.put(artifact.toString(), artifact);\n", 
            "+            unresolvedDeps++;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public String  getName() {\n", 
            "+        return name;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isLeafArtifact() {\n", 
            "+        return file == null ? false : true;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void loadComponentsInto(SynapseLibrary library) {\n", 
            "+        for (String artifactName : subArtifacts.keySet()) {\n", 
            "+            LibraryArtifact artifact = subArtifacts.get(artifactName);\n", 
            "+            if (artifact.isLeafArtifact()) {\n", 
            "+                //this is where actual artifact is constructed to it's ture form\n", 
            "+                Object template = artifact.file.build();\n", 
            "+                if (artifact.file instanceof TemplateArtifactFile) {\n", 
            "+\n", 
            "+                    if (template instanceof TemplateMediator) {\n", 
            "+                        String templateName = ((TemplateMediator) template).getName();\n", 
            "+                        library.addComponent(getQualifiedName(library.getPackage(), templateName), template);\n", 
            "+                    } else if (template instanceof Template) {\n", 
            "+                        String templateName = ((Template) template).getName();\n", 
            "+                        library.addComponent(getQualifiedName(library.getPackage(), templateName), template);\n", 
            "+                    } else if (template != null) {\n", 
            "+                        library.addComponent(getQualifiedName(library.getPackage(),\n", 
            "+                                                              artifact.getName()), template);\n", 
            "+                    } else {\n", 
            "+                        throw new SynapseArtifactDeploymentException(\"Cannot load components into \" +\n", 
            "+                                                                     \"Synapse Library. Component \" +\n", 
            "+                                                                     \"cannot be built for \" + artifactName);\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            } else {\n", 
            "+                artifact.loadComponentsInto(library);\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private String getQualifiedName(String aPackage, String templateName) {\n", 
            "+        return aPackage + \".\" + templateName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setPath(String path) {\n", 
            "+        if (!path.endsWith(File.separator)) {\n", 
            "+            path = path + File.separator;\n", 
            "+        }\n", 
            "+        this.extractedPath = path;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String toString() {\n", 
            "+        return name;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getType() {\n", 
            "+        return type;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setType(String type) {\n", 
            "+        this.type = type;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setParent(LibraryArtifact parent) {\n", 
            "+        this.parent = parent;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setDescription(String description) {\n", 
            "+        this.description = description;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getDescription() {\n", 
            "+        return description;  //To change body of implemented methods use File | Settings | File Templates.\n", 
            "+    }\n", 
            "+\n", 
            "+    private class TemplateArtifactFile extends ArtifactFile {\n", 
            "+        public TemplateArtifactFile(String fileXmlPath) {\n", 
            "+            super(extractedPath + fileXmlPath);\n", 
            "+        }\n", 
            "+\n", 
            "+        @Override\n", 
            "+        public Object build() {\n", 
            "+            Object templateObject = null;\n", 
            "+            OMElement element = configurationElement.getFirstChildWithName(\n", 
            "+                    new QName(SynapseConstants.SYNAPSE_NAMESPACE, \"sequence\"));\n", 
            "+            if (element != null) {\n", 
            "+                String name = element.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE, \"name\"));\n", 
            "+                try {\n", 
            "+                    templateObject = MediatorFactoryFinder.getInstance().getMediator(configurationElement, new Properties());\n", 
            "+                } catch (Exception e) {\n", 
            "+                    String msg = \"Template configuration : \" + name + \" cannot be built\" +\n", 
            "+                            \"for Synapse Library artifact : \" + LibraryArtifact.this.name;;\n", 
            "+//                        handleConfigurationError(SynapseConstants.FAIL_SAFE_MODE_TEMPLATES, msg, e);\n", 
            "+                    throw new SynapseArtifactDeploymentException(msg,e);\n", 
            "+                }\n", 
            "+                return templateObject;\n", 
            "+            } else {\n", 
            "+                element = configurationElement.getFirstChildWithName(\n", 
            "+                        new QName(SynapseConstants.SYNAPSE_NAMESPACE, \"endpoint\"));\n", 
            "+                if (element != null) {\n", 
            "+                    TemplateFactory templateFactory = new TemplateFactory();\n", 
            "+                    String name = element.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE,\n", 
            "+                                                                      \"name\"));\n", 
            "+                    try {\n", 
            "+                        templateObject = templateFactory.createEndpointTemplate(configurationElement,\n", 
            "+                                                                                new Properties());\n", 
            "+                    } catch (Exception e) {\n", 
            "+                        String msg = \"Endpoint Template: \" + name + \"configuration cannot be built \" +\n", 
            "+                                     \"for Synapse Library artifact : \" + LibraryArtifact.this.name;\n", 
            "+//                        handleConfigurationError(SynapseConstants.FAIL_SAFE_MODE_TEMPLATES, msg, e);\n", 
            "+                        throw new SynapseArtifactDeploymentException(msg,e);\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            }\n", 
            "+            return templateObject;\n", 
            "+        }\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    public static class Dependency {\n", 
            "+\n", 
            "+        private String name;\n", 
            "+        boolean markAsResolved = false;\n", 
            "+\n", 
            "+        public Dependency(String  name) {\n", 
            "+            this.name = name;\n", 
            "+        }\n", 
            "+\n", 
            "+        public String getName() {\n", 
            "+            return name;\n", 
            "+        }\n", 
            "+\n", 
            "+        public boolean resolveWith(LibraryArtifact artifact) {\n", 
            "+            return markAsResolved == name.equals(artifact.name);\n", 
            "+        }\n", 
            "+\n", 
            "+        public boolean isResolved() {\n", 
            "+            return markAsResolved;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/libraries/model/LibraryArtifact.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/libraries/model/LibraryArtifact.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-31,11 +31,17", 
          "lines": [
            " import org.apache.axis2.format.PlainTextBuilder;\r\n", 
            " import org.apache.axis2.phaseresolver.PhaseException;\r\n", 
            " import org.apache.axis2.phaseresolver.PhaseMetadata;\r\n", 
            "+import org.apache.commons.io.FileUtils;\r\n", 
            "+import org.apache.commons.io.FilenameUtils;\r\n", 
            " import org.apache.commons.logging.Log;\r\n", 
            " import org.apache.commons.logging.LogFactory;\r\n", 
            " import org.apache.synapse.commons.datasource.DataSourceRepositoryHolder;\r\n", 
            " import org.apache.synapse.commons.util.RMIRegistryController;\r\n", 
            " import org.apache.synapse.config.*;\r\n", 
            "+import org.apache.synapse.libraries.imports.SynapseImport;\r\n", 
            "+import org.apache.synapse.libraries.model.Library;\r\n", 
            "+import org.apache.synapse.libraries.util.LibDeployerConstants;\r\n", 
            "+import org.apache.synapse.libraries.util.LibDeployerUtils;\r\n", 
            " import org.apache.synapse.securevault.SecurityConstants;\r\n", 
            " import org.apache.synapse.securevault.secret.SecretCallbackHandler;\r\n", 
            " import org.apache.synapse.commons.datasource.DataSourceInformationRepository;\r\n"
          ]
        }, 
        {
          "locn": "-51,6 +57,7", 
          "lines": [
            " import org.apache.synapse.util.xpath.ext.SynapseXpathVariableResolver;\r\n", 
            " import org.apache.synapse.util.xpath.ext.XpathExtensionUtil;\r\n", 
            " \r\n", 
            "+import java.io.File;\r\n", 
            " import java.util.*;\r\n", 
            " \r\n", 
            " /**\r\n"
          ]
        }, 
        {
          "locn": "-205,7 +212,43", 
          "lines": [
            " \r\n", 
            "     }\r\n", 
            " \r\n", 
            "+    private void initSynapseLibraries(SynapseConfiguration synapseConfig, String root) {\r\n", 
            "+        File synLibDir = new File(root, \"repository\" + File.separator +\"conf\" +\r\n", 
            "+                                        File.separator +\"synapse-libs\");\r\n", 
            "+        if (synLibDir.exists()) {\r\n", 
            "+            if (log.isDebugEnabled()) {\r\n", 
            "+                log.debug(\"Loading Synapse Libraries from :\" + synLibDir.getPath());\r\n", 
            "+            }\r\n", 
            " \r\n", 
            "+            Iterator synLibFile = FileUtils.iterateFiles(synLibDir, new String[]{LibDeployerConstants.SYNAPSE_LIB_FORMAT}, false);\r\n", 
            "+            while (synLibFile.hasNext()) {\r\n", 
            "+                File file = (File) synLibFile.next();\r\n", 
            "+                Library lib = LibDeployerUtils.createSynapseLibrary(FilenameUtils.normalize(file.getAbsolutePath()));\r\n", 
            "+                String libArtifactName = lib.getQName().toString();\r\n", 
            "+                //add the library to synapse Config\r\n", 
            "+                synapseConfig.addSynapseLibrary(lib.toString(), lib);\r\n", 
            "+                synapseConfig.getArtifactDeploymentStore().addArtifact(file.getAbsolutePath(),\r\n", 
            "+                                                                           libArtifactName);\r\n", 
            "+                if (log.isDebugEnabled()) {\r\n", 
            "+                    log.debug(\"Synapse Library Deployment for lib: \" + libArtifactName + \" Completed\");\r\n", 
            "+                }\r\n", 
            "+\r\n", 
            "+                //each time a library is deployed we check with available imports  and\r\n", 
            "+                //if necessary (ie:- relevant import is available) load the libraries\r\n", 
            "+                SynapseImport synImport = synapseConfig.getSynapseImports().get(libArtifactName);\r\n", 
            "+                if (synImport != null) {\r\n", 
            "+                    LibDeployerUtils.loadLibArtifacts(synImport, lib);\r\n", 
            "+                    if (log.isDebugEnabled()) {\r\n", 
            "+                        log.debug(\"Loading Synapse Library: \" + libArtifactName + \" into memory for Import\");\r\n", 
            "+                    }\r\n", 
            "+\r\n", 
            "+                }\r\n", 
            "+            }\r\n", 
            "+        }\r\n", 
            "+\r\n", 
            "+    }\r\n", 
            "+\r\n", 
            "+\r\n", 
            "     /**\r\n", 
            "      * {@inheritDoc}\r\n", 
            "      */\r\n"
          ]
        }, 
        {
          "locn": "-470,6 +513,7", 
          "lines": [
            "             synapseConfiguration = SynapseConfigurationBuilder.getDefaultConfiguration();\r\n", 
            "         }\r\n", 
            " \r\n", 
            "+        initSynapseLibraries(synapseConfiguration, serverConfigurationInformation.getSynapseHome());\r\n", 
            "         Enumeration keys = properties.keys();\r\n", 
            "         while (keys.hasMoreElements()) {\r\n", 
            "             String key = (String) keys.nextElement();\r\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/Axis2SynapseController.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/Axis2SynapseController.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-152,7 +152,7", 
          "lines": [
            "         if (o != null && o instanceof Mediator) {\n", 
            "             return (Mediator) o;\n", 
            "         } else {\n", 
            "-            Mediator m = getConfiguration().getSequence(key);\n", 
            "+            Mediator m = getConfiguration().getSequenceTemplate(key);\n", 
            "             if (m instanceof TemplateMediator) {\n", 
            "                 TemplateMediator templateMediator = (TemplateMediator) m;\n", 
            "                 synchronized (m) {\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2MessageContext.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2MessageContext.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,256", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.deployers;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axis2.deployment.DeploymentException;\n", 
            "+import org.apache.commons.io.FileUtils;\n", 
            "+import org.apache.commons.io.FilenameUtils;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.config.xml.SynapseImportFactory;\n", 
            "+import org.apache.synapse.libraries.imports.SynapseImport;\n", 
            "+import org.apache.synapse.libraries.model.Library;\n", 
            "+import org.apache.synapse.libraries.util.LibDeployerUtils;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+import java.io.File;\n", 
            "+import java.io.IOException;\n", 
            "+import java.util.Properties;\n", 
            "+\n", 
            "+public class ImportDeployer extends AbstractSynapseArtifactDeployer {\n", 
            "+\n", 
            "+    private static Log log = LogFactory.getLog(ImportDeployer.class);\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public String deploySynapseArtifact(OMElement artifactConfig, String fileName,\n", 
            "+                                        Properties properties) {\n", 
            "+\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Synapse Import Deployment from file : \" + fileName + \" : Started\");\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            SynapseImport synImport = SynapseImportFactory.createImport(artifactConfig, properties);\n", 
            "+            String synImportQualfiedName = LibDeployerUtils.getQualifiedName(synImport);\n", 
            "+\n", 
            "+            SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);\n", 
            "+\n", 
            "+            if (existingImport != null) {\n", 
            "+                //a synapse import with the same name (name + version) already exists\n", 
            "+                //we should not allow multiple such imports\n", 
            "+                log.warn(\"Synapse Import with the name : \" + synImportQualfiedName + \" already exists! \" +\n", 
            "+                         \"Could not load multiple Imports of same type.\");\n", 
            "+                String backedUp = backupFile(new File(fileName));\n", 
            "+                log.info(\"Synapse Import with the name : \" + synImportQualfiedName + \" is now backed up in : \"\n", 
            "+                         + backedUp);\n", 
            "+                return null;\n", 
            "+            } else {\n", 
            "+                if (synImport != null) {\n", 
            "+                    synImport.setFileName((new File(fileName)).getName());\n", 
            "+                    getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);\n", 
            "+                    //get corresponding library for loading imports if available\n", 
            "+                    Library synLib = getSynapseConfiguration().getSynapseLibraries()\n", 
            "+                            .get(synImportQualfiedName);\n", 
            "+                    if (synLib != null) {\n", 
            "+                        LibDeployerUtils.loadLibArtifacts(synImport, synLib);\n", 
            "+                    }\n", 
            "+                    log.info(\"Synapse Library Import named '\" + synImportQualfiedName +\n", 
            "+                             \" has been deployed from file : \"\n", 
            "+                             + fileName);\n", 
            "+                    return synImportQualfiedName;\n", 
            "+                } else {\n", 
            "+                    handleSynapseArtifactDeploymentError(\"Synapse Import Deployment Failed. \" +\n", 
            "+                                                         \"The artifact described in the file \" +\n", 
            "+                                                         fileName + \" is not a valid import\");\n", 
            "+                }\n", 
            "+            }\n", 
            "+        } catch (Exception e) {\n", 
            "+            handleSynapseArtifactDeploymentError(\n", 
            "+                    \"Sequence Deployment from the file : \" + fileName + \" : Failed.\", e);\n", 
            "+        }\n", 
            "+\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public String updateSynapseArtifact(OMElement artifactConfig, String fileName,\n", 
            "+                                        String existingArtifactName, Properties properties) {\n", 
            "+\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Synapse Import Deployment from file : \" + fileName + \" : Started\");\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            SynapseImport synImport = SynapseImportFactory.createImport(artifactConfig, properties);\n", 
            "+            String synImportQualfiedName = LibDeployerUtils.getQualifiedName(synImport);\n", 
            "+\n", 
            "+            if (synImport == null) {\n", 
            "+                handleSynapseArtifactDeploymentError(\"Synapse Import update failed. The artifact \" +\n", 
            "+                                                     \"defined in the file: \" + fileName + \" is not a valid import.\");\n", 
            "+                return null;\n", 
            "+            }\n", 
            "+\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Synapse Import: \" + synImportQualfiedName + \" has been built from the file: \" + fileName);\n", 
            "+            }\n", 
            "+\n", 
            "+            if (existingArtifactName.equals(synImportQualfiedName)) {\n", 
            "+                //normal update ,import Qualified Name(lib name + version) has not changed\n", 
            "+                synImport.setFileName((new File(fileName)).getName());\n", 
            "+                getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);\n", 
            "+                //get corresponding library for loading imports if available\n", 
            "+                Library synLib = getSynapseConfiguration().getSynapseLibraries()\n", 
            "+                        .get(synImportQualfiedName);\n", 
            "+                if (synLib != null) {\n", 
            "+                    //this is a important step -> we need to unload what ever the components loaded previously\n", 
            "+                    //then reload\n", 
            "+                    synLib.unLoadLibrary();\n", 
            "+                    LibDeployerUtils.loadLibArtifacts(synImport, synLib);\n", 
            "+                }\n", 
            "+                log.info(\"Synapse Library Import named '\" + synImportQualfiedName +\n", 
            "+                         \" has been deployed from file : \"\n", 
            "+                         + fileName);\n", 
            "+            } else {\n", 
            "+                //when updating ,import Qualified Name has been changed !!\n", 
            "+                //check for any other import with the same name\n", 
            "+                SynapseImport existingImport = getSynapseConfiguration().getSynapseImports().get(synImportQualfiedName);\n", 
            "+                if (existingImport != null) {\n", 
            "+                    //a synapse import with the same name (name + version) already exists\n", 
            "+                    //we should not allow multiple such imports\n", 
            "+                    log.warn(\"Synapse Import with the name : \" + synImportQualfiedName + \" already exists! \" +\n", 
            "+                             \"Could not load multiple Imports of same type.\");\n", 
            "+                    String backedUp = backupFile(new File(fileName));\n", 
            "+                    log.info(\"Synapse Import with the name : \" + synImportQualfiedName + \" is now backed up in : \"\n", 
            "+                             + backedUp);\n", 
            "+                    return null;\n", 
            "+                }else {\n", 
            "+                    synImport.setFileName((new File(fileName)).getName());\n", 
            "+                    getSynapseConfiguration().addSynapseImport(synImportQualfiedName, synImport);\n", 
            "+                    //get corresponding library for loading imports if available\n", 
            "+                    Library synLib = getSynapseConfiguration().getSynapseLibraries()\n", 
            "+                            .get(synImportQualfiedName);\n", 
            "+                    //this is a important step -> we need to unload what ever the components loaded previously\n", 
            "+                    synLib.unLoadLibrary();\n", 
            "+                    //then reload\n", 
            "+                    if (synLib != null) {\n", 
            "+                        LibDeployerUtils.loadLibArtifacts(synImport, synLib);\n", 
            "+                    }\n", 
            "+                    log.info(\"Synapse Library Import named '\" + synImportQualfiedName +\n", 
            "+                             \" has been deployed from file : \"\n", 
            "+                             + fileName);\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+            log.info(\"Synapse Import: \" + synImportQualfiedName + \" has been updated from the file: \" + fileName);\n", 
            "+\n", 
            "+            waitForCompletion(); // Give some time for worker threads to release the old sequence\n", 
            "+            return synImportQualfiedName;\n", 
            "+\n", 
            "+        } catch (Exception e) {\n", 
            "+            handleSynapseArtifactDeploymentError(\"Error while updating the Synapse Import from the \" +\n", 
            "+                                                 \"file: \" + fileName);\n", 
            "+        }\n", 
            "+\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public void undeploySynapseArtifact(String artifactName) {\n", 
            "+\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Undeployment of the Synapse Import named : \"\n", 
            "+                      + artifactName + \" : Started\");\n", 
            "+        }\n", 
            "+        try {\n", 
            "+            SynapseImport undeployingImport = getSynapseConfiguration().getSynapseImports().get(artifactName);\n", 
            "+            if (undeployingImport != null) {\n", 
            "+                getSynapseConfiguration().removeSynapseImport(artifactName);\n", 
            "+                //get corresponding library for un-loading this import\n", 
            "+                Library synLib = getSynapseConfiguration().getSynapseLibraries().get(artifactName);\n", 
            "+                if (synLib != null) {\n", 
            "+                    //this is a important step -> we need to unload what ever the components loaded thru this import\n", 
            "+                    synLib.unLoadLibrary();\n", 
            "+                }\n", 
            "+                log.info(\"Synapse Import : \" + artifactName + \"' has been undeployed\");\n", 
            "+            } else {\n", 
            "+                log.warn(\"Synapse Import : \" + artifactName + \" has already been undeployed\");\n", 
            "+            }\n", 
            "+        } catch (Exception e) {\n", 
            "+            handleSynapseArtifactDeploymentError(\n", 
            "+                    \"Undeployement of Synapse Import named : \" + artifactName + \" : Failed\", e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public void restoreSynapseArtifact(String artifactName) {\n", 
            "+        //TODO implement --> need to implement the serializer\n", 
            "+\n", 
            "+/*\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Restoring the Sequence with name : \" + artifactName + \" : Started\");\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            SequenceMediator seq\n", 
            "+                    = getSynapseConfiguration().getDefinedSequences().get(artifactName);\n", 
            "+            OMElement seqElem = MediatorSerializerFinder.getInstance().getSerializer(seq).\n", 
            "+                    serializeMediator(null, seq);\n", 
            "+            if (seq.getFileName() != null) {\n", 
            "+                String fileName = getServerConfigurationInformation().getSynapseXMLLocation()\n", 
            "+                                  + File.separator + MultiXMLConfigurationBuilder.SEQUENCES_DIR\n", 
            "+                                  + File.separator + seq.getFileName();\n", 
            "+                writeToFile(seqElem, fileName);\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Restoring the Sequence with name : \" + artifactName + \" : Completed\");\n", 
            "+                }\n", 
            "+                log.info(\"Sequence named '\" + artifactName + \"' has been restored\");\n", 
            "+            } else {\n", 
            "+                handleSynapseArtifactDeploymentError(\"Couldn't restore the sequence named '\"\n", 
            "+                                                     + artifactName + \"', filename cannot be found\");\n", 
            "+            }\n", 
            "+        } catch (Exception e) {\n", 
            "+            handleSynapseArtifactDeploymentError(\n", 
            "+                    \"Restoring of the sequence named '\" + artifactName + \"' has failed\", e);\n", 
            "+        }\n", 
            "+*/\n", 
            "+    }\n", 
            "+\n", 
            "+    private String backupFile(File file) throws DeploymentException {\n", 
            "+        String filePath = FilenameUtils.normalize(file.getAbsolutePath());\n", 
            "+\n", 
            "+        String backupFilePath = filePath + \".back\";\n", 
            "+        int backupIndex = 0;\n", 
            "+        while (backupIndex >= 0) {\n", 
            "+            if (new File(backupFilePath).exists()) {\n", 
            "+                backupIndex++;\n", 
            "+                backupFilePath = filePath + \".\" + backupIndex + \".back\";\n", 
            "+            } else {\n", 
            "+                backupIndex = -1;\n", 
            "+                try {\n", 
            "+                    FileUtils.moveFile(file, new File(backupFilePath));\n", 
            "+                } catch (IOException e) {\n", 
            "+                    handleSynapseArtifactDeploymentError(\"Error while backing up the artifact: \" +\n", 
            "+                                                         file.getName(), e);\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return backupFilePath;\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/deployers/ImportDeployer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/deployers/ImportDeployer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,217", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.deployers;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axiom.om.OMException;\n", 
            "+import org.apache.axis2.deployment.DeploymentException;\n", 
            "+import org.apache.axis2.deployment.repository.util.DeploymentFileData;\n", 
            "+import org.apache.commons.io.FilenameUtils;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.ServerState;\n", 
            "+import org.apache.synapse.libraries.imports.SynapseImport;\n", 
            "+import org.apache.synapse.libraries.model.Library;\n", 
            "+import org.apache.synapse.libraries.model.SynapseLibrary;\n", 
            "+import org.apache.synapse.libraries.util.LibDeployerUtils;\n", 
            "+\n", 
            "+import java.io.File;\n", 
            "+import java.io.IOException;\n", 
            "+import java.util.Properties;\n", 
            "+\n", 
            "+public class LibraryArtifactDeployer extends AbstractSynapseArtifactDeployer {\n", 
            "+    private static final Log log = LogFactory.getLog(LibraryArtifactDeployer.class);\n", 
            "+\n", 
            "+    public void deploy(DeploymentFileData deploymentFileData) throws DeploymentException {\n", 
            "+        String libFilePath = FilenameUtils.normalize(deploymentFileData.getAbsolutePath());\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Deployment of the synapse library artifact from file : \" + libFilePath + \" : STARTED\");\n", 
            "+        }\n", 
            "+\n", 
            "+        if (getServerContextInformation().getServerState() != ServerState.STARTED) {\n", 
            "+            // synapse server has not yet being started\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Skipped the library artifact deployment (since the Synapse \" +\n", 
            "+                          \"server doesn't seem to be started yet), from file : \"\n", 
            "+                          + deploymentFileData.getAbsolutePath());\n", 
            "+            }\n", 
            "+            return;\n", 
            "+        }\n", 
            "+        try {\n", 
            "+            SynapseArtifactDeploymentStore deploymentStore = getSynapseConfiguration().getArtifactDeploymentStore();\n", 
            "+\n", 
            "+            Library lib = LibDeployerUtils.createSynapseLibrary(libFilePath);\n", 
            "+            String libArtifactName = lib.getQName().toString();\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Created the Synapse Library : \" + libArtifactName + \"  from : \" + libFilePath);\n", 
            "+            }\n", 
            "+\n", 
            "+            if (deploymentStore.isUpdatingArtifact(libFilePath)) {\n", 
            "+\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Updating Library artifact detected with filename : \" + libFilePath);\n", 
            "+                }\n", 
            "+                // this is an hot-update case\n", 
            "+                String existingArtifactName\n", 
            "+                        = deploymentStore.getUpdatingArtifactWithFileName(libFilePath);\n", 
            "+                deploymentStore.removeUpdatingArtifact(libFilePath);\n", 
            "+                undeploySynapseArtifact(existingArtifactName);\n", 
            "+\n", 
            "+                //deploy from beginning\n", 
            "+                //add the library to synapse Config\n", 
            "+                completeDeployment(lib, libArtifactName);\n", 
            "+\n", 
            "+            } else {\n", 
            "+                // new artifact hot-deployment case\n", 
            "+                try {\n", 
            "+                    //add the library to synapse Config\n", 
            "+                    completeDeployment(lib, libArtifactName);\n", 
            "+                } catch (SynapseArtifactDeploymentException sade) {\n", 
            "+                    log.error(\"Deployment of the Synapse Artifact from file : \"\n", 
            "+                              + libFilePath + \" : Failed!\", sade);\n", 
            "+                    /*log.info(\"The file has been backed up into : \"\n", 
            "+                             + backupFile(deploymentFileData.getFile()));*/\n", 
            "+                }\n", 
            "+            }\n", 
            "+            if (libArtifactName != null) {\n", 
            "+                deploymentStore.addArtifact(libFilePath, libArtifactName);\n", 
            "+            }\n", 
            "+\n", 
            "+            log.info(\"Synapse Library named '\" + lib.toString()\n", 
            "+                     + \"' has been deployed from file : \" + libFilePath);\n", 
            "+\n", 
            "+        } catch (IOException ex) {\n", 
            "+            handleDeploymentError(\"Deployment of synapse artifact failed. Error reading \"\n", 
            "+                                  + libFilePath + \" : \" + ex.getMessage(), ex);\n", 
            "+        } catch (Exception ex) {\n", 
            "+            handleDeploymentError(\"Deployment of synapse artifact failed for synapse libray at : \"\n", 
            "+                                  + libFilePath + \" : \" + ex.getMessage(), ex);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Deployment of the synapse artifact from file : \"\n", 
            "+                      + libFilePath + \" : COMPLETED\");\n", 
            "+        }\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    private void completeDeployment(Library lib, String libArtifactName) throws DeploymentException {\n", 
            "+        getSynapseConfiguration().addSynapseLibrary(lib.getQName().toString(), lib);\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Synapse Library Deployment for lib: \" + libArtifactName + \" Completed\");\n", 
            "+        }\n", 
            "+\n", 
            "+        //each time a library is deployed we check with available imports  and\n", 
            "+        //if necessary (ie:- relevant import is available) load the libraries\n", 
            "+        SynapseImport synImport = getSynapseConfiguration().getSynapseImports().get(libArtifactName);\n", 
            "+\n", 
            "+        if (synImport != null) {\n", 
            "+            LibDeployerUtils.loadLibArtifacts(synImport, lib);\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Loading Synapse Library: \" + libArtifactName + \" into memory for Import\");\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public void undeploy(String fileName) throws DeploymentException {\n", 
            "+        fileName = FilenameUtils.normalize(fileName);\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"UnDeployment of the synapse library from file : \"\n", 
            "+                      + fileName + \" : STARTED\");\n", 
            "+        }\n", 
            "+\n", 
            "+        SynapseArtifactDeploymentStore deploymentStore =\n", 
            "+                getSynapseConfiguration().getArtifactDeploymentStore();\n", 
            "+\n", 
            "+        if (deploymentStore.containsFileName(fileName)) {\n", 
            "+            File undeployingFile = new File(fileName);\n", 
            "+            // axis2 treats Hot-Update as (Undeployment + deployment), where synapse needs to\n", 
            "+            // differentiate the Hot-Update from the above two, since it needs some validations for\n", 
            "+            // a real undeployment. Also this makes sure a zero downtime of the synapse artifacts\n", 
            "+            // which are being Hot-deployed\n", 
            "+            if (undeployingFile.exists()) {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Marking artifact as updating from file : \" + fileName);\n", 
            "+                }\n", 
            "+                // if the file exists, which means it has been updated and is a Hot-Update case\n", 
            "+                if (!deploymentStore.isRestoredFile(fileName)) {\n", 
            "+                    deploymentStore.addUpdatingArtifact(\n", 
            "+                            fileName, deploymentStore.getArtifactNameForFile(fileName));\n", 
            "+                    deploymentStore.removeArtifactWithFileName(fileName);\n", 
            "+                }\n", 
            "+            } else {\n", 
            "+                // if the file doesn't exists then it is an actual undeployment\n", 
            "+                String artifactName = deploymentStore.getArtifactNameForFile(fileName);\n", 
            "+                try {\n", 
            "+                    //do un-deployment\n", 
            "+                    undeploySynapseArtifact(artifactName);\n", 
            "+\n", 
            "+                    deploymentStore.removeArtifactWithFileName(fileName);\n", 
            "+                    log.info(\"Synapse Library named '\" + artifactName + \"' has been undeployed\");\n", 
            "+                } catch (SynapseArtifactDeploymentException sade) {\n", 
            "+                    log.error(\"Unable to undeploy the synapse library artifact from file : \" + fileName, sade);\n", 
            "+                }\n", 
            "+            }\n", 
            "+        } else {\n", 
            "+            String msg = \"Artifact representing the filename \"\n", 
            "+                         + fileName + \" is not deployed on Synapse\";\n", 
            "+            log.error(msg);\n", 
            "+            throw new DeploymentException(msg);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"UnDeployment of the synapse library artifact from file : \"\n", 
            "+                      + fileName + \" : COMPLETED\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public void undeploySynapseArtifact(String artifactName) {\n", 
            "+        //get Old Lib config\n", 
            "+        Library existingLib = null;\n", 
            "+        try {\n", 
            "+            existingLib = getSynapseConfiguration().getSynapseLibraries().get(artifactName);\n", 
            "+            existingLib.unLoadLibrary();\n", 
            "+            getSynapseConfiguration().removeSynapseLibrary(artifactName);\n", 
            "+        } catch (DeploymentException e) {\n", 
            "+            handleDeploymentError(e.getMessage(),e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private void handleDeploymentError(String msg, Exception e){\n", 
            "+        log.error(msg, e);\n", 
            "+    }\n", 
            "+\n", 
            "+    //avoid implementing any of the below methods since these are unusable in this library deployment\n", 
            "+    // scenario . we just want to inherit some of the methods from  AbstractSynapseArtifactDeployer\n", 
            "+    public void setDirectory(String directory) {\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setExtension(String extension) {\n", 
            "+    }\n", 
            "+\n", 
            "+    public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void restoreSynapseArtifact(String artifactName) {\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/deployers/LibraryArtifactDeployer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/deployers/LibraryArtifactDeployer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-147,6 +147,7", 
          "lines": [
            "                             org.apache.synapse.endpoints.*,\n", 
            "                             org.apache.synapse.eventing.*,\n", 
            "                             org.apache.synapse.mediators.*,\n", 
            "+                            org.apache.synapse.libraries.*,\n", 
            "                             org.apache.synapse.message.*,\n", 
            "                             org.apache.synapse.metrics.*,\n", 
            "                             org.apache.synapse.registry.*,\n"
          ]
        }
      ], 
      "to": "java/modules/core/pom.xml", 
      "from": "java/modules/core/pom.xml"
    }
  ], 
  "id": "1237557"
}