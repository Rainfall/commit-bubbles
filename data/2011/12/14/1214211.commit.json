{
  "when": "2011-12-14T07:24:36-05:00", 
  "message": "REST API support and some improvements to the integration test framework", 
  "who": "hiranya", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-0,0 +1,427", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+import org.apache.axiom.util.UIDGenerator;\n", 
            "+import org.apache.axis2.Constants;\n", 
            "+import org.apache.http.HttpHeaders;\n", 
            "+import org.apache.http.protocol.HTTP;\n", 
            "+import org.apache.synapse.ManagedLifecycle;\n", 
            "+import org.apache.synapse.Mediator;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.core.SynapseEnvironment;\n", 
            "+import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            "+import org.apache.synapse.core.axis2.Axis2Sender;\n", 
            "+import org.apache.synapse.mediators.MediatorFaultHandler;\n", 
            "+import org.apache.synapse.mediators.base.SequenceMediator;\n", 
            "+import org.apache.synapse.rest.dispatch.DispatcherHelper;\n", 
            "+import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            "+\n", 
            "+import java.io.UnsupportedEncodingException;\n", 
            "+import java.net.URLDecoder;\n", 
            "+import java.util.HashSet;\n", 
            "+import java.util.Map;\n", 
            "+import java.util.Set;\n", 
            "+\n", 
            "+public class Resource extends AbstractRESTProcessor implements ManagedLifecycle {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * List of HTTP methods applicable on this method. Empty list means all methods\n", 
            "+     * are applicable.\n", 
            "+     */\n", 
            "+    private Set<String> methods = new HashSet<String>(4);\n", 
            "+\n", 
            "+    private String contentType;\n", 
            "+\n", 
            "+    private String userAgent;\n", 
            "+\n", 
            "+    private int protocol = RESTConstants.PROTOCOL_HTTP_AND_HTTPS;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * In-lined sequence to be executed upon receiving messages\n", 
            "+     */\n", 
            "+    private SequenceMediator inSequence;\n", 
            "+\n", 
            "+    private SequenceMediator outSequence;\n", 
            "+\n", 
            "+    private SequenceMediator faultSequence;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Identifier of the sequence to be executed upon receiving a message\n", 
            "+     */\n", 
            "+    private String inSequenceKey;\n", 
            "+\n", 
            "+    private String outSequenceKey;\n", 
            "+\n", 
            "+    private String faultSequenceKey;\n", 
            "+\n", 
            "+    /**\n", 
            "+     * DispatcherHelper instance which is  used to determine whether a particular resource\n", 
            "+     * should be dispatched to this resource or not\n", 
            "+     */\n", 
            "+    private DispatcherHelper dispatcherHelper;\n", 
            "+\n", 
            "+    public Resource() {\n", 
            "+        super(UIDGenerator.generateUID());\n", 
            "+    }\n", 
            "+\n", 
            "+    protected String getName() {\n", 
            "+        return name;\n", 
            "+    }\n", 
            "+\n", 
            "+    public SequenceMediator getInSequence() {\n", 
            "+        return inSequence;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setInSequence(SequenceMediator inSequence) {\n", 
            "+        this.inSequence = inSequence;\n", 
            "+    }\n", 
            "+\n", 
            "+    public SequenceMediator getOutSequence() {\n", 
            "+        return outSequence;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setOutSequence(SequenceMediator outSequence) {\n", 
            "+        this.outSequence = outSequence;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getInSequenceKey() {\n", 
            "+        return inSequenceKey;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setInSequenceKey(String inSequenceKey) {\n", 
            "+        this.inSequenceKey = inSequenceKey;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getOutSequenceKey() {\n", 
            "+        return outSequenceKey;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setOutSequenceKey(String outSequenceKey) {\n", 
            "+        this.outSequenceKey = outSequenceKey;\n", 
            "+    }\n", 
            "+\n", 
            "+    public SequenceMediator getFaultSequence() {\n", 
            "+        return faultSequence;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setFaultSequence(SequenceMediator faultSequence) {\n", 
            "+        this.faultSequence = faultSequence;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getFaultSequenceKey() {\n", 
            "+        return faultSequenceKey;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setFaultSequenceKey(String faultSequenceKey) {\n", 
            "+        this.faultSequenceKey = faultSequenceKey;\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean addMethod(String method) {\n", 
            "+        for (RESTConstants.METHODS allowedMethod : RESTConstants.METHODS.values()) {\n", 
            "+            if (allowedMethod.name().equals(method)) {\n", 
            "+                methods.add(method);\n", 
            "+                return true;\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return false;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String[] getMethods() {\n", 
            "+        return methods.toArray(new String[methods.size()]);\n", 
            "+    }\n", 
            "+\n", 
            "+    public DispatcherHelper getDispatcherHelper() {\n", 
            "+        return dispatcherHelper;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setDispatcherHelper(DispatcherHelper dispatcherHelper) {\n", 
            "+        this.dispatcherHelper = dispatcherHelper;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getContentType() {\n", 
            "+        return contentType;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setContentType(String contentType) {\n", 
            "+        if (contentType.indexOf('/') == -1 || contentType.split(\"/\").length != 2) {\n", 
            "+            throw new SynapseException(\"Invalid content type: \" + contentType);\n", 
            "+        }\n", 
            "+        this.contentType = contentType;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getUserAgent() {\n", 
            "+        return userAgent;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setUserAgent(String userAgent) {\n", 
            "+        this.userAgent = userAgent;\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getProtocol() {\n", 
            "+        return protocol;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setProtocol(int protocol) {\n", 
            "+        this.protocol = protocol;\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    boolean canProcess(MessageContext synCtx) {\n", 
            "+        if (synCtx.isResponse()) {\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+\n", 
            "+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).\n", 
            "+                getAxis2MessageContext();\n", 
            "+        if (protocol == RESTConstants.PROTOCOL_HTTP_ONLY &&\n", 
            "+                !Constants.TRANSPORT_HTTP.equals(msgCtx.getIncomingTransportName())) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Protocol information does not match - Expected HTTP\");\n", 
            "+            }\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+\n", 
            "+        if (protocol == RESTConstants.PROTOCOL_HTTPS_ONLY &&\n", 
            "+                !Constants.TRANSPORT_HTTPS.equals(msgCtx.getIncomingTransportName())) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Protocol information does not match - Expected HTTPS\");\n", 
            "+            }\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+\n", 
            "+        String method = (String) msgCtx.getProperty(Constants.Configuration.HTTP_METHOD);\n", 
            "+        synCtx.setProperty(RESTConstants.REST_METHOD, method);\n", 
            "+\n", 
            "+        if (RESTConstants.METHOD_OPTIONS.equals(method)) {\n", 
            "+            return true; // OPTIONS requests are always welcome\n", 
            "+        } else if (!methods.isEmpty()) {\n", 
            "+            if (!methods.contains(method)) {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"HTTP method does not match\");\n", 
            "+                }\n", 
            "+                return false;\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        Map transportHeaders = (Map) msgCtx.getProperty(\n", 
            "+                org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);\n", 
            "+        if ((contentType != null || userAgent != null) && transportHeaders == null) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Transport headers not available on the message\");\n", 
            "+            }\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+\n", 
            "+        boolean hasPayload = !Boolean.TRUE.equals(msgCtx.getProperty(NhttpConstants.NO_ENTITY_BODY));\n", 
            "+        if (contentType != null && hasPayload) {\n", 
            "+            String type = (String) transportHeaders.get(HTTP.CONTENT_TYPE);\n", 
            "+            if (!contentType.equals(type)) {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Content type does not match - Expected: \" + contentType + \", \" +\n", 
            "+                            \"Found: \" + type);\n", 
            "+                }\n", 
            "+                return false;\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        if (userAgent != null) {\n", 
            "+            String agent = (String) transportHeaders.get(HTTP.USER_AGENT);\n", 
            "+            if (agent == null || !agent.matches(this.userAgent)) {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"User agent does not match - Expected: \" + userAgent + \", \" +\n", 
            "+                            \"Found: \" + agent);\n", 
            "+                }\n", 
            "+                return false;\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        return true;\n", 
            "+    }\n", 
            "+\n", 
            "+    void process(MessageContext synCtx) {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Processing message with ID: \" + synCtx.getMessageID() + \" through the \" +\n", 
            "+                    \"resource: \" + name);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (!synCtx.isResponse()) {\n", 
            "+            String method = (String) synCtx.getProperty(RESTConstants.REST_METHOD);\n", 
            "+            if (RESTConstants.METHOD_OPTIONS.equals(method) && sendOptions(synCtx)) {\n", 
            "+                return;\n", 
            "+            }\n", 
            "+\n", 
            "+            synCtx.setProperty(RESTConstants.SYNAPSE_RESOURCE, name);\n", 
            "+            String path = RESTUtils.getFullRequestPath(synCtx);\n", 
            "+\n", 
            "+            int queryIndex = path.indexOf('?');\n", 
            "+            if (queryIndex != -1) {\n", 
            "+                String query = path.substring(queryIndex + 1);\n", 
            "+                String[] entries = query.split(\"&\");\n", 
            "+                for (String entry : entries) {\n", 
            "+                    int index = entry.indexOf('=');\n", 
            "+                    if (index != -1) {\n", 
            "+                        try {\n", 
            "+                            String name = entry.substring(0, index);\n", 
            "+                            String value = URLDecoder.decode(entry.substring(index + 1),\n", 
            "+                                    RESTConstants.DEFAULT_ENCODING);\n", 
            "+                            synCtx.setProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + name, value);\n", 
            "+                        } catch (UnsupportedEncodingException ignored) {\n", 
            "+\n", 
            "+                        }\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        SequenceMediator sequence = synCtx.isResponse() ? outSequence : inSequence;\n", 
            "+        if (sequence != null) {\n", 
            "+            registerFaultHandler(synCtx);\n", 
            "+            sequence.mediate(synCtx);\n", 
            "+            return;\n", 
            "+        }\n", 
            "+\n", 
            "+        String sequenceKey = synCtx.isResponse() ? outSequenceKey : inSequenceKey;\n", 
            "+        if (sequenceKey != null) {\n", 
            "+            registerFaultHandler(synCtx);\n", 
            "+            Mediator referredSequence = synCtx.getSequence(sequenceKey);\n", 
            "+            if (referredSequence != null) {\n", 
            "+                referredSequence.mediate(synCtx);\n", 
            "+            } else {\n", 
            "+                throw new SynapseException(\"Specified sequence: \" + sequenceKey + \" cannot \" +\n", 
            "+                        \"be found\");\n", 
            "+            }\n", 
            "+            return;\n", 
            "+        }\n", 
            "+\n", 
            "+        // Neither a sequence nor a sequence key has been specified. If this message is a\n", 
            "+        // response, simply send it back to the client.\n", 
            "+        if (synCtx.isResponse()) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"No out-sequence configured. Sending the response back.\");\n", 
            "+            }\n", 
            "+            registerFaultHandler(synCtx);\n", 
            "+            Axis2Sender.sendBack(synCtx);\n", 
            "+        } else if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"No in-sequence configured. Dropping the request.\");\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private void registerFaultHandler(MessageContext synCtx) {\n", 
            "+        if (faultSequence != null) {\n", 
            "+            synCtx.pushFaultHandler(new MediatorFaultHandler(faultSequence));\n", 
            "+        } else if (faultSequenceKey != null) {\n", 
            "+            Mediator faultSequence = synCtx.getSequence(faultSequenceKey);\n", 
            "+            if (faultSequence != null) {\n", 
            "+                synCtx.pushFaultHandler(new MediatorFaultHandler(faultSequence));\n", 
            "+            } else {\n", 
            "+                synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));\n", 
            "+            }\n", 
            "+        } else {\n", 
            "+            synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private boolean sendOptions(MessageContext synCtx) {\n", 
            "+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).\n", 
            "+                getAxis2MessageContext();\n", 
            "+        Map<String,String> transportHeaders = (Map<String,String>) msgCtx.getProperty(\n", 
            "+                org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);\n", 
            "+\n", 
            "+        if (methods.contains(RESTConstants.METHOD_OPTIONS)) {\n", 
            "+            // Resource should mediate the OPTIONS request\n", 
            "+            String maxForwardsHeader = transportHeaders.get(HttpHeaders.MAX_FORWARDS);\n", 
            "+            if (maxForwardsHeader != null) {\n", 
            "+                int maxForwards = Integer.parseInt(maxForwardsHeader);\n", 
            "+                if (maxForwards == 0) {\n", 
            "+                    // Resource should respond to the OPTIONS request\n", 
            "+                    synCtx.setResponse(true);\n", 
            "+                    synCtx.setTo(null);\n", 
            "+                    transportHeaders.put(HttpHeaders.ALLOW, getSupportedMethods());\n", 
            "+                    Axis2Sender.sendBack(synCtx);\n", 
            "+                    return true;\n", 
            "+                } else {\n", 
            "+                    transportHeaders.put(HttpHeaders.MAX_FORWARDS, String.valueOf(maxForwards - 1));\n", 
            "+                }\n", 
            "+            }\n", 
            "+            return false;\n", 
            "+\n", 
            "+        } else {\n", 
            "+            // Resource should respond to the OPTIONS request\n", 
            "+            synCtx.setResponse(true);\n", 
            "+            synCtx.setTo(null);\n", 
            "+            transportHeaders.put(HttpHeaders.ALLOW, getSupportedMethods());\n", 
            "+            Axis2Sender.sendBack(synCtx);\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private String getSupportedMethods() {\n", 
            "+        String value = \"\";\n", 
            "+        if (methods.isEmpty()) {\n", 
            "+            value = RESTConstants.REST_ALL_SUPPORTED_METHODS;\n", 
            "+        } else {\n", 
            "+            for (String method : methods) {\n", 
            "+                if (RESTConstants.METHOD_OPTIONS.equals(method)) {\n", 
            "+                    continue;\n", 
            "+                }\n", 
            "+\n", 
            "+                if (value.length() > 0) {\n", 
            "+                    value += \", \";\n", 
            "+                }\n", 
            "+                value += method;\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return value;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void init(SynapseEnvironment se) {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Initializing resource with ID: \" + name);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (inSequence != null) {\n", 
            "+            inSequence.init(se);\n", 
            "+        }\n", 
            "+        if (outSequence != null) {\n", 
            "+            outSequence.init(se);\n", 
            "+        }\n", 
            "+        if (faultSequence != null) {\n", 
            "+            faultSequence.init(se);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public void destroy() {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Destroying resource with ID: \" + name);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (inSequence != null && inSequence.isInitialized()) {\n", 
            "+            inSequence.destroy();\n", 
            "+        }\n", 
            "+        if (outSequence != null && outSequence.isInitialized()) {\n", 
            "+            outSequence.destroy();\n", 
            "+        }\n", 
            "+        if (faultSequence != null && faultSequence.isInitialized()) {\n", 
            "+            faultSequence.destroy();\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/Resource.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/Resource.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,48", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+public class RESTConstants {\n", 
            "+\n", 
            "+    public static enum METHODS {\n", 
            "+        GET, POST, PUT, DELETE, OPTIONS\n", 
            "+    }\n", 
            "+\n", 
            "+    public static final int PROTOCOL_HTTP_AND_HTTPS = 0;\n", 
            "+    public static final int PROTOCOL_HTTP_ONLY      = 1;\n", 
            "+    public static final int PROTOCOL_HTTPS_ONLY     = 2;\n", 
            "+\n", 
            "+    public static final String REST_FULL_REQUEST_PATH = \"REST_FULL_REQUEST_PATH\";\n", 
            "+    public static final String REST_SUB_REQUEST_PATH = \"REST_SUB_REQUEST_PATH\";\n", 
            "+    public static final String REST_METHOD = \"REST_METHOD\";\n", 
            "+    public static final String METHOD_OPTIONS = \"OPTIONS\";\n", 
            "+    public static final String REST_ALL_SUPPORTED_METHODS = \"GET, POST, PUT, DELETE\";\n", 
            "+    public static final String REST_URI_VARIABLE_PREFIX = \"uri.var.\";\n", 
            "+    public static final String REST_QUERY_PARAM_PREFIX = \"query.param.\";\n", 
            "+\n", 
            "+    public static final String SYNAPSE_RESOURCE = \"SYNAPSE_RESOURCE\";\n", 
            "+    public static final String SYNAPSE_REST_API = \"SYNAPSE_REST_API\";\n", 
            "+\n", 
            "+    public static final String REST_API_CONTEXT = \"REST_API_CONTEXT\";\n", 
            "+    public static final String REST_URL_PREFIX = \"REST_URL_PREFIX\";\n", 
            "+\n", 
            "+    public static final String DEFAULT_ENCODING = \"UTF-8\";\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/RESTConstants.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/RESTConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-72,8 +72,8", 
          "lines": [
            "     public static final QName PROXY_ELT       = new QName(SYNAPSE_NAMESPACE, \"proxy\");\n", 
            "     public static final QName EVENT_SOURCE_ELT = new QName(SYNAPSE_NAMESPACE, \"eventSource\");\n", 
            "     public static final QName MESSAGE_STORE_ELT = new QName(SYNAPSE_NAMESPACE, \"messageStore\");\n", 
            "-    public static final QName MESSAGE_PROCESSOR_ELT = new QName(SYNAPSE_NAMESPACE ,\n", 
            "-                                                                                \"messageProcessor\");\n", 
            "+    public static final QName MESSAGE_PROCESSOR_ELT = new QName(SYNAPSE_NAMESPACE, \"messageProcessor\");\n", 
            "+    public static final QName API_ELT = new QName(SYNAPSE_NAMESPACE, \"api\");\n", 
            " \n", 
            "     public static final String NULL_NAMESPACE = \"\";\n", 
            "     public static final Object QUARTZ_QNAME   =\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/XMLConfigConstants.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/XMLConfigConstants.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-29,6 +29,7", 
          "lines": [
            " import org.apache.synapse.SynapseConstants;\r\n", 
            " import org.apache.synapse.SynapseException;\r\n", 
            " import org.apache.synapse.config.xml.endpoints.TemplateSerializer;\r\n", 
            "+import org.apache.synapse.config.xml.rest.APISerializer;\r\n", 
            " import org.apache.synapse.endpoints.Template;\r\n", 
            " import org.apache.synapse.mediators.template.TemplateMediator;\r\n", 
            " import org.apache.synapse.message.processors.MessageProcessor;\r\n"
          ]
        }, 
        {
          "locn": "-43,6 +44,7", 
          "lines": [
            " import org.apache.synapse.endpoints.Endpoint;\r\n", 
            " import org.apache.synapse.eventing.SynapseEventSource;\r\n", 
            " import org.apache.synapse.mediators.base.SequenceMediator;\r\n", 
            "+import org.apache.synapse.rest.API;\r\n", 
            " \r\n", 
            " import javax.xml.namespace.QName;\r\n", 
            " import java.util.Collection;\r\n"
          ]
        }, 
        {
          "locn": "-150,6 +152,8", 
          "lines": [
            "        //Message Processors\r\n", 
            "         serializeMessageProcessors(definitions,synCfg.getMessageProcessors());\r\n", 
            " \r\n", 
            "+        serializeAPIs(definitions, synCfg.getAPIs());\r\n", 
            "+\r\n", 
            "         return definitions;\r\n", 
            "     }\r\n", 
            " \r\n"
          ]
        }, 
        {
          "locn": "-223,6 +227,14", 
          "lines": [
            "         }\r\n", 
            "     }\r\n", 
            " \r\n", 
            "+    private static void serializeAPIs(OMElement definitions,\r\n", 
            "+                                      Collection<API> apiSet) {\r\n", 
            "+        for (API api : apiSet) {\r\n", 
            "+            OMElement apiElt = APISerializer.serializeAPI(api);\r\n", 
            "+            definitions.addChild(apiElt);\r\n", 
            "+        }\r\n", 
            "+    }\r\n", 
            "+\r\n", 
            "     private static void handleException(String msg) {\r\n", 
            "         log.error(msg);\r\n", 
            "         throw new SynapseException(msg);\r\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,112", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.config.xml.rest;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMAttribute;\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.config.xml.XMLConfigConstants;\n", 
            "+import org.apache.synapse.rest.API;\n", 
            "+import org.apache.synapse.rest.Handler;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+import java.util.Iterator;\n", 
            "+\n", 
            "+public class APIFactory {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(APIFactory.class);\n", 
            "+\n", 
            "+    public static API createAPI(OMElement apiElt) {\n", 
            "+        OMAttribute nameAtt = apiElt.getAttribute(new QName(\"name\"));\n", 
            "+        if (nameAtt == null || \"\".equals(nameAtt.getAttributeValue())) {\n", 
            "+            handleException(\"Attribute 'name' is required for an API definition\");\n", 
            "+        }\n", 
            "+\n", 
            "+        OMAttribute contextAtt = apiElt.getAttribute(new QName(\"context\"));\n", 
            "+        if (contextAtt == null || \"\".equals(contextAtt.getAttributeValue())) {\n", 
            "+            handleException(\"Attribute 'context' is required for an API definition\");\n", 
            "+        }\n", 
            "+\n", 
            "+        API api = new API(nameAtt.getAttributeValue(), contextAtt.getAttributeValue());\n", 
            "+\n", 
            "+        OMAttribute hostAtt = apiElt.getAttribute(new QName(\"hostname\"));\n", 
            "+        if (hostAtt != null && !\"\".equals(hostAtt.getAttributeValue())) {\n", 
            "+            api.setHost(hostAtt.getAttributeValue());\n", 
            "+        }\n", 
            "+\n", 
            "+        OMAttribute portAtt = apiElt.getAttribute(new QName(\"port\"));\n", 
            "+        if (portAtt != null && !\"\".equals(portAtt.getAttributeValue())) {\n", 
            "+            api.setPort(Integer.parseInt(portAtt.getAttributeValue()));\n", 
            "+        }\n", 
            "+\n", 
            "+        Iterator resources = apiElt.getChildrenWithName(new QName(\n", 
            "+                XMLConfigConstants.SYNAPSE_NAMESPACE, \"resource\"));\n", 
            "+        boolean noResources = true;\n", 
            "+        while (resources.hasNext()) {\n", 
            "+            OMElement resourceElt = (OMElement) resources.next();\n", 
            "+            api.addResource(ResourceFactory.createResource(resourceElt));\n", 
            "+            noResources = false;\n", 
            "+        }\n", 
            "+\n", 
            "+        if (noResources) {\n", 
            "+            handleException(\"An API must contain at least one resource definition\");\n", 
            "+        }\n", 
            "+\n", 
            "+        OMElement handlersElt = apiElt.getFirstChildWithName(new QName(\n", 
            "+                XMLConfigConstants.SYNAPSE_NAMESPACE, \"handlers\"));\n", 
            "+        if (handlersElt != null) {\n", 
            "+            Iterator handlers = handlersElt.getChildrenWithName(new QName(\n", 
            "+                    XMLConfigConstants.SYNAPSE_NAMESPACE, \"handler\"));\n", 
            "+            while (handlers.hasNext()) {\n", 
            "+                OMElement handlerElt = (OMElement) handlers.next();\n", 
            "+                defineHandler(api, handlerElt);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        return api;\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void defineHandler(API api, OMElement handlerElt) {\n", 
            "+        String handlerClass = handlerElt.getAttributeValue(new QName(\"class\"));\n", 
            "+        if (handlerClass == null || \"\".equals(handlerClass)) {\n", 
            "+            handleException(\"A handler element must have a class attribute\");\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            Class clazz = APIFactory.class.getClassLoader().loadClass(handlerClass);\n", 
            "+            Handler handler = (Handler) clazz.newInstance();\n", 
            "+            api.addHandler(handler);\n", 
            "+        } catch (Exception e) {\n", 
            "+            handleException(\"Error initializing API handler: \" + handlerClass, e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void handleException(String msg) {\n", 
            "+        log.error(msg);\n", 
            "+        throw new SynapseException(msg);\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void handleException(String msg, Exception e) {\n", 
            "+        log.error(msg, e);\n", 
            "+        throw new SynapseException(msg, e);\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/APIFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/APIFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-27,6 +27,7", 
          "lines": [
            " import org.apache.synapse.SynapseConstants;\r\n", 
            " import org.apache.synapse.SynapseException;\r\n", 
            " import org.apache.synapse.config.xml.endpoints.TemplateFactory;\r\n", 
            "+import org.apache.synapse.config.xml.rest.APIFactory;\r\n", 
            " import org.apache.synapse.endpoints.Template;\r\n", 
            " import org.apache.synapse.mediators.template.TemplateMediator;\r\n", 
            " import org.apache.synapse.message.processors.MessageProcessor;\r\n"
          ]
        }, 
        {
          "locn": "-43,6 +44,7", 
          "lines": [
            " import org.apache.synapse.eventing.SynapseEventSource;\r\n", 
            " import org.apache.synapse.registry.Registry;\r\n", 
            " import org.apache.axis2.AxisFault;\r\n", 
            "+import org.apache.synapse.rest.API;\r\n", 
            " \r\n", 
            " import javax.xml.namespace.QName;\r\n", 
            " import java.util.Iterator;\r\n"
          ]
        }, 
        {
          "locn": "-95,6 +97,8", 
          "lines": [
            "                     defineMessageProcessor(config, elt, properties);\r\n", 
            "                 } else if (StartupFinder.getInstance().isStartup(elt.getQName())) {\r\n", 
            "                     defineStartup(config, elt, properties);\r\n", 
            "+                } else if (XMLConfigConstants.API_ELT.equals(elt.getQName())) {\r\n", 
            "+                    defineAPI(config, elt);\r\n", 
            "                 } else if (XMLConfigConstants.DESCRIPTION_ELT.equals(elt.getQName())) {\r\n", 
            "                     config.setDescription(elt.getText());\r\n", 
            "                 } else {\r\n"
          ]
        }, 
        {
          "locn": "-315,6 +319,11", 
          "lines": [
            "         }\r\n", 
            "     }\r\n", 
            " \r\n", 
            "+    public static void defineAPI(SynapseConfiguration config, OMElement elem) {\r\n", 
            "+        API api = APIFactory.createAPI(elem);\r\n", 
            "+        config.addAPI(api.getName(), api);\r\n", 
            "+    }\r\n", 
            "+\r\n", 
            "     private static void handleException(String msg) {\r\n", 
            "         log.error(msg);\r\n", 
            "         throw new SynapseException(msg);\r\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-671,6 +671,12", 
          "lines": [
            "             <artifactId>commons-lang</artifactId>\n", 
            "             <scope>test</scope>\n", 
            "         </dependency>\n", 
            "+\n", 
            "+\t<dependency>\n", 
            "+\t    <groupId>org.wso2.uri.template</groupId>\n", 
            "+\t    <artifactId>wso2-uri-templates</artifactId>\n", 
            "+\t    <version>1.0.0</version>\n", 
            "+\t</dependency>\n", 
            "         \n", 
            "         <!-- Caching dependencies -->\n", 
            "         <dependency>\n"
          ]
        }
      ], 
      "to": "java/pom.xml", 
      "from": "java/pom.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,20 +1,21", 
          "lines": [
            " /*\n", 
            "-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "-*\n", 
            "-*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "-*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "-*  in compliance with the License.\n", 
            "-*  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-* Unless required by applicable law or agreed to in writing,\n", 
            "-* software distributed under the License is distributed on an\n", 
            "-* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-* KIND, either express or implied.  See the License for the\n", 
            "-* specific language governing permissions and limitations\n", 
            "-* under the License.\n", 
            "-*/\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            " \n", 
            " package org.apache.synapse.samples.framework.config;\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/Axis2ServerConfiguration.java", 
      "from": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/Axis2ServerConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,20 +1,21", 
          "lines": [
            " /*\n", 
            "-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "-*\n", 
            "-*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "-*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "-*  in compliance with the License.\n", 
            "-*  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-* Unless required by applicable law or agreed to in writing,\n", 
            "-* software distributed under the License is distributed on an\n", 
            "-* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-* KIND, either express or implied.  See the License for the\n", 
            "-* specific language governing permissions and limitations\n", 
            "-* under the License.\n", 
            "-*/\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            " \n", 
            " package org.apache.synapse.samples.framework.config;\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/JMSBrokerConfiguration.java", 
      "from": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/JMSBrokerConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,20 +1,21", 
          "lines": [
            " /*\n", 
            "-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "-*\n", 
            "-*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "-*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "-*  in compliance with the License.\n", 
            "-*  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-* Unless required by applicable law or agreed to in writing,\n", 
            "-* software distributed under the License is distributed on an\n", 
            "-* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-* KIND, either express or implied.  See the License for the\n", 
            "-* specific language governing permissions and limitations\n", 
            "-* under the License.\n", 
            "-*/\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            " \n", 
            " package org.apache.synapse.samples.framework.config;\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/SampleConfiguration.java", 
      "from": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/SampleConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,20 +1,21", 
          "lines": [
            " /*\n", 
            "-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "-*\n", 
            "-*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "-*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "-*  in compliance with the License.\n", 
            "-*  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-* Unless required by applicable law or agreed to in writing,\n", 
            "-* software distributed under the License is distributed on an\n", 
            "-* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-* KIND, either express or implied.  See the License for the\n", 
            "-* specific language governing permissions and limitations\n", 
            "-* under the License.\n", 
            "-*/\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            " \n", 
            " package org.apache.synapse.samples.framework.config;\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/Axis2ClientConfiguration.java", 
      "from": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/Axis2ClientConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,20 +1,21", 
          "lines": [
            " /*\n", 
            "-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "-*\n", 
            "-*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "-*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "-*  in compliance with the License.\n", 
            "-*  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-* Unless required by applicable law or agreed to in writing,\n", 
            "-* software distributed under the License is distributed on an\n", 
            "-* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-* KIND, either express or implied.  See the License for the\n", 
            "-* specific language governing permissions and limitations\n", 
            "-* under the License.\n", 
            "-*/\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            " \n", 
            " package org.apache.synapse.samples.framework.config;\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/DerbyConfiguration.java", 
      "from": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/DerbyConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,20 +1,21", 
          "lines": [
            " /*\n", 
            "-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "-*\n", 
            "-*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "-*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "-*  in compliance with the License.\n", 
            "-*  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-* Unless required by applicable law or agreed to in writing,\n", 
            "-* software distributed under the License is distributed on an\n", 
            "-* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-* KIND, either express or implied.  See the License for the\n", 
            "-* specific language governing permissions and limitations\n", 
            "-* under the License.\n", 
            "-*/\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            " \n", 
            " package org.apache.synapse.samples.framework.config;\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/SynapseServerConfiguration.java", 
      "from": "java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/SynapseServerConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,81", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.config.xml.rest;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axiom.om.util.AXIOMUtil;\n", 
            "+import org.apache.synapse.config.xml.AbstractTestCase;\n", 
            "+import org.apache.synapse.rest.API;\n", 
            "+\n", 
            "+public class APISerializationTest extends AbstractTestCase {\n", 
            "+\n", 
            "+    public void testAPISerialization1() throws Exception {\n", 
            "+        String xml = \"<api name=\\\"test\\\" context=\\\"/dictionary\\\" xmlns=\\\"http://ws.apache.org/ns/synapse\\\">\" +\n", 
            "+                \"<resource url-mapping=\\\"/admin/view\\\" inSequence=\\\"in\\\" outSequence=\\\"out\\\"/></api>\";\n", 
            "+        OMElement om = AXIOMUtil.stringToOM(xml);\n", 
            "+        API api = APIFactory.createAPI(om);\n", 
            "+        OMElement out = APISerializer.serializeAPI(api);\n", 
            "+        assertXMLEqual(xml, out.toString());\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testAPISerialization2() throws Exception {\n", 
            "+        String xml = \"<api name=\\\"test\\\" context=\\\"/dictionary\\\" hostname=\\\"apache.org\\\" port=\\\"8243\\\"\" +\n", 
            "+                \" xmlns=\\\"http://ws.apache.org/ns/synapse\\\"><resource url-mapping=\\\"/admin/view\\\" \" +\n", 
            "+                \"inSequence=\\\"in\\\" outSequence=\\\"out\\\"/></api>\";\n", 
            "+        OMElement om = AXIOMUtil.stringToOM(xml);\n", 
            "+        API api = APIFactory.createAPI(om);\n", 
            "+        OMElement out = APISerializer.serializeAPI(api);\n", 
            "+        assertXMLEqual(xml, out.toString());\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testAPISerialization3() throws Exception {\n", 
            "+        String xml = \"<api name=\\\"test\\\" context=\\\"/dictionary\\\" hostname=\\\"apache.org\\\" port=\\\"8243\\\"\" +\n", 
            "+                \" xmlns=\\\"http://ws.apache.org/ns/synapse\\\"><resource url-mapping=\\\"/admin/view\\\" \" +\n", 
            "+                \"inSequence=\\\"in\\\"><outSequence><log/><send/></outSequence></resource></api>\";\n", 
            "+        OMElement om = AXIOMUtil.stringToOM(xml);\n", 
            "+        API api = APIFactory.createAPI(om);\n", 
            "+        OMElement out = APISerializer.serializeAPI(api);\n", 
            "+        assertXMLEqual(xml, out.toString());\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testAPISerialization4() throws Exception {\n", 
            "+        String xml = \"<api name=\\\"test\\\" context=\\\"/dictionary\\\" hostname=\\\"apache.org\\\" port=\\\"8243\\\"\" +\n", 
            "+                \" xmlns=\\\"http://ws.apache.org/ns/synapse\\\"><resource url-mapping=\\\"/admin/view\\\" \" +\n", 
            "+                \"outSequence=\\\"out\\\"><inSequence><log/><send/></inSequence></resource></api>\";\n", 
            "+        OMElement om = AXIOMUtil.stringToOM(xml);\n", 
            "+        API api = APIFactory.createAPI(om);\n", 
            "+        OMElement out = APISerializer.serializeAPI(api);\n", 
            "+        assertXMLEqual(xml, out.toString());\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testAPISerialization5() throws Exception {\n", 
            "+        String xml = \"<api name=\\\"test\\\" context=\\\"/dictionary\\\" hostname=\\\"apache.org\\\" port=\\\"8243\\\"\" +\n", 
            "+                \" xmlns=\\\"http://ws.apache.org/ns/synapse\\\"><resource url-mapping=\\\"/admin/view/*\\\" \" +\n", 
            "+                \"><inSequence><log/><send/></inSequence><outSequence><log/><send/></outSequence></resource>\" +\n", 
            "+                \"<resource url-mapping=\\\"/admin/*\\\"><inSequence><log/><send/></inSequence><outSequence>\" +\n", 
            "+                \"<log/><send/></outSequence></resource><resource uri-template=\\\"/{char}/{word}\\\">\" +\n", 
            "+                \"<inSequence><send/></inSequence><faultSequence><log level=\\\"full\\\"/></faultSequence>\" +\n", 
            "+                \"</resource></api>\";\n", 
            "+        OMElement om = AXIOMUtil.stringToOM(xml);\n", 
            "+        API api = APIFactory.createAPI(om);\n", 
            "+        OMElement out = APISerializer.serializeAPI(api);\n", 
            "+        assertXMLEqual(xml, out.toString());\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/test/java/org/apache/synapse/config/xml/rest/APISerializationTest.java", 
      "from": "java/modules/core/src/test/java/org/apache/synapse/config/xml/rest/APISerializationTest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,178", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+import org.apache.http.protocol.HTTP;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.config.SynapseConfiguration;\n", 
            "+\n", 
            "+public class APIDispatcherTest extends RESTMediationTestCase {\n", 
            "+\n", 
            "+    private static final String TEST_API = \"TestAPI\";\n", 
            "+\n", 
            "+    public void testGeneralAPIDispatch() throws Exception {\n", 
            "+        API api = new API(TEST_API, \"/\");\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(TEST_API, api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/foo/bar?a=5\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testBasicAPIDispatch() throws Exception {\n", 
            "+        API api = new API(TEST_API, \"/test\");\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(TEST_API, api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        // Messages with '/test' context should ne dispatched\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar?a=5\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test?a=5\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        // Messages WITHOUT the '/test' context should NOT be dispatched\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/foo/test/bar?a=5\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test1/bar?a=5\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testResponseDispatch() throws Exception {\n", 
            "+        API api = new API(TEST_API, \"/test\");\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(TEST_API, api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        // Messages with '/test' context should ne dispatched\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test\", \"GET\");\n", 
            "+        synCtx.setResponse(true);\n", 
            "+        assertFalse(handler.process(synCtx));\n", 
            "+\n", 
            "+        synCtx.setProperty(RESTConstants.SYNAPSE_REST_API, TEST_API);\n", 
            "+        assertTrue(handler.process(synCtx));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testHostBasedAPIDispatch() throws Exception {\n", 
            "+        API api = new API(TEST_API, \"/test\");\n", 
            "+        api.setHost(\"synapse.apache.org\");\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(TEST_API, api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        // Messages that don't have the proper host set should not be dispatched\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        // Messages with the correct host should be dispatched\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/\", \"GET\");\n", 
            "+        addHttpHeader(HTTP.TARGET_HOST, \"synapse.apache.org\", synCtx);\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        // API should be able to infer the default HTTP port\n", 
            "+        api.setPort(80);\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        // Messages with an incorrect port number should not be dispatched\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar?a=5\", \"GET\");\n", 
            "+        addHttpHeader(HTTP.TARGET_HOST, \"synapse.apache.org:8280\", synCtx);\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        // Messages with the correct port number should be dispatched\n", 
            "+        api.setPort(8280);\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        api.setPort(443);\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar?a=5\", \"GET\");\n", 
            "+        addHttpHeader(HTTP.TARGET_HOST, \"synapse.apache.org\", synCtx);\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        // API should accurately infer the default HTTPS port\n", 
            "+        synCtx = getMessageContext(synapseConfig, true, \"/test/foo/bar?a=5\", \"GET\");\n", 
            "+        addHttpHeader(HTTP.TARGET_HOST, \"synapse.apache.org\", synCtx);\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testMultipleAPIDispatch() throws Exception {\n", 
            "+        String apiName1 = \"TestAPI1\";\n", 
            "+        String apiName2 = \"TestAPI2\";\n", 
            "+        String apiName3 = \"TestAPI3\";\n", 
            "+\n", 
            "+        API api1 = new API(apiName1, \"/test\");\n", 
            "+        API api2 = new API(apiName2, \"/dictionary\");\n", 
            "+        api2.setHost(\"synapse.apache.org\");\n", 
            "+        API api3 = new API(apiName3, \"/foo/bar\");\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(apiName1, api1);\n", 
            "+        synapseConfig.addAPI(apiName2, api2);\n", 
            "+        synapseConfig.addAPI(apiName3, api3);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(apiName1, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/dictionary/c/cat\", \"GET\");\n", 
            "+        addHttpHeader(HTTP.TARGET_HOST, \"synapse.apache.org\", synCtx);\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(apiName2, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/foo/bar/index.jsp?user=test\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(apiName3, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/foo/index.jsp?user=test\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));\n", 
            "+    }\n", 
            "+\n", 
            "+}\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/test/java/org/apache/synapse/rest/APIDispatcherTest.java", 
      "from": "java/modules/core/src/test/java/org/apache/synapse/rest/APIDispatcherTest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,165", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.config.SynapseConfiguration;\n", 
            "+import org.apache.synapse.rest.dispatch.URITemplateHelper;\n", 
            "+\n", 
            "+public class URITemplateBasedDispatcherTest extends RESTMediationTestCase {\n", 
            "+\n", 
            "+    private static final String PROP_NAME = \"prop.name\";\n", 
            "+    private static final String PROP_VALUE = \"prop.value\";\n", 
            "+\n", 
            "+    public void testBasicTemplateDispatch1() throws Exception {\n", 
            "+        API api = new API(\"TestAPI\", \"/test\");\n", 
            "+        Resource resource = new Resource();\n", 
            "+        resource.setDispatcherHelper(new URITemplateHelper(\"/~{user}\"));\n", 
            "+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));\n", 
            "+        api.addResource(resource);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test/~foo\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+        assertEquals(\"foo\", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + \"user\"));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/~foo/bar\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testBasicTemplateDispatch2() throws Exception {\n", 
            "+\n", 
            "+        API api = new API(\"TestAPI\", \"/\");\n", 
            "+        Resource resource = new Resource();\n", 
            "+        resource.setDispatcherHelper(new URITemplateHelper(\"/dictionary/{char}/{word}\"));\n", 
            "+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));\n", 
            "+        api.addResource(resource);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/dictionary/c/cat\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+        assertEquals(\"c\", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + \"char\"));\n", 
            "+        assertEquals(\"cat\", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + \"word\"));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/dictionary/d/dog/\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+        assertEquals(\"d\", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + \"char\"));\n", 
            "+        assertEquals(\"dog\", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + \"word\"));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/c/cat\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/dictionary/c\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/dictionary/c/cat?a=5\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testDefaultDispatch() throws Exception {\n", 
            "+\n", 
            "+        API api = new API(\"TestAPI\", \"/test\");\n", 
            "+        Resource resource = new Resource();\n", 
            "+        resource.setDispatcherHelper(new URITemplateHelper(\"/\"));\n", 
            "+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));\n", 
            "+        api.addResource(resource);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testMultipleResourceDispatch() throws Exception {\n", 
            "+\n", 
            "+        API api = new API(\"TestAPI\", \"/\");\n", 
            "+        Resource resource1 = new Resource();\n", 
            "+        resource1.setDispatcherHelper(new URITemplateHelper(\"/dictionary/{char}/{word}\"));\n", 
            "+        resource1.setInSequence(getTestSequence(PROP_NAME, \"r1\"));\n", 
            "+        api.addResource(resource1);\n", 
            "+\n", 
            "+        Resource resource2 = new Resource();\n", 
            "+        resource2.setDispatcherHelper(new URITemplateHelper(\"/dictionary/{char}\"));\n", 
            "+        resource2.setInSequence(getTestSequence(PROP_NAME, \"r2\"));\n", 
            "+        api.addResource(resource2);\n", 
            "+\n", 
            "+        Resource resource3 = new Resource();\n", 
            "+        resource3.setDispatcherHelper(new URITemplateHelper(\"/dictionary/{char}{#ref}\"));\n", 
            "+        resource3.setInSequence(getTestSequence(PROP_NAME, \"r3\"));\n", 
            "+        api.addResource(resource3);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/dictionary/c/cat\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"r1\", synCtx.getProperty(PROP_NAME));\n", 
            "+        assertEquals(\"c\", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + \"char\"));\n", 
            "+        assertEquals(\"cat\", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + \"word\"));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/dictionary/d\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"r2\", synCtx.getProperty(PROP_NAME));\n", 
            "+        assertEquals(\"d\", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + \"char\"));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/dictionary/e#test\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"r3\", synCtx.getProperty(PROP_NAME));\n", 
            "+        assertEquals(\"e\", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + \"char\"));\n", 
            "+        assertEquals(\"test\", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + \"ref\"));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/dictionary/c/cat/test\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/dictionary/c/cat#ref\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/dictionary/c/cat?a=5\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/test/java/org/apache/synapse/rest/URITemplateBasedDispatcherTest.java", 
      "from": "java/modules/core/src/test/java/org/apache/synapse/rest/URITemplateBasedDispatcherTest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,72", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+import junit.framework.TestCase;\n", 
            "+import org.apache.axis2.Constants;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.config.SynapseConfiguration;\n", 
            "+import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            "+import org.apache.synapse.mediators.TestUtils;\n", 
            "+import org.apache.synapse.mediators.base.SequenceMediator;\n", 
            "+import org.apache.synapse.mediators.builtin.PropertyMediator;\n", 
            "+\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.Map;\n", 
            "+\n", 
            "+public abstract class RESTMediationTestCase extends TestCase {\n", 
            "+\n", 
            "+    protected MessageContext getMessageContext(SynapseConfiguration synapseConfig, boolean https,\n", 
            "+                                               String url, String method) throws Exception {\n", 
            "+        MessageContext synCtx = TestUtils.createSynapseMessageContext(\"<foo/>\", synapseConfig);\n", 
            "+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).\n", 
            "+                getAxis2MessageContext();\n", 
            "+        if (https) {\n", 
            "+            msgCtx.setIncomingTransportName(\"https\");\n", 
            "+        } else {\n", 
            "+            msgCtx.setIncomingTransportName(\"http\");\n", 
            "+        }\n", 
            "+        msgCtx.setProperty(Constants.Configuration.HTTP_METHOD, method);\n", 
            "+        msgCtx.setProperty(Constants.Configuration.TRANSPORT_IN_URL, url);\n", 
            "+        return synCtx;\n", 
            "+    }\n", 
            "+\n", 
            "+    protected void addHttpHeader(String name, String value, MessageContext synCtx) {\n", 
            "+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).\n", 
            "+                getAxis2MessageContext();\n", 
            "+        Object obj = msgCtx.getProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);\n", 
            "+        if (obj != null) {\n", 
            "+            ((Map) obj).put(name, value);\n", 
            "+        } else {\n", 
            "+            Map map = new HashMap();\n", 
            "+            map.put(name, value);\n", 
            "+            msgCtx.setProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS, map);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    protected SequenceMediator getTestSequence(String name, String value) {\n", 
            "+        SequenceMediator seq = new SequenceMediator();\n", 
            "+        PropertyMediator prop = new PropertyMediator();\n", 
            "+        prop.setName(name);\n", 
            "+        prop.setValue(value);\n", 
            "+        seq.addChild(prop);\n", 
            "+        return seq;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/test/java/org/apache/synapse/rest/RESTMediationTestCase.java", 
      "from": "java/modules/core/src/test/java/org/apache/synapse/rest/RESTMediationTestCase.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,225", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.config.SynapseConfiguration;\n", 
            "+import org.apache.synapse.rest.dispatch.URLMappingHelper;\n", 
            "+\n", 
            "+public class URLMappingBasedDispatcherTest extends RESTMediationTestCase {\n", 
            "+\n", 
            "+    private static final String PROP_NAME = \"prop.name\";\n", 
            "+    private static final String PROP_VALUE = \"prop.value\";\n", 
            "+\n", 
            "+    public void testDefaultResourceDispatch() throws Exception {\n", 
            "+\n", 
            "+        API api = new API(\"TestAPI\", \"/test\");\n", 
            "+        Resource resource = new Resource();\n", 
            "+        resource.setDispatcherHelper(new URLMappingHelper(\"/\"));\n", 
            "+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));\n", 
            "+        api.addResource(resource);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testPathBasedDispatch() throws Exception {\n", 
            "+\n", 
            "+        API api = new API(\"TestAPI\", \"/test\");\n", 
            "+        Resource resource = new Resource();\n", 
            "+        resource.setDispatcherHelper(new URLMappingHelper(\"/foo/bar/*\"));\n", 
            "+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));\n", 
            "+        api.addResource(resource);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar/\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar/index.jsp\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testExtensionBasedDispatch() throws Exception {\n", 
            "+\n", 
            "+        API api = new API(\"TestAPI\", \"/test\");\n", 
            "+        Resource resource = new Resource();\n", 
            "+        resource.setDispatcherHelper(new URLMappingHelper(\"*.jsp\"));\n", 
            "+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));\n", 
            "+        api.addResource(resource);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar/index.jsp\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/welcome.jsp\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/index.jsp?a=5&b=10\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/index.html\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testExactMatchBasedDispatch() throws Exception {\n", 
            "+        API api = new API(\"TestAPI\", \"/test\");\n", 
            "+        Resource resource = new Resource();\n", 
            "+        resource.setDispatcherHelper(new URLMappingHelper(\"/foo/bar\"));\n", 
            "+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));\n", 
            "+        api.addResource(resource);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar/\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar/index.html\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testMultipleResourceDispatch() throws Exception {\n", 
            "+        API api = new API(\"TestAPI\", \"/test\");\n", 
            "+\n", 
            "+        Resource resource1 = new Resource();\n", 
            "+        resource1.setDispatcherHelper(new URLMappingHelper(\"/foo/*\"));\n", 
            "+        resource1.setInSequence(getTestSequence(PROP_NAME, \"resource1\"));\n", 
            "+\n", 
            "+        Resource resource2 = new Resource();\n", 
            "+        resource2.setDispatcherHelper(new URLMappingHelper(\"/foo/bar/*\"));\n", 
            "+        resource2.setInSequence(getTestSequence(PROP_NAME, \"resource2\"));\n", 
            "+\n", 
            "+        Resource resource3 = new Resource();\n", 
            "+        resource3.setDispatcherHelper(new URLMappingHelper(\"*.jsp\"));\n", 
            "+        resource3.setInSequence(getTestSequence(PROP_NAME, \"resource3\"));\n", 
            "+\n", 
            "+        api.addResource(resource1);\n", 
            "+        api.addResource(resource2);\n", 
            "+        api.addResource(resource3);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test/foo/\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"resource1\", synCtx.getProperty(PROP_NAME));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/index.html?a=5\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"resource1\", synCtx.getProperty(PROP_NAME));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bars\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"resource1\", synCtx.getProperty(PROP_NAME));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/index.jsp\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"resource1\", synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar/\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"resource2\", synCtx.getProperty(PROP_NAME));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar/index.html?a=5\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"resource2\", synCtx.getProperty(PROP_NAME));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar/hello\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"resource2\", synCtx.getProperty(PROP_NAME));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar/index.jsp\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"resource2\", synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/index.jsp\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"resource3\", synCtx.getProperty(PROP_NAME));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/hello/index.jsp?a=5\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"resource3\", synCtx.getProperty(PROP_NAME));\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foolish/bars/index.jsp\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"resource3\", synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/foolish/index.html\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testResponseDispatch() throws Exception {\n", 
            "+        API api = new API(\"TestAPI\", \"/test\");\n", 
            "+        Resource resource = new Resource();\n", 
            "+        resource.setDispatcherHelper(new URLMappingHelper(\"/foo/bar/*\"));\n", 
            "+        resource.setOutSequence(getTestSequence(PROP_NAME, PROP_VALUE));\n", 
            "+        api.addResource(resource);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test/foo/bar\", \"GET\");\n", 
            "+        synCtx.setProperty(RESTConstants.SYNAPSE_REST_API, api.getName());\n", 
            "+        synCtx.setResponse(true);\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertNull(synCtx.getProperty(PROP_NAME));\n", 
            "+\n", 
            "+        synCtx.setProperty(RESTConstants.SYNAPSE_RESOURCE, resource.getName());\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/test/java/org/apache/synapse/rest/URLMappingBasedDispatcherTest.java", 
      "from": "java/modules/core/src/test/java/org/apache/synapse/rest/URLMappingBasedDispatcherTest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,92", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.config.SynapseConfiguration;\n", 
            "+import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            "+import org.apache.synapse.core.axis2.Axis2SynapseEnvironment;\n", 
            "+import org.apache.synapse.core.axis2.MessageContextCreatorForAxis2;\n", 
            "+import org.apache.synapse.core.axis2.SynapseMessageReceiver;\n", 
            "+import org.apache.synapse.mediators.Value;\n", 
            "+import org.apache.synapse.mediators.base.SequenceMediator;\n", 
            "+import org.apache.synapse.mediators.builtin.PropertyMediator;\n", 
            "+import org.apache.synapse.mediators.transform.XSLTMediator;\n", 
            "+import org.apache.synapse.rest.dispatch.URITemplateHelper;\n", 
            "+\n", 
            "+public class ResourceTest extends RESTMediationTestCase {\n", 
            "+\n", 
            "+    public void testQueryParams() throws Exception {\n", 
            "+        API api = new API(\"TestAPI\", \"/test\");\n", 
            "+        Resource resource = new Resource();\n", 
            "+        api.addResource(resource);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+\n", 
            "+        RESTRequestHandler handler = new RESTRequestHandler();\n", 
            "+\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false,\n", 
            "+                \"/test/admin?a=5&b=10&user=bar\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"5\", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + \"a\"));\n", 
            "+        assertEquals(\"10\", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + \"b\"));\n", 
            "+        assertEquals(\"bar\", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + \"user\"));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/admin?a=5\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"5\", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + \"a\"));\n", 
            "+\n", 
            "+        synCtx = getMessageContext(synapseConfig, false, \"/test/admin?a=Hello%20World&b=10&c=/foo/bar\", \"GET\");\n", 
            "+        handler.process(synCtx);\n", 
            "+        assertEquals(\"Hello World\", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + \"a\"));\n", 
            "+        assertEquals(\"10\", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + \"b\"));\n", 
            "+        assertEquals(\"/foo/bar\", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + \"c\"));\n", 
            "+    }\n", 
            "+\n", 
            "+    public void testFaultSequence() throws Exception {\n", 
            "+        API api = new API(\"TestAPI\", \"/test\");\n", 
            "+        Resource resource = new Resource();\n", 
            "+        resource.setDispatcherHelper(new URITemplateHelper(\"/~{user}\"));\n", 
            "+        SequenceMediator inSequence = getTestSequence(\"seq.in\", \"seq.in.value\");\n", 
            "+        ((PropertyMediator) inSequence.getChild(0)).setScope(\"axis2\");\n", 
            "+        XSLTMediator xsltMediator = new XSLTMediator();\n", 
            "+        xsltMediator.setXsltKey(new Value(\"/bogus/key\"));\n", 
            "+        inSequence.addChild(xsltMediator);\n", 
            "+        resource.setInSequence(inSequence);\n", 
            "+        SequenceMediator faultSequence = getTestSequence(\"seq.fault\", \"seq.fault.value\");\n", 
            "+        ((PropertyMediator) faultSequence.getChild(0)).setScope(\"axis2\");\n", 
            "+        resource.setFaultSequence(faultSequence);\n", 
            "+        api.addResource(resource);\n", 
            "+\n", 
            "+        SynapseConfiguration synapseConfig = new SynapseConfiguration();\n", 
            "+        synapseConfig.addAPI(api.getName(), api);\n", 
            "+        synapseConfig.addSequence(\"main\", getTestSequence(\"main.in\", \"main.value\"));\n", 
            "+        MessageContext synCtx = getMessageContext(synapseConfig, false, \"/test/~foo\", \"GET\");\n", 
            "+        MessageContextCreatorForAxis2.setSynConfig(synapseConfig);\n", 
            "+        MessageContextCreatorForAxis2.setSynEnv(synCtx.getEnvironment());\n", 
            "+\n", 
            "+        org.apache.axis2.context.MessageContext mc = ((Axis2MessageContext) synCtx).getAxis2MessageContext();\n", 
            "+        mc.setConfigurationContext(((Axis2SynapseEnvironment) synCtx.getEnvironment()).getAxis2ConfigurationContext());\n", 
            "+        new SynapseMessageReceiver().receive(mc);\n", 
            "+        assertEquals(\"seq.in.value\", mc.getProperty(\"seq.in\"));\n", 
            "+        assertEquals(\"seq.fault.value\", mc.getProperty(\"seq.fault\"));\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/test/java/org/apache/synapse/rest/ResourceTest.java", 
      "from": "java/modules/core/src/test/java/org/apache/synapse/rest/ResourceTest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-30,6 +30,9", 
          "lines": [
            " import org.apache.commons.logging.LogFactory;\n", 
            " import org.apache.synapse.*;\n", 
            " import org.apache.synapse.config.xml.XMLConfigConstants;\n", 
            "+import org.apache.synapse.rest.RESTConstants;\n", 
            "+import org.apache.synapse.rest.RESTRequestHandler;\n", 
            "+import org.apache.synapse.rest.Resource;\n", 
            " import org.apache.synapse.task.SynapseTaskManager;\n", 
            " import org.apache.synapse.aspects.statistics.StatisticsCollector;\n", 
            " import org.apache.synapse.config.SynapseConfiguration;\n"
          ]
        }, 
        {
          "locn": "-61,6 +64,7", 
          "lines": [
            "     private ExecutorService executorService;\n", 
            "     private boolean initialized = false;\n", 
            "     private SynapseTaskManager taskManager;\n", 
            "+    private RESTRequestHandler restHandler;\n", 
            " \n", 
            "     /** The StatisticsCollector object */\n", 
            "     private StatisticsCollector statisticsCollector = new StatisticsCollector();\n"
          ]
        }, 
        {
          "locn": "-104,7 +108,8", 
          "lines": [
            "             synCfg.getProperty(SynapseThreadPool.SYN_THREAD_IDPREFIX,\n", 
            "                 SynapseThreadPool.SYNAPSE_THREAD_ID_PREFIX));\n", 
            " \n", 
            "-        taskManager = new SynapseTaskManager();                \n", 
            "+        taskManager = new SynapseTaskManager();\n", 
            "+        restHandler = new RESTRequestHandler();\n", 
            "     }\n", 
            " \n", 
            "     public Axis2SynapseEnvironment(ConfigurationContext cfgCtx,\n"
          ]
        }, 
        {
          "locn": "-172,6 +177,11", 
          "lines": [
            "                     return false;\n", 
            "                 }\n", 
            "             } else {\n", 
            "+                boolean processed = restHandler.process(synCtx);\n", 
            "+                if (processed) {\n", 
            "+                    return true;\n", 
            "+                }\n", 
            "+\n", 
            "                 if (log.isDebugEnabled()) {\n", 
            "                     log.debug(\"Using Main Sequence for injected message\");\n", 
            "                 }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,172", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.deployers;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axis2.deployment.DeploymentException;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.config.xml.MultiXMLConfigurationBuilder;\n", 
            "+import org.apache.synapse.config.xml.rest.APIFactory;\n", 
            "+import org.apache.synapse.config.xml.rest.APISerializer;\n", 
            "+import org.apache.synapse.rest.API;\n", 
            "+\n", 
            "+import java.io.File;\n", 
            "+import java.util.Properties;\n", 
            "+\n", 
            "+public class APIDeployer extends AbstractSynapseArtifactDeployer {\n", 
            "+\n", 
            "+    private static Log log = LogFactory.getLog(APIDeployer.class);\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"API deployment from file : \" + fileName + \" : Started\");\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            API api = APIFactory.createAPI(artifactConfig);\n", 
            "+            if (api != null) {\n", 
            "+                api.setFileName((new File(fileName)).getName());\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"API named '\" + api.getName()\n", 
            "+                            + \"' has been built from the file \" + fileName);\n", 
            "+                }\n", 
            "+                api.init(getSynapseEnvironment());\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Initialized the API: \" + api.getName());\n", 
            "+                }\n", 
            "+                getSynapseConfiguration().addAPI(api.getName(), api);\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"API deployment from file : \" + fileName + \" : Completed\");\n", 
            "+                }\n", 
            "+                log.info(\"API named '\" + api.getName() +\n", 
            "+                        \"' has been deployed from file : \" + fileName);\n", 
            "+                return api.getName();\n", 
            "+            } else {\n", 
            "+                handleSynapseArtifactDeploymentError(\"API deployment Failed. The artifact \" +\n", 
            "+                        \"described in the file \" + fileName + \" is not a valid API\");\n", 
            "+            }\n", 
            "+        } catch (Exception e) {\n", 
            "+            handleSynapseArtifactDeploymentError(\"API deployment from the file : \"\n", 
            "+                    + fileName + \" : Failed.\", e);\n", 
            "+        }\n", 
            "+\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"API update from file : \" + fileName + \" has started\");\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            API api = APIFactory.createAPI(artifactConfig);\n", 
            "+            if (api == null) {\n", 
            "+                handleSynapseArtifactDeploymentError(\"API update failed. The artifact \" +\n", 
            "+                        \"defined in the file: \" + fileName + \" is not a valid API.\");\n", 
            "+                return null;\n", 
            "+            }\n", 
            "+            api.setFileName(new File(fileName).getName());\n", 
            "+\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"API: \" + api.getName() + \" has been built from the file: \" + fileName);\n", 
            "+            }\n", 
            "+\n", 
            "+            api.init(getSynapseEnvironment());\n", 
            "+            API existingAPI = getSynapseConfiguration().getAPI(existingArtifactName);\n", 
            "+            if (existingArtifactName.equals(api.getName())) {\n", 
            "+                getSynapseConfiguration().updateAPI(existingArtifactName, api);\n", 
            "+            } else {\n", 
            "+                // The user has changed the name of the API\n", 
            "+                // We should add the updated API as a new API and remove the old one\n", 
            "+                getSynapseConfiguration().addAPI(api.getName(), api);\n", 
            "+                getSynapseConfiguration().removeAPI(existingArtifactName);\n", 
            "+                log.info(\"API: \" + existingArtifactName + \" has been undeployed\");\n", 
            "+            }\n", 
            "+\n", 
            "+            log.info(\"API: \" + api.getName() + \" has been updated from the file: \" + fileName);\n", 
            "+\n", 
            "+            waitForCompletion();\n", 
            "+            existingAPI.destroy();\n", 
            "+            return api.getName();\n", 
            "+\n", 
            "+        } catch (DeploymentException e) {\n", 
            "+            handleSynapseArtifactDeploymentError(\"Error while updating the API from the \" +\n", 
            "+                    \"file: \" + fileName);\n", 
            "+        }\n", 
            "+\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public void undeploySynapseArtifact(String artifactName) {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Undeployment of the API named : \"\n", 
            "+                    + artifactName + \" : Started\");\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            API api = getSynapseConfiguration().getAPI(artifactName);\n", 
            "+            if (api != null) {\n", 
            "+                getSynapseConfiguration().removeAPI(artifactName);\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Undeployment of the API named : \"\n", 
            "+                            + artifactName + \" : Completed\");\n", 
            "+                }\n", 
            "+                log.info(\"API named '\" + api.getName() + \"' has been undeployed\");\n", 
            "+            } else if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"API \" + artifactName + \" has already been undeployed\");\n", 
            "+            }\n", 
            "+        } catch (Exception e) {\n", 
            "+            handleSynapseArtifactDeploymentError(\n", 
            "+                    \"Undeployment of API named : \" + artifactName + \" : Failed\", e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    @Override\n", 
            "+    public void restoreSynapseArtifact(String artifactName) {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Restoring the API with name : \" + artifactName + \" : Started\");\n", 
            "+        }\n", 
            "+\n", 
            "+        try {\n", 
            "+            API api = getSynapseConfiguration().getAPI(artifactName);\n", 
            "+            OMElement apiElement = APISerializer.serializeAPI(api);\n", 
            "+            if (api.getFileName() != null) {\n", 
            "+                String fileName = getServerConfigurationInformation().getSynapseXMLLocation()\n", 
            "+                        + File.separator + MultiXMLConfigurationBuilder.REST_API_DIR\n", 
            "+                        + File.separator + api.getFileName();\n", 
            "+                writeToFile(apiElement, fileName);\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Restoring the API with name : \" + artifactName + \" : Completed\");\n", 
            "+                }\n", 
            "+                log.info(\"API named '\" + artifactName + \"' has been restored\");\n", 
            "+            } else {\n", 
            "+                handleSynapseArtifactDeploymentError(\"Couldn't restore the API named '\"\n", 
            "+                        + artifactName + \"', filename cannot be found\");\n", 
            "+            }\n", 
            "+        } catch (Exception e) {\n", 
            "+            handleSynapseArtifactDeploymentError(\n", 
            "+                    \"Restoring of the API named '\" + artifactName + \"' has failed\", e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/deployers/APIDeployer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/deployers/APIDeployer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,30", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+\n", 
            "+public interface Handler {\n", 
            "+\n", 
            "+    public boolean handleRequest(MessageContext messageContext);\n", 
            "+\n", 
            "+    public boolean handleResponse(MessageContext messageContext);\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/Handler.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/Handler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,105", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+import org.apache.axis2.Constants;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            "+import org.apache.synapse.rest.dispatch.RESTDispatcher;\n", 
            "+import org.apache.synapse.rest.dispatch.DefaultDispatcher;\n", 
            "+import org.apache.synapse.rest.dispatch.URLMappingBasedDispatcher;\n", 
            "+import org.apache.synapse.rest.dispatch.URITemplateBasedDispatcher;\n", 
            "+import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            "+\n", 
            "+import java.net.MalformedURLException;\n", 
            "+import java.net.URL;\n", 
            "+import java.util.ArrayList;\n", 
            "+import java.util.List;\n", 
            "+\n", 
            "+public class RESTUtils {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(RESTUtils.class);\n", 
            "+\n", 
            "+    private static final List<RESTDispatcher> dispatchers = new ArrayList<RESTDispatcher>();\n", 
            "+\n", 
            "+    static {\n", 
            "+        dispatchers.add(new URLMappingBasedDispatcher());\n", 
            "+        dispatchers.add(new URITemplateBasedDispatcher());\n", 
            "+        dispatchers.add(new DefaultDispatcher());\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String trimSlashes(String url) {\n", 
            "+        if (url.startsWith(\"/\")) {\n", 
            "+            url = url.substring(1);\n", 
            "+        }\n", 
            "+        if (url.startsWith(\"/\")) {\n", 
            "+            url = url.substring(0, url.length() - 1);\n", 
            "+        }\n", 
            "+        return url;\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String trimTrailingSlashes(String url) {\n", 
            "+        while (url.endsWith(\"/\")) {\n", 
            "+            url = url.substring(0, url.length() - 1);\n", 
            "+        }\n", 
            "+        return url;\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getFullRequestPath(MessageContext synCtx) {\n", 
            "+        Object obj = synCtx.getProperty(RESTConstants.REST_FULL_REQUEST_PATH);\n", 
            "+        if (obj != null) {\n", 
            "+            return (String) obj;\n", 
            "+        }\n", 
            "+\n", 
            "+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).\n", 
            "+                getAxis2MessageContext();\n", 
            "+        String url = (String) msgCtx.getProperty(Constants.Configuration.TRANSPORT_IN_URL);\n", 
            "+        if (url == null) {\n", 
            "+            url = (String) synCtx.getProperty(NhttpConstants.SERVICE_PREFIX);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (url.contains(\"://\")) {\n", 
            "+            try {\n", 
            "+                url = new URL(url).getPath();\n", 
            "+            } catch (MalformedURLException e) {\n", 
            "+                handleException(\"Request URL: \" + url + \" is malformed\", e);\n", 
            "+            }\n", 
            "+        }\n", 
            "+        synCtx.setProperty(RESTConstants.REST_FULL_REQUEST_PATH, url);\n", 
            "+        return url;\n", 
            "+    }\n", 
            "+\n", 
            "+    public static String getSubRequestPath(MessageContext synCtx) {\n", 
            "+        return (String) synCtx.getProperty(RESTConstants.REST_SUB_REQUEST_PATH);\n", 
            "+    }\n", 
            "+\n", 
            "+    public static List<RESTDispatcher> getDispatchers() {\n", 
            "+        return dispatchers;\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void handleException(String msg, Throwable t) {\n", 
            "+        log.error(msg, t);\n", 
            "+        throw new SynapseException(msg, t);\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/RESTUtils.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/RESTUtils.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,97", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest.dispatch;\n", 
            "+\n", 
            "+import org.apache.synapse.rest.RESTUtils;\n", 
            "+\n", 
            "+public class URLMappingHelper implements DispatcherHelper {\n", 
            "+\n", 
            "+    private String[] pathSegments;\n", 
            "+    private String extension;\n", 
            "+    private String exactMatch;\n", 
            "+\n", 
            "+    public URLMappingHelper(String urlMapping) {\n", 
            "+        if (urlMapping.startsWith(\"/\") && urlMapping.endsWith(\"/*\")) {\n", 
            "+            if (urlMapping.length() > 2) {\n", 
            "+                pathSegments = urlMapping.substring(1, urlMapping.length() - 2).split(\"/\");\n", 
            "+            } else {\n", 
            "+                pathSegments = new String[] {};\n", 
            "+            }\n", 
            "+        } else if (urlMapping.startsWith(\"*.\")) {\n", 
            "+            extension = urlMapping.substring(1);\n", 
            "+        } else {\n", 
            "+            exactMatch = urlMapping;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isExactMatch(String url) {\n", 
            "+        if (!\"/\".equals(url)) {\n", 
            "+            url = RESTUtils.trimTrailingSlashes(url);\n", 
            "+        }\n", 
            "+        return exactMatch != null && exactMatch.equals(url);\n", 
            "+    }\n", 
            "+\n", 
            "+    public boolean isExtensionMatch(String url) {\n", 
            "+        int index = url.indexOf('?');\n", 
            "+        if (index != -1) {\n", 
            "+            url = url.substring(0, index);\n", 
            "+        }\n", 
            "+        return extension != null && url.endsWith(extension);\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getPrefixMatchingLength(String url) {\n", 
            "+        if (pathSegments != null) {\n", 
            "+            if (pathSegments.length == 0) {\n", 
            "+                return 1;\n", 
            "+            }\n", 
            "+\n", 
            "+            url = RESTUtils.trimSlashes(url);\n", 
            "+            String[] segments = url.split(\"/\");\n", 
            "+            int matchingLength = 0;\n", 
            "+            for (int i = 0; i < pathSegments.length; i++) {\n", 
            "+                if (segments.length > i) {\n", 
            "+                    if (segments[i].equals(pathSegments[i])) {\n", 
            "+                        matchingLength++;\n", 
            "+                    } else {\n", 
            "+                        return 0;\n", 
            "+                    }\n", 
            "+                } else {\n", 
            "+                    return 0;\n", 
            "+                }\n", 
            "+            }\n", 
            "+            return matchingLength;\n", 
            "+        }\n", 
            "+        return 0;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getString() {\n", 
            "+        if (pathSegments != null) {\n", 
            "+            String str = \"\";\n", 
            "+            for (String segment : pathSegments) {\n", 
            "+                str += \"/\" + segment;\n", 
            "+            }\n", 
            "+            return str + \"/*\";\n", 
            "+        } else if (extension != null) {\n", 
            "+            return \"*.\" + extension;\n", 
            "+        } else {\n", 
            "+            return exactMatch;\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URLMappingHelper.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URLMappingHelper.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,50", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest.dispatch;\n", 
            "+\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.rest.*;\n", 
            "+\n", 
            "+import java.util.Collection;\n", 
            "+import java.util.HashMap;\n", 
            "+import java.util.Map;\n", 
            "+\n", 
            "+public class URITemplateBasedDispatcher implements RESTDispatcher {\n", 
            "+\n", 
            "+    public Resource findResource(MessageContext synCtx, Collection<Resource> resources) {\n", 
            "+        String url = RESTUtils.getSubRequestPath(synCtx);\n", 
            "+        for (Resource r : resources) {\n", 
            "+            DispatcherHelper helper = r.getDispatcherHelper();\n", 
            "+            if (helper instanceof URITemplateHelper) {\n", 
            "+                URITemplateHelper templateHelper = (URITemplateHelper) helper;\n", 
            "+                Map<String,String> variables = new HashMap<String,String>();\n", 
            "+                if (templateHelper.getUriTemplate().matches(url, variables)) {\n", 
            "+                    for (Map.Entry<String,String> entry : variables.entrySet()) {\n", 
            "+                        synCtx.setProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + entry.getKey(),\n", 
            "+                                entry.getValue());\n", 
            "+                    }\n", 
            "+                    return r;\n", 
            "+                }\n", 
            "+            }\n", 
            "+\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URITemplateBasedDispatcher.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URITemplateBasedDispatcher.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,42", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+package org.apache.synapse.rest.dispatch;\n", 
            "+\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.rest.Resource;\n", 
            "+\n", 
            "+import java.util.Collection;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Interface for finding a Resource through which a given request can be mediated.\n", 
            "+ * Implementations of this interface should attempt to find a Resource out of the\n", 
            "+ * provided collection using which the given message can br further processed.\n", 
            "+ */\n", 
            "+public interface RESTDispatcher {\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Find a Resource instance suitable for processing the given message\n", 
            "+     *\n", 
            "+     * @param synCtx MessageContext to be processed through a Resource\n", 
            "+     * @param resources Collection of available Resource instances\n", 
            "+     * @return A matching Resource instance or null\n", 
            "+     */\n", 
            "+    public Resource findResource(MessageContext synCtx, Collection<Resource> resources);\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/RESTDispatcher.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/RESTDispatcher.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,87", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest.dispatch;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.rest.*;\n", 
            "+\n", 
            "+import java.util.*;\n", 
            "+\n", 
            "+public class URLMappingBasedDispatcher implements RESTDispatcher {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(URLMappingBasedDispatcher.class);\n", 
            "+\n", 
            "+    public Resource findResource(MessageContext synCtx, Collection<Resource> resources) {\n", 
            "+        List<URLMappingHelper> mappings = new ArrayList<URLMappingHelper>();\n", 
            "+        List<Resource> filteredResources = new ArrayList<Resource>();\n", 
            "+\n", 
            "+        for (Resource r : resources) {\n", 
            "+            DispatcherHelper helper = r.getDispatcherHelper();\n", 
            "+            if (helper instanceof URLMappingHelper) {\n", 
            "+                mappings.add((URLMappingHelper) helper);\n", 
            "+                filteredResources.add(r);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        int count = filteredResources.size();\n", 
            "+        if (count == 0) {\n", 
            "+            return null;\n", 
            "+        }\n", 
            "+\n", 
            "+        String url = RESTUtils.getSubRequestPath(synCtx);\n", 
            "+        for (int i = 0; i < count; i++) {\n", 
            "+            if (mappings.get(i).isExactMatch(url)) {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Found exact URL match for: \" + url);\n", 
            "+                }\n", 
            "+                return filteredResources.get(i);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        int maxLength = 0;\n", 
            "+        Resource matchedResource = null;\n", 
            "+        for (int i = 0; i < count; i++) {\n", 
            "+            int length = mappings.get(i).getPrefixMatchingLength(url);\n", 
            "+            if (length > maxLength) {\n", 
            "+                maxLength = length;\n", 
            "+                matchedResource = filteredResources.get(i);\n", 
            "+            }\n", 
            "+        }\n", 
            "+        if (matchedResource != null) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Found path match for: \" + url + \" with matching length: \" + maxLength);\n", 
            "+            }\n", 
            "+            return matchedResource;\n", 
            "+        }\n", 
            "+\n", 
            "+        for (int i = 0; i < count; i++) {\n", 
            "+            if (mappings.get(i).isExtensionMatch(url)) {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Found extension match for: \" + url);\n", 
            "+                }\n", 
            "+                return filteredResources.get(i);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URLMappingBasedDispatcher.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URLMappingBasedDispatcher.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,26", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest.dispatch;\n", 
            "+\n", 
            "+public interface DispatcherHelper {\n", 
            "+\n", 
            "+    public String getString();\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/DispatcherHelper.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/DispatcherHelper.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,38", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest.dispatch;\n", 
            "+\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.rest.dispatch.RESTDispatcher;\n", 
            "+import org.apache.synapse.rest.Resource;\n", 
            "+\n", 
            "+import java.util.Collection;\n", 
            "+\n", 
            "+public class DefaultDispatcher implements RESTDispatcher {\n", 
            "+\n", 
            "+    public Resource findResource(MessageContext synCtx, Collection<Resource> resources) {\n", 
            "+        for (Resource resource : resources) {\n", 
            "+            if (resource.getDispatcherHelper() == null) {\n", 
            "+                return resource;\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/DefaultDispatcher.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/DefaultDispatcher.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,48", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest.dispatch;\n", 
            "+\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.wso2.uri.template.URITemplate;\n", 
            "+import org.wso2.uri.template.URITemplateException;\n", 
            "+\n", 
            "+public class URITemplateHelper implements DispatcherHelper {\n", 
            "+\n", 
            "+    private String templateString;\n", 
            "+\n", 
            "+    private URITemplate uriTemplate;\n", 
            "+\n", 
            "+    public URITemplateHelper(String templateString) {\n", 
            "+        this.templateString = templateString;\n", 
            "+        try {\n", 
            "+            this.uriTemplate = new URITemplate(templateString);\n", 
            "+        } catch (URITemplateException e) {\n", 
            "+            throw new SynapseException(\"Error while parsing the URI template\", e);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public URITemplate getUriTemplate() {\n", 
            "+        return uriTemplate;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getString() {\n", 
            "+        return templateString;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URITemplateHelper.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URITemplateHelper.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,66", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+\n", 
            "+/**\n", 
            "+ * Abstract representation of an entity that can process REST messages. The caller can\n", 
            "+ * first invoke the canProcess method of the processor to validate whether this processor\n", 
            "+ * can process the given request or not.\n", 
            "+ */\n", 
            "+public abstract class AbstractRESTProcessor {\n", 
            "+\n", 
            "+    protected Log log = LogFactory.getLog(getClass());\n", 
            "+\n", 
            "+    protected String name;\n", 
            "+\n", 
            "+    public AbstractRESTProcessor(String name) {\n", 
            "+        this.name = name;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Check whether this processor can handle the given request\n", 
            "+     *\n", 
            "+     * @param synCtx MessageContext of the message to be processed\n", 
            "+     * @return true if the processor is suitable for handling the message\n", 
            "+     */\n", 
            "+    abstract boolean canProcess(MessageContext synCtx);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Process the given message through this processor instance\n", 
            "+     *\n", 
            "+     * @param synCtx MessageContext of the message to be processed\n", 
            "+     */\n", 
            "+    abstract void process(MessageContext synCtx);\n", 
            "+\n", 
            "+    protected void handleException(String msg) {\n", 
            "+        log.error(msg);\n", 
            "+        throw new SynapseException(msg);\n", 
            "+    }\n", 
            "+\n", 
            "+    protected void handleException(String msg, Exception e) {\n", 
            "+        log.error(msg, e);\n", 
            "+        throw new SynapseException(msg, e);\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/AbstractRESTProcessor.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/AbstractRESTProcessor.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,89", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+import org.apache.axis2.Constants;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            "+\n", 
            "+import java.util.*;\n", 
            "+\n", 
            "+/**\n", 
            "+ * This class is responsible for receiving requests from various sources and dispatching\n", 
            "+ * them to a suitable REST API for further processing. This is the main entry point for\n", 
            "+ * mediating messages through APIs and Resources.\n", 
            "+ */\n", 
            "+public class RESTRequestHandler {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(RESTRequestHandler.class);\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Attempt to process the given message through one of the available APIs. This method\n", 
            "+     * will first try to locate a suitable API for the given message by running it through\n", 
            "+     * the API validation routines available. If a matching API is found it will dispatch\n", 
            "+     * the message to the located API. If a matching API cannot be found, message will be\n", 
            "+     * left intact so any other handlers (eg: main sequence) can pick it up later.\n", 
            "+     *\n", 
            "+     * @param synCtx MessageContext of the request to be processed\n", 
            "+     * @return true if the message was dispatched to an API and false otherwise\n", 
            "+     */\n", 
            "+    public boolean process(MessageContext synCtx) {\n", 
            "+        if (synCtx.isResponse()) {\n", 
            "+            return dispatchToAPI(synCtx);\n", 
            "+        }\n", 
            "+\n", 
            "+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).\n", 
            "+                getAxis2MessageContext();\n", 
            "+        String protocol = msgCtx.getIncomingTransportName();\n", 
            "+        if (!Constants.TRANSPORT_HTTP.equals(protocol) && !Constants.TRANSPORT_HTTPS.equals(protocol)) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Invalid protocol for REST API mediation: \" + protocol);\n", 
            "+            }\n", 
            "+            return false;\n", 
            "+        }\n", 
            "+\n", 
            "+        return dispatchToAPI(synCtx);\n", 
            "+    }\n", 
            "+\n", 
            "+    private boolean dispatchToAPI(MessageContext synCtx) {\n", 
            "+        Collection<API> apiSet = synCtx.getEnvironment().getSynapseConfiguration().getAPIs();\n", 
            "+        API defaultAPI = null;\n", 
            "+        for (API api : apiSet) {\n", 
            "+            if (\"/\".equals(api.getContext())) {\n", 
            "+                defaultAPI = api;\n", 
            "+            } else if (api.canProcess(synCtx)) {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Located specific API: \" + api.getName() + \" for processing message\");\n", 
            "+                }\n", 
            "+                api.process(synCtx);\n", 
            "+                return true;\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        if (defaultAPI != null && defaultAPI.canProcess(synCtx)) {\n", 
            "+            defaultAPI.process(synCtx);\n", 
            "+            return true;\n", 
            "+        }\n", 
            "+\n", 
            "+        return false;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/RESTRequestHandler.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/RESTRequestHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,311", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.rest;\n", 
            "+\n", 
            "+import org.apache.axis2.Constants;\n", 
            "+import org.apache.http.protocol.HTTP;\n", 
            "+import org.apache.synapse.ManagedLifecycle;\n", 
            "+import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.core.SynapseEnvironment;\n", 
            "+import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            "+import org.apache.synapse.rest.dispatch.DispatcherHelper;\n", 
            "+import org.apache.synapse.rest.dispatch.RESTDispatcher;\n", 
            "+import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            "+\n", 
            "+import java.util.*;\n", 
            "+\n", 
            "+public class API extends AbstractRESTProcessor implements ManagedLifecycle {\n", 
            "+\n", 
            "+    private String host;\n", 
            "+    private int port = -1;\n", 
            "+    private String context;\n", 
            "+    private Map<String,Resource> resources = new LinkedHashMap<String,Resource>();\n", 
            "+    private List<Handler> handlers = new ArrayList<Handler>();\n", 
            "+\n", 
            "+    private String fileName;\n", 
            "+\n", 
            "+    public API(String name, String context) {\n", 
            "+        super(name);\n", 
            "+        if (!context.startsWith(\"/\")) {\n", 
            "+            handleException(\"API context must begin with '/' character\");\n", 
            "+        }\n", 
            "+        this.context = RESTUtils.trimTrailingSlashes(context);\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getName() {\n", 
            "+        return name;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getContext() {\n", 
            "+        return context;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getHost() {\n", 
            "+        return host;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setHost(String host) {\n", 
            "+        this.host = host;\n", 
            "+    }\n", 
            "+\n", 
            "+    public int getPort() {\n", 
            "+        return port;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setPort(int port) {\n", 
            "+        this.port = port;\n", 
            "+    }\n", 
            "+\n", 
            "+    public String getFileName() {\n", 
            "+        return fileName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setFileName(String fileName) {\n", 
            "+        this.fileName = fileName;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void addResource(Resource resource) {\n", 
            "+        DispatcherHelper dispatcherHelper = resource.getDispatcherHelper();\n", 
            "+        if (dispatcherHelper != null) {\n", 
            "+            String mapping = dispatcherHelper.getString();\n", 
            "+            for (Resource r : resources.values()) {\n", 
            "+                DispatcherHelper helper = r.getDispatcherHelper();\n", 
            "+                if (helper != null && helper.getString().equals(mapping) &&\n", 
            "+                        resourceMatches(resource, r)) {\n", 
            "+                    handleException(\"Two resources cannot have the same path mapping and methods\");\n", 
            "+                }\n", 
            "+            }\n", 
            "+        } else {\n", 
            "+            for (Resource r : resources.values()) {\n", 
            "+                DispatcherHelper helper = r.getDispatcherHelper();\n", 
            "+                if (helper == null) {\n", 
            "+                    handleException(\"Only one resource can be designated as default\");\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+        resources.put(resource.getName(), resource);\n", 
            "+    }\n", 
            "+\n", 
            "+    private boolean resourceMatches(Resource r1, Resource r2) {\n", 
            "+        String[] methods1 = r1.getMethods();\n", 
            "+        String[] methods2 = r2.getMethods();\n", 
            "+        for (String m1 : methods1) {\n", 
            "+            for (String m2 : methods2) {\n", 
            "+                if (m1.equals(m2)) {\n", 
            "+                    return true;\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return false;\n", 
            "+    }\n", 
            "+\n", 
            "+    public Resource[] getResources() {\n", 
            "+        return resources.values().toArray(new Resource[resources.size()]);\n", 
            "+    }\n", 
            "+\n", 
            "+    public void addHandler(Handler handler) {\n", 
            "+        handlers.add(handler);\n", 
            "+    }\n", 
            "+\n", 
            "+    public Handler[] getHandlers() {\n", 
            "+        return handlers.toArray(new Handler[handlers.size()]);\n", 
            "+    }\n", 
            "+\n", 
            "+    boolean canProcess(MessageContext synCtx) {\n", 
            "+        if (synCtx.isResponse()) {\n", 
            "+            String apiName = (String) synCtx.getProperty(RESTConstants.SYNAPSE_REST_API);\n", 
            "+            if (!name.equals(apiName)) {\n", 
            "+                return false;\n", 
            "+            }\n", 
            "+        } else {\n", 
            "+            String path = RESTUtils.getFullRequestPath(synCtx);\n", 
            "+            if (!path.startsWith(context + \"/\") && !path.startsWith(context + \"?\") &&\n", 
            "+                    !context.equals(path) && !\"/\".equals(context)) {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"API context: \" + context + \" does not match request URI: \" + path);\n", 
            "+                }\n", 
            "+                return false;\n", 
            "+            }\n", 
            "+\n", 
            "+            if (host != null || port != -1) {\n", 
            "+                org.apache.axis2.context.MessageContext msgCtx =\n", 
            "+                        ((Axis2MessageContext) synCtx).getAxis2MessageContext();\n", 
            "+                String hostHeader = getHostHeader(msgCtx);\n", 
            "+                if (hostHeader != null) {\n", 
            "+                    if (host != null && !host.equals(extractHostName(hostHeader))) {\n", 
            "+                        if (log.isDebugEnabled()) {\n", 
            "+                            log.debug(\"API host: \" + host + \" does not match host information \" +\n", 
            "+                                    \"in the request: \" + hostHeader);\n", 
            "+                        }\n", 
            "+                        return false;\n", 
            "+                    }\n", 
            "+\n", 
            "+                    if (port != -1 && port != extractPortNumber(hostHeader,\n", 
            "+                            msgCtx.getIncomingTransportName())) {\n", 
            "+                        if (log.isDebugEnabled()) {\n", 
            "+                            log.debug(\"API port: \" + port + \" does not match port information \" +\n", 
            "+                                    \"in the request: \" + hostHeader);\n", 
            "+                        }\n", 
            "+                        return false;\n", 
            "+                    }\n", 
            "+                } else {\n", 
            "+                    if (log.isDebugEnabled()) {\n", 
            "+                        log.debug(\"Host information not available on the message\");\n", 
            "+                    }\n", 
            "+                    return false;\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        return true;\n", 
            "+    }\n", 
            "+\n", 
            "+    void process(MessageContext synCtx) {\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Processing message with ID: \" + synCtx.getMessageID() + \" through the \" +\n", 
            "+                    \"API: \" + name);\n", 
            "+        }\n", 
            "+\n", 
            "+        for (Handler handler : handlers) {\n", 
            "+            if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"Processing message with ID: \" + synCtx.getMessageID() + \" through \" +\n", 
            "+                        \"handler: \" + handler.getClass().getName());\n", 
            "+            }\n", 
            "+\n", 
            "+            boolean proceed;\n", 
            "+            if (synCtx.isResponse()) {\n", 
            "+                proceed = handler.handleResponse(synCtx);\n", 
            "+            } else {\n", 
            "+                proceed = handler.handleRequest(synCtx);\n", 
            "+            }\n", 
            "+\n", 
            "+            if (!proceed) {\n", 
            "+                return;\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        if (synCtx.isResponse()) {\n", 
            "+            String resourceName = (String) synCtx.getProperty(RESTConstants.SYNAPSE_RESOURCE);\n", 
            "+            if (resourceName != null) {\n", 
            "+                Resource resource = resources.get(resourceName);\n", 
            "+                if (resource != null) {\n", 
            "+                    resource.process(synCtx);\n", 
            "+                }\n", 
            "+            } else if (log.isDebugEnabled()) {\n", 
            "+                log.debug(\"No resource information on the response: \" + synCtx.getMessageID());\n", 
            "+            }\n", 
            "+            return;\n", 
            "+        }\n", 
            "+\n", 
            "+\n", 
            "+        synCtx.setProperty(RESTConstants.SYNAPSE_REST_API, name);\n", 
            "+        synCtx.setProperty(RESTConstants.REST_API_CONTEXT, context);\n", 
            "+        String path = RESTUtils.getFullRequestPath(synCtx);\n", 
            "+        String subPath = path.substring(context.length());\n", 
            "+        if (\"\".equals(subPath)) {\n", 
            "+            subPath = \"/\";\n", 
            "+        }\n", 
            "+        synCtx.setProperty(RESTConstants.REST_SUB_REQUEST_PATH, subPath);\n", 
            "+\n", 
            "+        org.apache.axis2.context.MessageContext msgCtx =\n", 
            "+                        ((Axis2MessageContext) synCtx).getAxis2MessageContext();\n", 
            "+        String hostHeader = getHostHeader(msgCtx);\n", 
            "+        if (hostHeader != null) {\n", 
            "+            synCtx.setProperty(RESTConstants.REST_URL_PREFIX,\n", 
            "+                    msgCtx.getIncomingTransportName() + \"://\" + hostHeader);\n", 
            "+        }\n", 
            "+\n", 
            "+        Set<Resource> acceptableResources = new HashSet<Resource>();\n", 
            "+        for (Resource r : resources.values()) {\n", 
            "+            if (r.canProcess(synCtx)) {\n", 
            "+                acceptableResources.add(r);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        boolean processed = false;\n", 
            "+        if (!acceptableResources.isEmpty()) {\n", 
            "+            for (RESTDispatcher dispatcher : RESTUtils.getDispatchers()) {\n", 
            "+                Resource resource = dispatcher.findResource(synCtx, acceptableResources);\n", 
            "+                if (resource != null) {\n", 
            "+                    resource.process(synCtx);\n", 
            "+                    processed = true;\n", 
            "+                    break;\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        if (!processed && log.isDebugEnabled()) {\n", 
            "+            log.debug(\"No matching resource was found for the request: \" + synCtx.getMessageID());\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private String getHostHeader(org.apache.axis2.context.MessageContext msgCtx) {\n", 
            "+        Map transportHeaders = (Map) msgCtx.getProperty(\n", 
            "+                org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);\n", 
            "+        String hostHeader = null;\n", 
            "+        if (transportHeaders != null) {\n", 
            "+            hostHeader = (String) transportHeaders.get(HTTP.TARGET_HOST);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (hostHeader == null) {\n", 
            "+            hostHeader = (String) msgCtx.getProperty(NhttpConstants.SERVICE_PREFIX);\n", 
            "+        }\n", 
            "+        return hostHeader;\n", 
            "+    }\n", 
            "+\n", 
            "+    private String extractHostName(String hostHeader) {\n", 
            "+        int index = hostHeader.indexOf(':');\n", 
            "+        if (index != -1) {\n", 
            "+            return hostHeader.substring(0, index);\n", 
            "+        } else {\n", 
            "+            return hostHeader;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private int extractPortNumber(String hostHeader, String transport) {\n", 
            "+        int index = hostHeader.indexOf(':');\n", 
            "+        if (index != -1) {\n", 
            "+            return Integer.parseInt(hostHeader.substring(index + 1));\n", 
            "+        } else if (Constants.TRANSPORT_HTTP.equals(transport)) {\n", 
            "+            return 80;\n", 
            "+        } else {\n", 
            "+            return 443;\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public void init(SynapseEnvironment se) {\n", 
            "+        if (resources.isEmpty()) {\n", 
            "+            handleException(\"The API: \" + name + \" has been configured without \" +\n", 
            "+                    \"any resource definitions\");\n", 
            "+        }\n", 
            "+\n", 
            "+        log.info(\"Initializing API: \" + name);\n", 
            "+        for (Resource resource : resources.values()) {\n", 
            "+            resource.init(se);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public void destroy() {\n", 
            "+        log.info(\"Destroying API: \" + name);\n", 
            "+        for (Resource resource : resources.values()) {\n", 
            "+            resource.destroy();\n", 
            "+        }\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/rest/API.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/rest/API.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-45,6 +45,7", 
          "lines": [
            " import org.apache.synapse.mediators.base.SequenceMediator;\n", 
            " import org.apache.synapse.registry.Registry;\n", 
            " import org.apache.axiom.om.OMNode;\n", 
            "+import org.apache.synapse.rest.API;\n", 
            " \n", 
            " import javax.xml.namespace.QName;\n", 
            " import java.io.IOException;\n"
          ]
        }, 
        {
          "locn": "-148,6 +149,8", 
          "lines": [
            "      */\n", 
            "     private Map<String, Template> endpointTemplates = new ConcurrentHashMap<String, Template>();\n", 
            " \n", 
            "+    private Map<String, API> apiTable = new ConcurrentHashMap<String, API>();\n", 
            "+\n", 
            "     /**\n", 
            "      * Description/documentation of the configuration\n", 
            "      */\n"
          ]
        }, 
        {
          "locn": "-299,6 +302,51", 
          "lines": [
            "         return definedTemplates;\n", 
            "     }\n", 
            " \n", 
            "+    public void addAPI(String name, API api) {\n", 
            "+        if (!apiTable.containsKey(name)) {\n", 
            "+            for (API existingAPI : apiTable.values()) {\n", 
            "+                if (existingAPI.getContext().equals(api.getContext())) {\n", 
            "+                    handleException(\"URL context: \" + api.getContext() + \" is already registered\" +\n", 
            "+                            \" with the API: \" + existingAPI.getName());\n", 
            "+                }\n", 
            "+            }\n", 
            "+            apiTable.put(name, api);\n", 
            "+        } else {\n", 
            "+            handleException(\"Duplicate resource definition by the name: \" + name);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public void updateAPI(String name, API api) {\n", 
            "+        if (!apiTable.containsKey(name)) {\n", 
            "+            handleException(\"No API exists by the name: \" + name);\n", 
            "+        } else {\n", 
            "+            for (API existingAPI : apiTable.values()) {\n", 
            "+                if (existingAPI.getContext().equals(api.getContext()) && !name.equals(api.getName())) {\n", 
            "+                    handleException(\"URL context: \" + api.getContext() + \" is already registered\" +\n", 
            "+                            \" with the API: \" + existingAPI.getName());\n", 
            "+                }\n", 
            "+            }\n", 
            "+            apiTable.put(name, api);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    public Collection<API> getAPIs() {\n", 
            "+        return Collections.unmodifiableCollection(apiTable.values());\n", 
            "+    }\n", 
            "+\n", 
            "+    public API getAPI(String name) {\n", 
            "+        return apiTable.get(name);\n", 
            "+    }\n", 
            "+\n", 
            "+    public void removeAPI(String name) {\n", 
            "+        API api = apiTable.get(name);\n", 
            "+        if (api != null) {\n", 
            "+            apiTable.remove(name);\n", 
            "+        } else {\n", 
            "+            handleException(\"No API exists by the name: \" + name);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "      /**\n", 
            "      * Return the template specified with the given key\n", 
            "      *\n"
          ]
        }, 
        {
          "locn": "-1264,8 +1312,9", 
          "lines": [
            "             mp.destroy();\n", 
            "         }\n", 
            " \n", 
            "-\n", 
            "-\n", 
            "+        for (API api : apiTable.values()) {\n", 
            "+            api.destroy();\n", 
            "+        }\n", 
            "     }\n", 
            " \n", 
            "     /**\n"
          ]
        }, 
        {
          "locn": "-1344,6 +1393,10", 
          "lines": [
            "         for(MessageProcessor messageProcessor : messageProcessors.values()) {\n", 
            "             messageProcessor.init(se);\n", 
            "         }\n", 
            "+\n", 
            "+        for (API api : apiTable.values()) {\n", 
            "+            api.init(se);\n", 
            "+        }\n", 
            "     }\n", 
            " \n", 
            "     private void handleException(String msg) {\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-77,16 +77,17", 
          "lines": [
            "  */\n", 
            " public class MultiXMLConfigurationBuilder {\n", 
            " \n", 
            "-    public static final String PROXY_SERVICES_DIR  = \"proxy-services\";\n", 
            "-    public static final String SEQUENCES_DIR       = \"sequences\";\n", 
            "-    public static final String TEMPLATES_DIR       = \"templates\";\n", 
            "-    public static final String ENDPOINTS_DIR       = \"endpoints\";\n", 
            "-    public static final String LOCAL_ENTRY_DIR     = \"local-entries\";\n", 
            "-    public static final String TASKS_DIR           = \"tasks\";\n", 
            "-    public static final String EVENTS_DIR          = \"event-sources\";\n", 
            "-    public static final String EXECUTORS_DIR       = \"priority-executors\";\n", 
            "-    public static final String MESSAGE_STORE_DIR   = \"message-stores\";\n", 
            "-    public static final String MESSAGE_PROCESSOR_DIR   = \"message-processors\";\n", 
            "+    public static final String PROXY_SERVICES_DIR       = \"proxy-services\";\n", 
            "+    public static final String SEQUENCES_DIR            = \"sequences\";\n", 
            "+    public static final String TEMPLATES_DIR            = \"templates\";\n", 
            "+    public static final String ENDPOINTS_DIR            = \"endpoints\";\n", 
            "+    public static final String LOCAL_ENTRY_DIR          = \"local-entries\";\n", 
            "+    public static final String TASKS_DIR                = \"tasks\";\n", 
            "+    public static final String EVENTS_DIR               = \"event-sources\";\n", 
            "+    public static final String EXECUTORS_DIR            = \"priority-executors\";\n", 
            "+    public static final String MESSAGE_STORE_DIR        = \"message-stores\";\n", 
            "+    public static final String MESSAGE_PROCESSOR_DIR    = \"message-processors\";\n", 
            "+    public static final String REST_API_DIR             = \"api\";\n", 
            " \n", 
            "     public static final String REGISTRY_FILE       = \"registry.xml\";\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MultiXMLConfigurationBuilder.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MultiXMLConfigurationBuilder.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,134", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.config.xml.rest;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMAttribute;\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axis2.Constants;\n", 
            "+import org.apache.commons.logging.Log;\n", 
            "+import org.apache.commons.logging.LogFactory;\n", 
            "+import org.apache.synapse.SynapseException;\n", 
            "+import org.apache.synapse.config.xml.SequenceMediatorFactory;\n", 
            "+import org.apache.synapse.config.xml.XMLConfigConstants;\n", 
            "+import org.apache.synapse.mediators.base.SequenceMediator;\n", 
            "+import org.apache.synapse.rest.RESTConstants;\n", 
            "+import org.apache.synapse.rest.Resource;\n", 
            "+import org.apache.synapse.rest.dispatch.URLMappingHelper;\n", 
            "+import org.apache.synapse.rest.dispatch.URITemplateHelper;\n", 
            "+\n", 
            "+import javax.xml.namespace.QName;\n", 
            "+import java.util.Properties;\n", 
            "+\n", 
            "+public class ResourceFactory {\n", 
            "+\n", 
            "+    private static final Log log = LogFactory.getLog(ResourceFactory.class);\n", 
            "+\n", 
            "+    public static Resource createResource(OMElement resourceElt) {\n", 
            "+        Resource resource = new Resource();\n", 
            "+        configureURLMappings(resource, resourceElt);\n", 
            "+        configureSequences(resource, resourceElt);\n", 
            "+        configureFilters(resource, resourceElt);\n", 
            "+        return resource;\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void configureFilters(Resource resource, OMElement resourceElt) {\n", 
            "+        OMAttribute protocolAtt = resourceElt.getAttribute(new QName(\"protocol\"));\n", 
            "+        if (protocolAtt != null && !\"\".equals(protocolAtt.getAttributeValue())) {\n", 
            "+            if (Constants.TRANSPORT_HTTP.equals(protocolAtt.getAttributeValue())) {\n", 
            "+                resource.setProtocol(RESTConstants.PROTOCOL_HTTP_ONLY);\n", 
            "+            } else if (Constants.TRANSPORT_HTTPS.equals(protocolAtt.getAttributeValue())) {\n", 
            "+                resource.setProtocol(RESTConstants.PROTOCOL_HTTPS_ONLY);\n", 
            "+            } else {\n", 
            "+                handleException(\"Invalid protocol name: \" + protocolAtt.getAttributeValue());\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        OMAttribute contentTypeAtt = resourceElt.getAttribute(new QName(\"content-type\"));\n", 
            "+        if (contentTypeAtt != null && !\"\".equals(contentTypeAtt.getAttributeValue())) {\n", 
            "+            resource.setContentType(contentTypeAtt.getAttributeValue());\n", 
            "+        }\n", 
            "+\n", 
            "+        OMAttribute userAgentAtt = resourceElt.getAttribute(new QName(\"user-agent\"));\n", 
            "+        if (userAgentAtt != null && !\"\".equals(userAgentAtt.getAttributeValue())) {\n", 
            "+            resource.setUserAgent(userAgentAtt.getAttributeValue());\n", 
            "+        }\n", 
            "+\n", 
            "+        OMAttribute methodsAtt = resourceElt.getAttribute(new QName(\"methods\"));\n", 
            "+        if (methodsAtt != null && !\"\".equals(methodsAtt.getAttributeValue())) {\n", 
            "+            String[] methods = methodsAtt.getAttributeValue().trim().split(\" \");\n", 
            "+            for (String method : methods) {\n", 
            "+                boolean added = resource.addMethod(method);\n", 
            "+                if (!added) {\n", 
            "+                    handleException(\"Invalid or duplicate method definition for resource\");\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void configureURLMappings(Resource resource, OMElement resourceElt) {\n", 
            "+        OMAttribute urlMappingAtt = resourceElt.getAttribute(new QName(\"url-mapping\"));\n", 
            "+        OMAttribute uriTemplateAtt = resourceElt.getAttribute(new QName(\"uri-template\"));\n", 
            "+        if (urlMappingAtt != null && !\"\".equals(urlMappingAtt.getAttributeValue())) {\n", 
            "+            resource.setDispatcherHelper(new URLMappingHelper(urlMappingAtt.getAttributeValue()));\n", 
            "+        } else if (uriTemplateAtt != null && !\"\".equals(uriTemplateAtt.getAttributeValue())) {\n", 
            "+            resource.setDispatcherHelper(new URITemplateHelper(uriTemplateAtt.getAttributeValue()));\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void configureSequences(Resource resource, OMElement resourceElt) {\n", 
            "+        OMAttribute inSequenceKeyAtt = resourceElt.getAttribute(new QName(\"inSequence\"));\n", 
            "+        OMElement inSequenceElt = resourceElt.getFirstChildWithName(new QName(\n", 
            "+                XMLConfigConstants.SYNAPSE_NAMESPACE, \"inSequence\"));\n", 
            "+        if (inSequenceKeyAtt != null && !\"\".equals(inSequenceKeyAtt.getAttributeValue())) {\n", 
            "+            resource.setInSequenceKey(inSequenceKeyAtt.getAttributeValue());\n", 
            "+        } else if (inSequenceElt != null) {\n", 
            "+            SequenceMediatorFactory fac = new SequenceMediatorFactory();\n", 
            "+            SequenceMediator sequence = fac.createAnonymousSequence(inSequenceElt, new Properties());\n", 
            "+            resource.setInSequence(sequence);\n", 
            "+        }\n", 
            "+\n", 
            "+        OMAttribute outSequenceKeyAtt = resourceElt.getAttribute(new QName(\"outSequence\"));\n", 
            "+        OMElement outSequenceElt = resourceElt.getFirstChildWithName(new QName(\n", 
            "+                XMLConfigConstants.SYNAPSE_NAMESPACE, \"outSequence\"));\n", 
            "+        if (outSequenceKeyAtt != null && !\"\".equals(outSequenceKeyAtt.getAttributeValue())) {\n", 
            "+            resource.setOutSequenceKey(outSequenceKeyAtt.getAttributeValue());\n", 
            "+        } else if (outSequenceElt != null) {\n", 
            "+            SequenceMediatorFactory fac = new SequenceMediatorFactory();\n", 
            "+            SequenceMediator sequence = fac.createAnonymousSequence(outSequenceElt, new Properties());\n", 
            "+            resource.setOutSequence(sequence);\n", 
            "+        }\n", 
            "+\n", 
            "+        OMAttribute faultSequenceKeyAtt = resourceElt.getAttribute(new QName(\"faultSequence\"));\n", 
            "+        OMElement faultSequenceElt = resourceElt.getFirstChildWithName(new QName(\n", 
            "+                XMLConfigConstants.SYNAPSE_NAMESPACE, \"faultSequence\"));\n", 
            "+        if (faultSequenceKeyAtt != null && !\"\".equals(faultSequenceKeyAtt.getAttributeValue())) {\n", 
            "+            resource.setFaultSequenceKey(faultSequenceKeyAtt.getAttributeValue());\n", 
            "+        } else if (faultSequenceElt != null) {\n", 
            "+            SequenceMediatorFactory fac = new SequenceMediatorFactory();\n", 
            "+            SequenceMediator sequence = fac.createAnonymousSequence(faultSequenceElt, new Properties());\n", 
            "+            resource.setFaultSequence(sequence);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    private static void handleException(String msg) {\n", 
            "+        log.error(msg);\n", 
            "+        throw new SynapseException(msg);\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/ResourceFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/ResourceFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,63", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.config.xml.rest;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMAbstractFactory;\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axiom.om.OMFactory;\n", 
            "+import org.apache.synapse.SynapseConstants;\n", 
            "+import org.apache.synapse.rest.API;\n", 
            "+import org.apache.synapse.rest.Handler;\n", 
            "+import org.apache.synapse.rest.Resource;\n", 
            "+\n", 
            "+public class APISerializer {\n", 
            "+\n", 
            "+    private static final OMFactory fac = OMAbstractFactory.getOMFactory();\n", 
            "+\n", 
            "+    public static OMElement serializeAPI(API api) {\n", 
            "+        OMElement apiElt = fac.createOMElement(\"api\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            "+        apiElt.addAttribute(\"name\", api.getName(), null);\n", 
            "+        apiElt.addAttribute(\"context\", api.getContext(), null);\n", 
            "+        if (api.getHost() != null) {\n", 
            "+            apiElt.addAttribute(\"hostname\", api.getHost(), null);\n", 
            "+        }\n", 
            "+        if (api.getPort() != -1) {\n", 
            "+            apiElt.addAttribute(\"port\", String.valueOf(api.getPort()), null);\n", 
            "+        }\n", 
            "+\n", 
            "+        Resource[] resources = api.getResources();\n", 
            "+        for (Resource r : resources) {\n", 
            "+            OMElement resourceElt = ResourceSerializer.serializeResource(r);\n", 
            "+            apiElt.addChild(resourceElt);\n", 
            "+        }\n", 
            "+\n", 
            "+        Handler[] handlers = api.getHandlers();\n", 
            "+        if (handlers.length > 0) {\n", 
            "+            OMElement handlersElt = fac.createOMElement(\"handlers\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            "+            for (Handler handler : handlers) {\n", 
            "+                OMElement handlerElt = fac.createOMElement(\"handler\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            "+                handlerElt.addAttribute(\"class\", handler.getClass().getName(), null);\n", 
            "+                handlersElt.addChild(handlerElt);\n", 
            "+            }\n", 
            "+            apiElt.addChild(handlersElt);\n", 
            "+        }\n", 
            "+        return apiElt;\n", 
            "+    }\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/APISerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/APISerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-149,6 +149,7", 
          "lines": [
            "                             org.apache.synapse.message.*,\n", 
            "                             org.apache.synapse.metrics.*,\n", 
            "                             org.apache.synapse.registry.*,\n", 
            "+                            org.apache.synapse.rest.*,\n", 
            "                             org.apache.synapse.startup.*,\n", 
            "                             org.apache.synapse.util.*,\n", 
            "                         </Export-Package>\n"
          ]
        }
      ], 
      "to": "java/modules/core/pom.xml", 
      "from": "java/modules/core/pom.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,100", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.config.xml.rest;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMAbstractFactory;\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axiom.om.OMFactory;\n", 
            "+import org.apache.synapse.SynapseConstants;\n", 
            "+import org.apache.synapse.config.xml.SequenceMediatorSerializer;\n", 
            "+import org.apache.synapse.rest.RESTConstants;\n", 
            "+import org.apache.synapse.rest.Resource;\n", 
            "+import org.apache.synapse.rest.dispatch.DispatcherHelper;\n", 
            "+import org.apache.synapse.rest.dispatch.URITemplateHelper;\n", 
            "+import org.apache.synapse.rest.dispatch.URLMappingHelper;\n", 
            "+\n", 
            "+public class ResourceSerializer {\n", 
            "+\n", 
            "+    private static final OMFactory fac = OMAbstractFactory.getOMFactory();\n", 
            "+\n", 
            "+    public static OMElement serializeResource(Resource resource) {\n", 
            "+        OMElement resourceElt = fac.createOMElement(\"resource\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            "+        String[] methods = resource.getMethods();\n", 
            "+        if (methods.length > 0) {\n", 
            "+            String value = \"\";\n", 
            "+            for (String method : methods) {\n", 
            "+                value += method + \" \";\n", 
            "+            }\n", 
            "+            resourceElt.addAttribute(\"methods\", value.trim(), null);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (resource.getContentType() != null) {\n", 
            "+            resourceElt.addAttribute(\"content-type\", resource.getContentType(), null);\n", 
            "+        }\n", 
            "+        if (resource.getUserAgent() != null) {\n", 
            "+            resourceElt.addAttribute(\"user-agent\", resource.getUserAgent(), null);\n", 
            "+        }\n", 
            "+        if (resource.getProtocol() == RESTConstants.PROTOCOL_HTTP_ONLY) {\n", 
            "+            resourceElt.addAttribute(\"protocol\", \"http\", null);\n", 
            "+        } else if (resource.getProtocol() == RESTConstants.PROTOCOL_HTTPS_ONLY) {\n", 
            "+            resourceElt.addAttribute(\"protocol\", \"https\", null);\n", 
            "+        }\n", 
            "+\n", 
            "+        DispatcherHelper helper = resource.getDispatcherHelper();\n", 
            "+        if (helper != null) {\n", 
            "+            if (helper instanceof URLMappingHelper) {\n", 
            "+                resourceElt.addAttribute(\"url-mapping\", helper.getString(), null);\n", 
            "+            } else if (helper instanceof URITemplateHelper) {\n", 
            "+                resourceElt.addAttribute(\"uri-template\", helper.getString(), null);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        SequenceMediatorSerializer seqSerializer = new SequenceMediatorSerializer();\n", 
            "+        if (resource.getInSequenceKey() != null) {\n", 
            "+            resourceElt.addAttribute(\"inSequence\", resource.getInSequenceKey(), null);\n", 
            "+        } else if (resource.getInSequence() != null) {\n", 
            "+            OMElement inSeqElement = seqSerializer.serializeAnonymousSequence(\n", 
            "+                    null, resource.getInSequence());\n", 
            "+            inSeqElement.setLocalName(\"inSequence\");\n", 
            "+            resourceElt.addChild(inSeqElement);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (resource.getOutSequenceKey() != null) {\n", 
            "+            resourceElt.addAttribute(\"outSequence\", resource.getOutSequenceKey(), null);\n", 
            "+        } else if (resource.getOutSequence() != null) {\n", 
            "+            OMElement outSeqElement = seqSerializer.serializeAnonymousSequence(\n", 
            "+                    null, resource.getOutSequence());\n", 
            "+            outSeqElement.setLocalName(\"outSequence\");\n", 
            "+            resourceElt.addChild(outSeqElement);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (resource.getFaultSequenceKey() != null) {\n", 
            "+            resourceElt.addAttribute(\"faultSequence\", resource.getFaultSequenceKey(), null);\n", 
            "+        } else if (resource.getFaultSequence() != null) {\n", 
            "+            OMElement faultSeqElement = seqSerializer.serializeAnonymousSequence(\n", 
            "+                    null, resource.getFaultSequence());\n", 
            "+            faultSeqElement.setLocalName(\"faultSequence\");\n", 
            "+            resourceElt.addChild(faultSeqElement);\n", 
            "+        }\n", 
            "+\n", 
            "+        return resourceElt;\n", 
            "+    }\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/ResourceSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/ResourceSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-1,20 +1,22", 
          "lines": [
            " /*\n", 
            "-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "-*\n", 
            "-*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "-*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "-*  in compliance with the License.\n", 
            "-*  You may obtain a copy of the License at\n", 
            "-*\n", 
            "-*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "-*\n", 
            "-* Unless required by applicable law or agreed to in writing,\n", 
            "-* software distributed under the License is distributed on an\n", 
            "-* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "-* KIND, either express or implied.  See the License for the\n", 
            "-* specific language governing permissions and limitations\n", 
            "-* under the License.\n", 
            "-*/\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            " package org.apache.synapse.message.processors.sampler;\n", 
            " \n", 
            " /**\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/message/processors/sampler/SamplingProcessorViewMBean.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/message/processors/sampler/SamplingProcessorViewMBean.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-92,6 +92,7", 
          "lines": [
            "     <deployer extension=\"xml\" directory=\"conf/synapse-config/templates\" class=\"org.apache.synapse.deployers.TemplateDeployer\"/>\n", 
            "     <deployer extension=\"xml\" directory=\"conf/synapse-config/message-stores\" class=\"org.apache.synapse.deployers.MessageStoreDeployer\"/>\n", 
            "     <deployer extension=\"xml\" directory=\"conf/synapse-config/message-processors\" class=\"org.apache.synapse.deployers.MessageProcessorDeployer\"/>\n", 
            "+    <deployer extension=\"xml\" directory=\"conf/synapse-config/api\" class=\"org.apache.synapse.deployers.APIDeployer\"/>\n", 
            " \n", 
            "     <!-- Following parameter will set the host name for the epr-->\n", 
            "     <!--<parameter name=\"hostname\" locked=\"true\">myhost.com</parameter>-->\n"
          ]
        }
      ], 
      "to": "java/repository/conf/axis2.xml", 
      "from": "java/repository/conf/axis2.xml"
    }
  ], 
  "id": "1214211"
}