{
  "when": "2013-07-13T01:49:38-04:00", 
  "message": "Further cleaned up the pass thru transport impl", 
  "who": "hiranya", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-27,7 +27,6", 
          "lines": [
            " import org.apache.axis2.transport.http.SOAPMessageFormatter;\n", 
            " import org.apache.commons.logging.Log;\n", 
            " import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.synapse.transport.passthru.util.DeferredMessageBuilder;\n", 
            " \n", 
            " import javax.activation.DataHandler;\n", 
            " import javax.activation.DataSource;\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/ExpandingMessageFormatter.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/ExpandingMessageFormatter.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-32,7 +32,6", 
          "lines": [
            " \n", 
            " import java.util.HashMap;\n", 
            " import java.util.Map;\n", 
            "-import java.util.Set;\n", 
            " \n", 
            " public class SourceResponseFactory {\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-39,30 +38,29", 
          "lines": [
            "     public static SourceResponse create(MessageContext msgContext,\n", 
            "                                         SourceRequest sourceRequest,\n", 
            "                                         SourceConfiguration sourceConfiguration) {\n", 
            "+\n", 
            "         // determine the status code to be sent\n", 
            "         int statusCode = PassThroughTransportUtils.determineHttpStatusCode(msgContext);\n", 
            "+        SourceResponse sourceResponse = new SourceResponse(sourceConfiguration,\n", 
            "+                statusCode, sourceRequest);\n", 
            " \n", 
            "-        SourceResponse sourceResponse =\n", 
            "-                new SourceResponse(sourceConfiguration, statusCode, sourceRequest);\n", 
            "-\n", 
            "         // set any transport headers\n", 
            "         Map transportHeaders = (Map) msgContext.getProperty(MessageContext.TRANSPORT_HEADERS);\n", 
            "-\n", 
            "         if (transportHeaders != null) {\n", 
            "             addResponseHeader(sourceResponse, transportHeaders);\n", 
            "-        }else{\n", 
            "-        \t  Boolean noEntityBody = (Boolean) msgContext.getProperty(NhttpConstants.NO_ENTITY_BODY);\n", 
            "+        } else {\n", 
            "+        \t Boolean noEntityBody = (Boolean) msgContext.getProperty(NhttpConstants.NO_ENTITY_BODY);\n", 
            "         \t if (noEntityBody == null || Boolean.FALSE == noEntityBody) {\n", 
            "         \t\t OMOutputFormat format = NhttpUtil.getOMOutputFormat(msgContext);\n", 
            "         \t\t transportHeaders = new HashMap();\n", 
            "             \t MessageFormatter messageFormatter =\n", 
            "                      MessageFormatterDecoratorFactory.createMessageFormatterDecorator(msgContext);\n", 
            "-            \t transportHeaders.put(HTTP.CONTENT_TYPE, messageFormatter.getContentType(msgContext, format, msgContext.getSoapAction()));\n", 
            "+            \t transportHeaders.put(HTTP.CONTENT_TYPE, messageFormatter.getContentType(\n", 
            "+                         msgContext, format, msgContext.getSoapAction()));\n", 
            "             \t addResponseHeader(sourceResponse, transportHeaders);\n", 
            "              }\n", 
            "         \t \n", 
            "         }\n", 
            "-\n", 
            "         return sourceResponse;\n", 
            "     }\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/SourceResponseFactory.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/SourceResponseFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-22,11 +22,9", 
          "lines": [
            " import org.apache.axiom.om.OMOutputFormat;\n", 
            " import org.apache.axis2.AxisFault;\n", 
            " import org.apache.axis2.Constants;\n", 
            "-//import org.apache.axis2.util.MessageProcessorSelector;\n", 
            " import org.apache.axis2.addressing.EndpointReference;\n", 
            " import org.apache.axis2.context.MessageContext;\n", 
            " import org.apache.axis2.transport.MessageFormatter;\n", 
            "-import org.apache.axis2.transport.TransportUtils;\n", 
            " import org.apache.axis2.transport.http.HTTPConstants;\n", 
            " import org.apache.axis2.transport.http.SOAPMessageFormatter;\n", 
            " import org.apache.axis2.util.MessageProcessorSelector;\n"
          ]
        }, 
        {
          "locn": "-45,7 +43,7", 
          "lines": [
            " \n", 
            " public class TargetRequestFactory {\n", 
            "     \n", 
            "-\tprivate static Log log = LogFactory.getLog(TargetRequestFactory.class);\n", 
            "+\tprivate static final Log log = LogFactory.getLog(TargetRequestFactory.class);\n", 
            " \n", 
            "     public static TargetRequest create(MessageContext msgContext,\n", 
            "                                        TargetConfiguration configuration) throws AxisFault {\n"
          ]
        }, 
        {
          "locn": "-57,10 +55,10", 
          "lines": [
            "             }\n", 
            " \n", 
            "             // basic request\n", 
            "-            Boolean noEntityBody = (Boolean) msgContext.getProperty(PassThroughConstants.NO_ENTITY_BODY);\n", 
            "-            \n", 
            "-            if(msgContext.getEnvelope().getBody().getFirstElement() != null){\n", 
            "-            \tnoEntityBody  =false;\n", 
            "+            Boolean noEntityBody = (Boolean) msgContext.getProperty(\n", 
            "+                    PassThroughConstants.NO_ENTITY_BODY);\n", 
            "+            if (msgContext.getEnvelope().getBody().getFirstElement() != null){\n", 
            "+            \tnoEntityBody  = false;\n", 
            "             }\n", 
            " \n", 
            "             EndpointReference epr = PassThroughTransportUtils.getDestinationEPR(msgContext);\n"
          ]
        }, 
        {
          "locn": "-73,7 +71,6", 
          "lines": [
            "                     configuration.isPreserveServerHeader(),\n", 
            "                     configuration.isPreserveUserAgentHeader());\n", 
            " \n", 
            "-\n", 
            "             Object o = msgContext.getProperty(MessageContext.TRANSPORT_HEADERS);\n", 
            "             if (o != null && o instanceof Map) {\n", 
            "                 Map headers = (Map) o;\n"
          ]
        }, 
        {
          "locn": "-84,10 +81,11", 
          "lines": [
            "                             entry.getValue() instanceof String) {\n", 
            "                         if (!HTTPConstants.HEADER_HOST.equalsIgnoreCase((String) entry.getKey())) {\n", 
            "                             request.addHeader((String) entry.getKey(), (String) entry.getValue());\n", 
            "-                        }else {\n", 
            "-                            if(msgContext.getProperty(NhttpConstants.REQUEST_HOST_HEADER) != null) {\n", 
            "-                            \trequest.addHeader((String) (String) entry.getKey(),\n", 
            "-                                        (String)msgContext.getProperty(NhttpConstants.REQUEST_HOST_HEADER));\n", 
            "+                        } else {\n", 
            "+                            if( msgContext.getProperty(NhttpConstants.REQUEST_HOST_HEADER) != null) {\n", 
            "+                            \trequest.addHeader((String) entry.getKey(),\n", 
            "+                                        (String) msgContext.getProperty(\n", 
            "+                                                NhttpConstants.REQUEST_HOST_HEADER));\n", 
            "                             }\n", 
            "                         }\n", 
            "                     }\n"
          ]
        }, 
        {
          "locn": "-100,7 +98,8", 
          "lines": [
            "             }\n", 
            " \n", 
            "             // version\n", 
            "-            String forceHttp10 = (String) msgContext.getProperty(PassThroughConstants.FORCE_HTTP_1_0);\n", 
            "+            String forceHttp10 = (String) msgContext.getProperty(\n", 
            "+                    PassThroughConstants.FORCE_HTTP_1_0);\n", 
            "             if (\"true\".equals(forceHttp10)) {\n", 
            "                 request.setVersion(HttpVersion.HTTP_1_0);\n", 
            "             }\n"
          ]
        }, 
        {
          "locn": "-142,7 +141,8", 
          "lines": [
            "         \n", 
            "         if (formatter != null) {\n", 
            "             String contentType= formatter.getContentType(msgCtx, format, msgCtx.getSoapAction());\n", 
            "-          //keep the formatter information to prevent multipart boundary override (this will be the content writing to header)\n", 
            "+              //keep the formatter information to prevent multipart boundary override\n", 
            "+              // (this will be the content writing to header)\n", 
            "             msgCtx.setProperty(PassThroughConstants.MESSAGE_OUTPUT_FORMAT, format);\n", 
            "             return contentType;\n", 
            "             \n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/TargetRequestFactory.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/TargetRequestFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-74,7 +74,7", 
          "lines": [
            "      * need to cache it if it has not\n", 
            "      * already cached.\n", 
            "      *\n", 
            "-     * @param lastUse\n", 
            "+     * @param lastUse Boolean value to set\n", 
            "      */\n", 
            "     public void setLastUse(boolean lastUse) {\n", 
            "         this.lastUse = lastUse;\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/StreamingOnRequestDataSource.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/StreamingOnRequestDataSource.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-16,6 +16,7", 
          "lines": [
            "  *  specific language governing permissions and limitations\n", 
            "  *  under the License.\n", 
            "  */\n", 
            "+\n", 
            " package org.apache.synapse.transport.passthru.util;\n", 
            " \n", 
            " import org.apache.axiom.om.OMElement;\n"
          ]
        }, 
        {
          "locn": "-41,7 +42,6", 
          "lines": [
            " import java.io.IOException;\n", 
            " import java.io.InputStream;\n", 
            " import java.util.HashMap;\n", 
            "-import java.util.Iterator;\n", 
            " import java.util.Map;\n", 
            " \n", 
            " public class DeferredMessageBuilder {\n"
          ]
        }, 
        {
          "locn": "-76,14 +76,6", 
          "lines": [
            "         return builders;\n", 
            "     }\n", 
            " \n", 
            "-    public void addBuilder(String contentType, Builder builder) {\n", 
            "-        builders.put(contentType, builder);\n", 
            "-    }\n", 
            "-\n", 
            "-    public void addFormatter(String contentType, MessageFormatter messageFormatter) {\n", 
            "-        formatters.put(contentType, messageFormatter);\n", 
            "-    }\n", 
            "-\n", 
            "     public Map<String, MessageFormatter> getFormatters() {\n", 
            "         return formatters;\n", 
            "     }\n"
          ]
        }, 
        {
          "locn": "-90,42 +82,36", 
          "lines": [
            " \n", 
            "     public OMElement getDocument(MessageContext msgCtx, InputStream in) throws\n", 
            "             XMLStreamException, IOException {\n", 
            "-   \t  \n", 
            "-    \t\n", 
            "-    \tString contentType = (String) msgCtx.getProperty(Constants.Configuration.CONTENT_TYPE);\n", 
            "-    \tString _contentType =contentType;\n", 
            "- \t    in = HTTPTransportUtils.handleGZip(msgCtx, in);\n", 
            "- \t\tif (contentType != null) {\n", 
            "- \t\t\tint j = contentType.indexOf(\";\");\n", 
            "- \t\t\tif (j > 0) {\n", 
            "- \t\t\t\t_contentType = contentType.substring(0, j);\n", 
            "- \t\t\t}\n", 
            "- \t\t}\n", 
            "-    \t\n", 
            "-    \t\n", 
            "-    \tAxisConfiguration configuration =\n", 
            "-    \t\t  msgCtx.getConfigurationContext().getAxisConfiguration();\n", 
            "-      Parameter useFallbackParameter = configuration.getParameter(Constants.Configuration.USE_DEFAULT_FALLBACK_BUILDER);\n", 
            "-     \n", 
            "-      boolean useFallbackBuilder = false;\n", 
            "-      \n", 
            "-      if (useFallbackParameter !=null){\n", 
            "-      \tuseFallbackBuilder = JavaUtils.isTrueExplicitly(useFallbackParameter.getValue(),useFallbackBuilder);\n", 
            "-      }\n", 
            "-    \t\n", 
            "-    \tOMElement element = null;\n", 
            "+\n", 
            "+\n", 
            "+        String contentType = (String) msgCtx.getProperty(Constants.Configuration.CONTENT_TYPE);\n", 
            "+        String _contentType = contentType;\n", 
            "+        in = HTTPTransportUtils.handleGZip(msgCtx, in);\n", 
            "+        if (contentType != null) {\n", 
            "+            int j = contentType.indexOf(\";\");\n", 
            "+            if (j > 0) {\n", 
            "+                _contentType = contentType.substring(0, j);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "+        AxisConfiguration configuration =\n", 
            "+                msgCtx.getConfigurationContext().getAxisConfiguration();\n", 
            "+        Parameter useFallbackParameter = configuration.getParameter(Constants.Configuration.USE_DEFAULT_FALLBACK_BUILDER);\n", 
            "+\n", 
            "+        boolean useFallbackBuilder = false;\n", 
            "+\n", 
            "+        if (useFallbackParameter != null) {\n", 
            "+            useFallbackBuilder = JavaUtils.isTrueExplicitly(useFallbackParameter.getValue(), useFallbackBuilder);\n", 
            "+        }\n", 
            "+\n", 
            "+        OMElement element = null;\n", 
            "         Builder builder;\n", 
            "         if (contentType != null) {\n", 
            "             // loading builder from externally..\n", 
            "-            builder = configuration.getMessageBuilder(_contentType,useFallbackBuilder);\n", 
            "+            builder = configuration.getMessageBuilder(_contentType, useFallbackBuilder);\n", 
            "             if (builder != null) {\n", 
            "                 try {\n", 
            "-                    /*try {\n", 
            "-                        throw new Exception(\"Building message\");\n", 
            "-                    } catch (Exception e) {\n", 
            "-                        e.printStackTrace();\n", 
            "-                    }*/\n", 
            "-                    element = builder.processDocument(in,contentType, msgCtx);\n", 
            "+                    element = builder.processDocument(in, contentType, msgCtx);\n", 
            "                 } catch (AxisFault axisFault) {\n", 
            "                     log.error(\"Error building message\", axisFault);\n", 
            "                     throw axisFault;\n"
          ]
        }, 
        {
          "locn": "-135,12 +121,7", 
          "lines": [
            " \n", 
            "         if (element == null) {\n", 
            "             if (msgCtx.isDoingREST()) {\n", 
            "-                try {\n", 
            "-                    element = BuilderUtil.getPOXBuilder(in, null).getDocumentElement();\n", 
            "-                } catch (XMLStreamException e) {\n", 
            "-                    log.error(\"Error building message using POX Builder\", e);\n", 
            "-                    throw e;\n", 
            "-                }\n", 
            "+                element = BuilderUtil.createPOXBuilder(in, null).getDocumentElement();\n", 
            "             } else {\n", 
            "                 // switch to default\n", 
            "                 builder = new SOAPBuilder();\n"
          ]
        }, 
        {
          "locn": "-160,82 +141,9", 
          "lines": [
            "         }\n", 
            " \n", 
            "         //setting up original contentType (resetting the content type)\n", 
            "-        if(contentType != null && !contentType.isEmpty()){\n", 
            "-         msgCtx.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);\n", 
            "+        if (contentType != null && !contentType.isEmpty()) {\n", 
            "+            msgCtx.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);\n", 
            "         }\n", 
            "         return element;\n", 
            "     }\n", 
            "-\n", 
            "-    private Builder getBuilderForContentType(String contentType) {\n", 
            "-        String type;\n", 
            "-        int index = contentType.indexOf(';');\n", 
            "-        if (index > 0) {\n", 
            "-            type = contentType.substring(0, index);\n", 
            "-        } else {\n", 
            "-            type = contentType;\n", 
            "-        }\n", 
            "-\n", 
            "-        Builder builder = builders.get(type);\n", 
            "-\n", 
            "-        if (builder == null) {\n", 
            "-            builder = builders.get(type.toLowerCase());\n", 
            "-        }\n", 
            "-\n", 
            "-        if (builder == null) {\n", 
            "-            Iterator<Map.Entry<String, Builder>> iterator = builders.entrySet().iterator();\n", 
            "-            while (iterator.hasNext() && builder == null) {\n", 
            "-                Map.Entry<String, Builder> entry = iterator.next();\n", 
            "-                String key = entry.getKey();\n", 
            "-                if (contentType.matches(key)) {\n", 
            "-                    builder = entry.getValue();\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return builder;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static Builder createBuilder(String className) throws AxisFault {\n", 
            "-        try {\n", 
            "-            Class c = Class.forName(className);\n", 
            "-            Object o = c.newInstance();\n", 
            "-            if (o instanceof Builder) {\n", 
            "-                return (Builder) o;\n", 
            "-            }\n", 
            "-        } catch (ClassNotFoundException e) {\n", 
            "-            handleException(\"Builder class not found :\" +\n", 
            "-                    className, e);\n", 
            "-        } catch (IllegalAccessException e) {\n", 
            "-            handleException(\"Cannot initiate Builder class :\" +\n", 
            "-                    className, e);\n", 
            "-        } catch (InstantiationException e) {\n", 
            "-            handleException(\"Cannot initiate Builder class :\" +\n", 
            "-                    className, e);\n", 
            "-        }\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    public static MessageFormatter createFormatter(String className) throws AxisFault {\n", 
            "-        try {\n", 
            "-            Class c = Class.forName(className);\n", 
            "-            Object o = c.newInstance();\n", 
            "-            if (o instanceof MessageFormatter) {\n", 
            "-                return (MessageFormatter) o;\n", 
            "-            }\n", 
            "-        } catch (ClassNotFoundException e) {\n", 
            "-            handleException(\"MessageFormatter class not found :\" +\n", 
            "-                    className, e);\n", 
            "-        } catch (IllegalAccessException e) {\n", 
            "-            handleException(\"Cannot initiate MessageFormatter class :\" +\n", 
            "-                    className, e);\n", 
            "-        } catch (InstantiationException e) {\n", 
            "-            handleException(\"Cannot initiate MessageFormatter class :\" +\n", 
            "-                    className, e);\n", 
            "-        }\n", 
            "-        return null;\n", 
            "-    }\n", 
            "-\n", 
            "-    private static void handleException(String message, Exception e) throws AxisFault {\n", 
            "-        log.error(message, e);\n", 
            "-        throw new AxisFault(message, e);\n", 
            "-    }\n", 
            " }\n", 
            "\\ No newline at end of file\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/DeferredMessageBuilder.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/DeferredMessageBuilder.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-58,15 +58,15", 
          "lines": [
            "     private static boolean noAddressingHandler = false;\n", 
            "     \n", 
            "     private static Boolean forcePTBuild = null;\n", 
            "-    \n", 
            " \n", 
            "-    static{\n", 
            "-    \tif(forcePTBuild == null){\n", 
            "-           forcePTBuild =PassThroughConfiguration.getInstance().getBooleanProperty(PassThroughConstants.FORCE_PASS_THROUGH_BUILDER);\n", 
            "-           if(forcePTBuild ==null){\n", 
            "-             forcePTBuild =true;\n", 
            "+    static {\n", 
            "+    \tif (forcePTBuild == null){\n", 
            "+           forcePTBuild = PassThroughConfiguration.getInstance().getBooleanProperty(\n", 
            "+                   PassThroughConstants.FORCE_PASS_THROUGH_BUILDER);\n", 
            "+           if (forcePTBuild == null){\n", 
            "+             forcePTBuild = true;\n", 
            "            }\n", 
            "-        //this to keep track ignore the builder operation eventhough content level is enable.\n", 
            "+            //this to keep track ignore the builder operation even though content level is enable.\n", 
            "         }\n", 
            "     }\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-80,12 +80,10", 
          "lines": [
            "             XMLStreamException {\n", 
            " \n", 
            "         final Pipe pipe = (Pipe) messageContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE);\n", 
            "-\t\tif (pipe != null &&\n", 
            "-\t\t    !Boolean.TRUE.equals(messageContext.getProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED)) &&\n", 
            "-\t\t    forcePTBuild) {\n", 
            "+\t\tif (pipe != null && forcePTBuild &&\n", 
            "+                !PassThroughTransportUtils.builderInvoked(messageContext)) {\n", 
            " \t\t\tInputStream in = pipe.getInputStream();\n", 
            "-        \t\n", 
            "-        \tbuilldMessage(messageContext, earlyBuild, in);\n", 
            "+        \tbuildMessage(messageContext, earlyBuild, in);\n", 
            "             return;\n", 
            "         }\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-95,7 +93,6", 
          "lines": [
            " \n", 
            "         if (contentEle != null) {\n", 
            "             OMNode node = contentEle.getFirstOMChild();\n", 
            "-\n", 
            "             if (node != null && (node instanceof OMText)) {\n", 
            "                 OMText binaryDataNode = (OMText) node;\n", 
            "                 DataHandler dh = (DataHandler) binaryDataNode.getDataHandler();\n"
          ]
        }, 
        {
          "locn": "-124,42 +121,42", 
          "lines": [
            "         }\n", 
            "     }\n", 
            " \n", 
            "-\tpublic static void builldMessage(MessageContext messageContext, boolean earlyBuild, InputStream in) throws IOException, AxisFault {\n", 
            "-\t    //\n", 
            "-\t    BufferedInputStream bufferedInputStream= (BufferedInputStream) messageContext.getProperty(PassThroughConstants.BUFFERED_INPUT_STREAM);\n", 
            "-\t    if(bufferedInputStream != null){\n", 
            "-\t    \ttry{\n", 
            "+\tpublic static void buildMessage(MessageContext messageContext,\n", 
            "+                                    boolean earlyBuild, InputStream in) throws IOException {\n", 
            "+\n", 
            "+\t    BufferedInputStream bufferedInputStream = (BufferedInputStream) messageContext.getProperty(\n", 
            "+                PassThroughConstants.BUFFERED_INPUT_STREAM);\n", 
            "+\t    if (bufferedInputStream != null){\n", 
            "+\t    \ttry {\n", 
            " \t    \t  bufferedInputStream.reset();\n", 
            " \t    \t  bufferedInputStream.mark(0);\n", 
            "-\t    \t}catch (Exception e) {\n", 
            "+\t    \t} catch (Exception e) {\n", 
            " \t    \t\t//just ignore the error\n", 
            " \t\t\t}\n", 
            "-          \n", 
            "-\t    }else{\n", 
            "-\t    \t\tbufferedInputStream =new BufferedInputStream(in);\n", 
            "-\t\t    \t //TODO: need to handle properly for the moment lets use around 100k buffer.\n", 
            "+\t    } else {\n", 
            "+\t    \t\tbufferedInputStream = new BufferedInputStream(in);\n", 
            "+\t\t    \t //TODO: need to handle properly; for the moment lets use around 100k buffer.\n", 
            " \t\t\t    bufferedInputStream.mark(128 * 1024);\n", 
            "-\t\t    \tmessageContext.setProperty(PassThroughConstants.BUFFERED_INPUT_STREAM, bufferedInputStream);\n", 
            "-\t\t  }\n", 
            "+\t\t    \tmessageContext.setProperty(PassThroughConstants.BUFFERED_INPUT_STREAM,\n", 
            "+                        bufferedInputStream);\n", 
            "+\t\t}\n", 
            " \t   \n", 
            " \t    OMElement element = null;\n", 
            " \t    try{\n", 
            "-\t     element = messageBuilder.getDocument(messageContext, bufferedInputStream != null?bufferedInputStream:in);\n", 
            "+\t        element = messageBuilder.getDocument(messageContext, bufferedInputStream);\n", 
            " \t    }catch (Exception e) {\n", 
            "-\t    \tlog.error(\"Error while building Passthrough stream\",e);\n", 
            "+\t    \tlog.error(\"Error while building PassThrough stream\",e);\n", 
            " \t    }\n", 
            "+\n", 
            " \t    if (element != null) {\n", 
            " \t        messageContext.setEnvelope(TransportUtils.createSOAPEnvelope(element));\n", 
            " \t        messageContext.setProperty(DeferredMessageBuilder.RELAY_FORMATTERS_MAP,\n", 
            " \t                messageBuilder.getFormatters());\n", 
            "-\t        messageContext.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED,\n", 
            "-\t                Boolean.TRUE);\n", 
            "-\n", 
            "+\t        messageContext.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED, Boolean.TRUE);\n", 
            " \t        if (!earlyBuild) {\n", 
            " \t            processAddressing(messageContext);\n", 
            " \t        }\n", 
            " \t    }\n", 
            "-\t    return;\n", 
            "     }\n", 
            " \n", 
            "     private static void processAddressing(MessageContext messageContext) throws AxisFault {\n"
          ]
        }, 
        {
          "locn": "-197,14 +194,15", 
          "lines": [
            "         messageContext.setProperty(AddressingConstants.DISABLE_ADDRESSING_FOR_IN_MESSAGES, \"false\");\n", 
            "         \n", 
            "         Object disableAddressingForOutGoing = null;\n", 
            "-        if(messageContext.getProperty(\n", 
            "-                    AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES) != null){\n", 
            "-        \tdisableAddressingForOutGoing = messageContext.getProperty(AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES);\n", 
            "+        if (messageContext.getProperty(AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES) != null){\n", 
            "+        \tdisableAddressingForOutGoing = messageContext.getProperty(\n", 
            "+                    AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES);\n", 
            "         }\n", 
            "         addressingInHandler.invoke(messageContext);\n", 
            "         \n", 
            "-        if(disableAddressingForOutGoing !=null){\n", 
            "-        \tmessageContext.setProperty(AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, disableAddressingForOutGoing);\n", 
            "+        if (disableAddressingForOutGoing !=null){\n", 
            "+        \tmessageContext.setProperty(AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES,\n", 
            "+                    disableAddressingForOutGoing);\n", 
            "         }\n", 
            " \n", 
            "         if (messageContext.getAxisOperation() == null) {\n"
          ]
        }, 
        {
          "locn": "-214,30 +212,32", 
          "lines": [
            "         String mepString = messageContext.getAxisOperation().getMessageExchangePattern();\n", 
            " \n", 
            "         if (isOneWay(mepString)) {\n", 
            "-            Object requestResponseTransport = messageContext.getProperty(RequestResponseTransport.TRANSPORT_CONTROL);\n", 
            "+            Object requestResponseTransport = messageContext.getProperty(\n", 
            "+                    RequestResponseTransport.TRANSPORT_CONTROL);\n", 
            "             if (requestResponseTransport != null) {\n", 
            "-\n", 
            "                 Boolean disableAck = getDisableAck(messageContext);\n", 
            "-                if (disableAck == null || disableAck.booleanValue() == false) {\n", 
            "-                    ((RequestResponseTransport) requestResponseTransport).acknowledgeMessage(messageContext);\n", 
            "+                if (disableAck == null || !disableAck) {\n", 
            "+                    ((RequestResponseTransport) requestResponseTransport).acknowledgeMessage(\n", 
            "+                            messageContext);\n", 
            "                 }\n", 
            "             }\n", 
            "-        } else if (AddressingHelper.isReplyRedirected(messageContext) && AddressingHelper.isFaultRedirected(messageContext)) {\n", 
            "-            if (mepString.equals(WSDL2Constants.MEP_URI_IN_OUT)\n", 
            "-                    || mepString.equals(WSDL2Constants.MEP_URI_IN_OUT)\n", 
            "-                    || mepString.equals(WSDL2Constants.MEP_URI_IN_OUT)) {\n", 
            "-                // OR, if 2 way operation but the response is intended to not use the response channel of a 2-way transport\n", 
            "-                // then we don't need to keep the transport waiting.\n", 
            "-\n", 
            "-                Object requestResponseTransport = messageContext.getProperty(RequestResponseTransport.TRANSPORT_CONTROL);\n", 
            "+        } else if (AddressingHelper.isReplyRedirected(messageContext) &&\n", 
            "+                AddressingHelper.isFaultRedirected(messageContext)) {\n", 
            "+            if (mepString.equals(WSDL2Constants.MEP_URI_IN_OUT)) {\n", 
            "+                // OR, if 2 way operation but the response is intended to not use the\n", 
            "+                // response channel of a 2-way transport  then we don't need to keep the\n", 
            "+                // transport waiting.\n", 
            "+                Object requestResponseTransport = messageContext.getProperty(\n", 
            "+                        RequestResponseTransport.TRANSPORT_CONTROL);\n", 
            "                 if (requestResponseTransport != null) {\n", 
            " \n", 
            "-                    // We should send an early ack to the transport whenever possible, but some modules need\n", 
            "-                    // to use the back channel, so we need to check if they have disabled this code.\n", 
            "+                    // We should send an early ack to the transport whenever possible, but\n", 
            "+                    // some modules need to use the back channel, so we need to check if they\n", 
            "+                    // have disabled this code.\n", 
            "                     Boolean disableAck = getDisableAck(messageContext);\n", 
            "-\n", 
            "-                    if (disableAck == null || disableAck.booleanValue() == false) {\n", 
            "-                        ((RequestResponseTransport) requestResponseTransport).acknowledgeMessage(messageContext);\n", 
            "+                    if (disableAck == null || !disableAck) {\n", 
            "+                        ((RequestResponseTransport) requestResponseTransport).acknowledgeMessage(\n", 
            "+                                messageContext);\n", 
            "                     }\n", 
            " \n", 
            "                 }\n"
          ]
        }, 
        {
          "locn": "-248,9 +248,12", 
          "lines": [
            "     private static Boolean getDisableAck(MessageContext msgContext) throws AxisFault {\n", 
            "        // We should send an early ack to the transport whenever possible, but some modules need\n", 
            "        // to use the back channel, so we need to check if they have disabled this code.\n", 
            "-       Boolean disableAck = (Boolean) msgContext.getProperty(Constants.Configuration.DISABLE_RESPONSE_ACK);\n", 
            "-       if(disableAck == null) {\n", 
            "-          disableAck = (Boolean) (msgContext.getAxisService() != null ? msgContext.getAxisService().getParameterValue(Constants.Configuration.DISABLE_RESPONSE_ACK) : null);\n", 
            "+       Boolean disableAck = (Boolean) msgContext.getProperty(\n", 
            "+               Constants.Configuration.DISABLE_RESPONSE_ACK);\n", 
            "+       if (disableAck == null) {\n", 
            "+          disableAck = (Boolean) (msgContext.getAxisService() != null ?\n", 
            "+                  msgContext.getAxisService().getParameterValue(\n", 
            "+                          Constants.Configuration.DISABLE_RESPONSE_ACK) : null);\n", 
            "        }\n", 
            " \n", 
            "        return disableAck;\n"
          ]
        }, 
        {
          "locn": "-257,8 +260,6", 
          "lines": [
            "     }\n", 
            " \n", 
            "     private static boolean isOneWay(String mepString) {\n", 
            "-        return (mepString.equals(WSDL2Constants.MEP_URI_IN_ONLY)\n", 
            "-                || mepString.equals(WSDL2Constants.MEP_URI_IN_ONLY)\n", 
            "-                || mepString.equals(WSDL2Constants.MEP_URI_IN_ONLY));\n", 
            "+        return mepString.equals(WSDL2Constants.MEP_URI_IN_ONLY);\n", 
            "     }\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelayUtils.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelayUtils.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-73,7 +73,7", 
          "lines": [
            " \t\t\t\t\tString serviceOpPart = Utils.getServiceAndOperationPart(filePart,\n", 
            " \t\t\t\t\t                       messageContext.getConfigurationContext().getServiceContextPath());\n", 
            " \n", 
            "-\t\t\t\t\tAxisService axisService = null;\n", 
            "+\t\t\t\t\tAxisService axisService;\n", 
            " \n", 
            " \t\t\t\t\t// only service context path onwards values will be taken\n", 
            " \t\t\t\t\tif (messageContext.getConfigurationContext().getServiceContextPath() != null &&\n"
          ]
        }, 
        {
          "locn": "-121,19 +121,20", 
          "lines": [
            " \t    //if the request message is a POX and if authenticate enables, which means a custom security header added to the SOAP header\n", 
            " \t    //and in PT case, since the message is getting build forcefully we need to make sure the POX security headers added by POXSecurityHandler\n", 
            " \t    //is existing in the newly build soap envelope.\n", 
            "-\t    if(_contentType != null && _contentType.equals(APPLICATION_XML) && header != null && header.getChildElements() != null || messageContext.isDoingREST()){\n", 
            "+\t    if(_contentType != null && _contentType.equals(APPLICATION_XML) &&\n", 
            "+                header != null && header.getChildElements() != null || messageContext.isDoingREST()){\n", 
            " \t    \ttry {\n", 
            " \t            OMElement element =AXIOMUtil.stringToOM(header.toString());\n", 
            " \t            OMNamespace omNamespace =  \n", 
            " \t            OMAbstractFactory.getOMFactory().createOMNamespace(WSS_WSSECURITY_SECEXT_1_0_XSD, WSSE); \n", 
            "-\t            SOAPHeaderBlock soapBloackingHeader = OMAbstractFactory.getSOAP12Factory().createSOAPHeaderBlock(\"Security\",omNamespace);\n", 
            "+\t            SOAPHeaderBlock soapBlockingHeader = OMAbstractFactory.getSOAP12Factory().createSOAPHeaderBlock(\"Security\",omNamespace);\n", 
            " \t            OMElement securityHeader = (OMElement) element.getFirstOMChild();\n", 
            " \t    \t\tif (securityHeader != null) {\n", 
            " \t    \t\t\twhile (securityHeader.getChildElements().hasNext()) {\n", 
            "-\t    \t\t\t\tsoapBloackingHeader.addChild((OMNode) securityHeader.getChildElements().next());\n", 
            "+\t    \t\t\t\tsoapBlockingHeader.addChild((OMNode) securityHeader.getChildElements().next());\n", 
            " \t    \t\t\t}\n", 
            " \n", 
            "-\t    \t\t\tmessageContext.getEnvelope().getHeader().addChild(soapBloackingHeader);\n", 
            "+\t    \t\t\tmessageContext.getEnvelope().getHeader().addChild(soapBlockingHeader);\n", 
            " \t    \t\t}\n", 
            " \t        } catch (Exception e) {\n", 
            " \t               log.error(\"Error while executing the message at relaySecurity handler\", e);\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelaySecurityMessageBuilderDispatchHandler.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelaySecurityMessageBuilderDispatchHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-50,13 +50,11", 
          "lines": [
            " \n", 
            "     public ByteBuffer getBuffer() {\n", 
            "         if (marker == -1) {\n", 
            "-            //System.out.println(\"allocating marker -1\");\n", 
            "             return allocator.allocate(bufferSize);\n", 
            "         } else {\n", 
            "             lock.lock();\n", 
            "             try {\n", 
            "                 if (marker >= 0) {\n", 
            "-                    // System.out.println(\"Returning buffer\");\n", 
            "                     ByteBuffer b = buffers[marker];\n", 
            "                     buffers[marker] = null;\n", 
            "                     marker--;\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BufferFactory.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BufferFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-16,39 +16,31", 
          "lines": [
            "  *  specific language governing permissions and limitations\n", 
            "  *  under the License.\n", 
            "  */\n", 
            "+\n", 
            " package org.apache.synapse.transport.passthru.util;\n", 
            " \n", 
            " import org.apache.axiom.om.OMOutputFormat;\n", 
            " import org.apache.axis2.addressing.EndpointReference;\n", 
            " import org.apache.axis2.context.MessageContext;\n", 
            "-import org.apache.axis2.context.ConfigurationContext;\n", 
            " import org.apache.axis2.Constants;\n", 
            " import org.apache.axis2.transport.TransportUtils;\n", 
            "-import org.apache.axis2.util.JavaUtils;\n", 
            "-import org.apache.axis2.description.AxisService;\n", 
            "-import org.apache.axis2.description.Parameter;\n", 
            "-import org.apache.axis2.description.AxisOperation;\n", 
            " import org.apache.http.protocol.HTTP;\n", 
            " import org.apache.http.HttpStatus;\n", 
            " import org.apache.commons.logging.Log;\n", 
            " import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            " import org.apache.synapse.transport.passthru.PassThroughConstants;\n", 
            " \n", 
            " import java.net.InetAddress;\n", 
            "-import java.net.SocketException;\n", 
            "-import java.net.NetworkInterface;\n", 
            " import java.util.Map;\n", 
            " import java.util.Iterator;\n", 
            "-import java.util.Enumeration;\n", 
            "-import java.util.Hashtable;\n", 
            " \n", 
            " /**\n", 
            "  * Utility methods used by the transport.\n", 
            "  */\n", 
            " public class PassThroughTransportUtils {\n", 
            "-    private static Log log = LogFactory.getLog(PassThroughTransportUtils.class);\n", 
            " \n", 
            "+    private static final Log log = LogFactory.getLog(PassThroughTransportUtils.class);\n", 
            "+\n", 
            "     /**\n", 
            "      * This method tries to determine the hostname of the given InetAddress without\n", 
            "      * triggering a reverse DNS lookup.  {@link java.net.InetAddress#getHostName()}\n"
          ]
        }, 
        {
          "locn": "-61,7 +53,7", 
          "lines": [
            "      * the value of {@link java.net.InetAddress#getHostAddress()} is returned.\n", 
            "      *\n", 
            "      * @param address The InetAddress whose hostname has to be determined\n", 
            "-     * @return hostsname, if it can be determined. hostaddress, if not.          \n", 
            "+     * @return hostname, if it can be determined. host address, if not.\n", 
            "      */\n", 
            "     public static String getHostName(InetAddress address) {\n", 
            "         String result;\n"
          ]
        }, 
        {
          "locn": "-87,8 +79,7", 
          "lines": [
            "      * @return the destination EPR\n", 
            "      */\n", 
            "     public static EndpointReference getDestinationEPR(MessageContext msgContext) {\n", 
            "-\n", 
            "-        // Trasnport URL can be different from the WSA-To\n", 
            "+        // Transport URL can be different from the WSA-To\n", 
            "         String transportURL = (String) msgContext.getProperty(\n", 
            "             Constants.Configuration.TRANSPORT_URL);\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-162,8 +153,8", 
          "lines": [
            "             httpStatus = HttpStatus.SC_ACCEPTED;\n", 
            "         } else {\n", 
            "             // is this a fault message\n", 
            "-            boolean handleFault = msgContext.getEnvelope() != null ?\n", 
            "-                (msgContext.getEnvelope().getBody().hasFault() || msgContext.isProcessingFault()):false;\n", 
            "+            boolean handleFault = msgContext.getEnvelope() != null &&\n", 
            "+                    (msgContext.getEnvelope().getBody().hasFault() || msgContext.isProcessingFault());\n", 
            " \n", 
            "             // shall faults be transmitted with HTTP 200\n", 
            "             boolean faultsAsHttp200 =\n"
          ]
        }, 
        {
          "locn": "-192,111 +183,8", 
          "lines": [
            "         return httpStatus;\n", 
            "     }\n", 
            " \n", 
            "-    /**\n", 
            "-     * Whatever this method returns as the IP is ignored by the actual http/s listener when\n", 
            "-     * its getServiceEPR is invoked. This was originally copied from axis2\n", 
            "-     *\n", 
            "-     * @return Returns String.\n", 
            "-     * @throws java.net.SocketException if the socket can not be accessed\n", 
            "-     */\n", 
            "-    public static String getIpAddress() throws SocketException {\n", 
            "-        Enumeration e = NetworkInterface.getNetworkInterfaces();\n", 
            "-        String address = \"127.0.0.1\";\n", 
            "-\n", 
            "-        while (e.hasMoreElements()) {\n", 
            "-            NetworkInterface netface = (NetworkInterface) e.nextElement();\n", 
            "-            Enumeration addresses = netface.getInetAddresses();\n", 
            "-\n", 
            "-            while (addresses.hasMoreElements()) {\n", 
            "-                InetAddress ip = (InetAddress) addresses.nextElement();\n", 
            "-                if (!ip.isLoopbackAddress() && isIP(ip.getHostAddress())) {\n", 
            "-                    return ip.getHostAddress();\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-        return address;\n", 
            "-    }\n", 
            "-\n", 
            "-    private static boolean isIP(String hostAddress) {\n", 
            "-        return hostAddress.split(\"[.]\").length == 4;\n", 
            "-    }\n", 
            "-\n", 
            "-\n", 
            "-    /**\n", 
            "-     * Returns the HTML text for the list of services deployed.\n", 
            "-     * This can be delegated to another Class as well\n", 
            "-     * where it will handle more options of GET messages.\n", 
            "-     *\n", 
            "-     * @param prefix to be used for the Service names\n", 
            "-     * @param cfgCtx axis2 configuration context\n", 
            "-     * @return the HTML to be displayed as a String\n", 
            "-     */\n", 
            "-    public String getServicesHTML(String prefix, ConfigurationContext cfgCtx) {\n", 
            "-\n", 
            "-        Map services = cfgCtx.getAxisConfiguration().getServices();\n", 
            "-        Hashtable erroneousServices = cfgCtx.getAxisConfiguration().getFaultyServices();\n", 
            "-        boolean servicesFound = false;\n", 
            "-\n", 
            "-        StringBuffer resultBuf = new StringBuffer();\n", 
            "-        resultBuf.append(\"<html><head><title>Axis2: Services</title></head>\" + \"<body>\");\n", 
            "-\n", 
            "-        if ((services != null) && !services.isEmpty()) {\n", 
            "-\n", 
            "-            servicesFound = true;\n", 
            "-            resultBuf.append(\"<h2>\" + \"Deployed services\" + \"</h2>\");\n", 
            "-\n", 
            "-            for (Object service : services.values()) {\n", 
            "-\n", 
            "-                AxisService axisService = (AxisService) service;\n", 
            "-                Parameter parameter = axisService.getParameter(\n", 
            "-                        PassThroughConstants.HIDDEN_SERVICE_PARAM_NAME);\n", 
            "-                if (axisService.getName().startsWith(\"__\") ||\n", 
            "-                        (parameter != null && JavaUtils.isTrueExplicitly(parameter.getValue()))) {\n", 
            "-                    continue;    // skip private services\n", 
            "-                }\n", 
            "-\n", 
            "-                Iterator iterator = axisService.getOperations();\n", 
            "-                resultBuf.append(\"<h3><a href=\\\"\").append(prefix).append(axisService.getName()).append(\n", 
            "-                        \"?wsdl\\\">\").append(axisService.getName()).append(\"</a></h3>\");\n", 
            "-\n", 
            "-                if (iterator.hasNext()) {\n", 
            "-                    resultBuf.append(\"Available operations <ul>\");\n", 
            "-\n", 
            "-                    for (; iterator.hasNext();) {\n", 
            "-                        AxisOperation axisOperation = (AxisOperation) iterator.next();\n", 
            "-                        resultBuf.append(\"<li>\").append(\n", 
            "-                                axisOperation.getName().getLocalPart()).append(\"</li>\");\n", 
            "-                    }\n", 
            "-                    resultBuf.append(\"</ul>\");\n", 
            "-                } else {\n", 
            "-                    resultBuf.append(\"No operations specified for this service\");\n", 
            "-                }\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        if ((erroneousServices != null) && !erroneousServices.isEmpty()) {\n", 
            "-            servicesFound = true;\n", 
            "-            resultBuf.append(\"<hr><h2><font color=\\\"blue\\\">Faulty Services</font></h2>\");\n", 
            "-            Enumeration faultyservices = erroneousServices.keys();\n", 
            "-\n", 
            "-            while (faultyservices.hasMoreElements()) {\n", 
            "-                String faultyserviceName = (String) faultyservices.nextElement();\n", 
            "-                resultBuf.append(\"<h3><font color=\\\"blue\\\">\").append(\n", 
            "-                        faultyserviceName).append(\"</font></h3>\");\n", 
            "-            }\n", 
            "-        }\n", 
            "-\n", 
            "-        if (!servicesFound) {\n", 
            "-            resultBuf.append(\"<h2>There are no services deployed</h2>\");\n", 
            "-        }\n", 
            "-\n", 
            "-        resultBuf.append(\"</body></html>\");\n", 
            "-        return resultBuf.toString();\n", 
            "-    }\n", 
            "-\n", 
            "     public static OMOutputFormat getOMOutputFormat(MessageContext msgContext) {\n", 
            "-\n", 
            "-    \tOMOutputFormat format = null;\n", 
            "+    \tOMOutputFormat format;\n", 
            "     \tif(msgContext.getProperty(PassThroughConstants.MESSAGE_OUTPUT_FORMAT) != null){\n", 
            "     \t\tformat = (OMOutputFormat) msgContext.getProperty(PassThroughConstants.MESSAGE_OUTPUT_FORMAT);\n", 
            "     \t}else{\n"
          ]
        }, 
        {
          "locn": "-319,4 +207,9", 
          "lines": [
            "         return format;\n", 
            "     }\n", 
            " \n", 
            "+    public static boolean builderInvoked(MessageContext messageContext) {\n", 
            "+        return Boolean.TRUE.equals(messageContext.getProperty(\n", 
            "+                PassThroughConstants.MESSAGE_BUILDER_INVOKED));\n", 
            "+    }\n", 
            "+\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/PassThroughTransportUtils.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/PassThroughTransportUtils.java"
    }
  ], 
  "id": "1502751"
}