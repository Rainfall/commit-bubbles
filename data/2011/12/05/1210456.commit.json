{
  "when": "2011-12-05T08:29:27-05:00", 
  "message": "Refactoring, code clean up and a few minor bug fixes. Added commons-vfs as a test dependency to Synapse core.", 
  "who": "hiranya", 
  "changes": [
    {
      "chunks": [
        {
          "locn": "-64,7 +64,7", 
          "lines": [
            "     public static final QName ON_FAULT_Q = new QName(XMLConfigConstants.NULL_NAMESPACE, \"onError\");\n", 
            " \n", 
            "     private static final QName DESCRIPTION_Q\n", 
            "-            = new QName(SynapseConstants.SYNAPSE_NAMESPACE, \"description\");\n", 
            "+            = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, \"description\");\n", 
            " \n", 
            "     /**\n", 
            "      * Core method which is exposed for the external use, and this will find the proper\n"
          ]
        }, 
        {
          "locn": "-83,7 +83,7", 
          "lines": [
            "     /**\n", 
            "      * Core method which is exposed for the external use, and this will find the proper\n", 
            "      * {@link EndpointFactory} and create the endpoint which is of the format {@link Endpoint}.However\n", 
            "-     * defintion for this endpoint will be built using a custom Endpoint Defn factory.\n", 
            "+     * definition for this endpoint will be built using a custom Endpoint Defn factory.\n", 
            "      *\n", 
            "      * @param elem        XML from which the endpoint will be built\n", 
            "      * @param factory    custom definition factory which this endpoint will be used to build\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-46,15 +46,15", 
          "lines": [
            " \n", 
            "         AddressEndpoint addressEndpoint = (AddressEndpoint) endpoint;\n", 
            " \n", 
            "+        EndpointDefinition epAddress = addressEndpoint.getDefinition();\n", 
            "+        OMElement addressElement = serializeEndpointDefinition(epAddress);\n", 
            "+        endpointElement.addChild(addressElement);\n", 
            "+\n", 
            "         // serialize the properties\n", 
            "         serializeProperties(addressEndpoint, endpointElement);\n", 
            "         //serialize attributes\n", 
            "         serializeCommonAttributes(endpoint, endpointElement);\n", 
            " \n", 
            "-        EndpointDefinition epAddress = addressEndpoint.getDefinition();\n", 
            "-        OMElement addressElement = serializeEndpointDefinition(epAddress);\n", 
            "-        endpointElement.addChild(addressElement);\n", 
            "-\n", 
            "         return endpointElement;\n", 
            "     }\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/AddressEndpointSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/AddressEndpointSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-121,17 +121,11", 
          "lines": [
            "             OMElement action = fac.createOMElement(\"responseAction\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            "             if (endpointDefinition.getTimeoutAction() == SynapseConstants.DISCARD) {\n", 
            "                 action.setText(\"discard\");\n", 
            "-                timeout.addChild(action);\n", 
            "             } else if (endpointDefinition.getTimeoutAction()\n", 
            "                     == SynapseConstants.DISCARD_AND_FAULT) {\n", 
            "                 action.setText(\"fault\");\n", 
            "-                timeout.addChild(action);\n", 
            "-            } else if (endpointDefinition.getTimeoutAction()\n", 
            "-                    == SynapseConstants.NONE) {\n", 
            "-                // if the action is not given, it is set to fault\n", 
            "-                action.setText(\"fault\");\n", 
            "-                timeout.addChild(action);\n", 
            "             }\n", 
            "+            timeout.addChild(action);\n", 
            "         }\n", 
            " \n", 
            "         if (endpointDefinition.getInitialSuspendDuration() != -1 ||\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointDefinitionSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointDefinitionSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-704,7 +704,8", 
          "lines": [
            "                 }\r\n", 
            "             } catch (SynapseException e) {\r\n", 
            "                 if (failSafeProxyEnabled) {\r\n", 
            "-                    log.warn(\"The proxy service \" + proxy.getName() + \" cannot be deployed. Continue in Proxy Service fail-safe mode.\");\r\n", 
            "+                    log.warn(\"The proxy service \" + proxy.getName() + \" cannot be deployed - \" +\r\n", 
            "+                            \"Continue in Proxy Service fail-safe mode.\");\r\n", 
            "                 } else {\r\n", 
            "                     handleException(\"The proxy service \" + proxy.getName() + \" : Deployment Error\");\r\n", 
            "                 }\r\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/Axis2SynapseController.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/Axis2SynapseController.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-178,7 +178,7", 
          "lines": [
            "                     }\r\n", 
            "                 }\r\n", 
            "             } catch (Exception e) {\r\n", 
            "-                String msg = \"Sequence configuration : \" + name + \" cannot be built\";\r\n", 
            "+                String msg = \"Sequence configuration: \" + name + \" cannot be built\";\r\n", 
            "                 handleConfigurationError(SynapseConstants.FAIL_SAFE_MODE_SEQUENCES, msg, e);\r\n", 
            "             }\r\n", 
            "             return mediator;\r\n"
          ]
        }, 
        {
          "locn": "-201,7 +201,7", 
          "lines": [
            "                     config.addSequenceTemplate(name, (TemplateMediator) mediator) ;\r\n", 
            "                 }\r\n", 
            "             } catch (Exception e) {\r\n", 
            "-                String msg = \"Template configuration : \" + name + \" cannot be built\";\r\n", 
            "+                String msg = \"Template configuration: \" + name + \" cannot be built\";\r\n", 
            "                 handleConfigurationError(SynapseConstants.FAIL_SAFE_MODE_TEMPLATES, msg, e);\r\n", 
            "             }\r\n", 
            "             return mediator;\r\n"
          ]
        }, 
        {
          "locn": "-224,7 +224,7", 
          "lines": [
            "                     config.addEndpoint(name.trim(), endpoint);\r\n", 
            "                 }\r\n", 
            "             } catch (Exception e) {\r\n", 
            "-                String msg = \"Endpoint configuration : \" + name + \" cannot be built\";\r\n", 
            "+                String msg = \"Endpoint configuration: \" + name + \" cannot be built\";\r\n", 
            "                 handleConfigurationError(SynapseConstants.FAIL_SAFE_MODE_EP, msg, e);\r\n", 
            "             }\r\n", 
            "             return endpoint;\r\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-75,7 +75,7", 
          "lines": [
            "      * Note that the default namespace is explicitly excluded and not added to the\n", 
            "      * namespace context. This implies that XPath expressions\n", 
            "      * appearing in Synapse configuration files follow the same rule as in XSL\n", 
            "-     * stylesheets. Indeed, the XSLT specification defines the namespace context of\n", 
            "+     * style sheets. Indeed, the XSLT specification defines the namespace context of\n", 
            "      * an XPath expression as follows:\n", 
            "      * <blockquote>\n", 
            "      * the set of namespace declarations are those in scope on the element which has the\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/OMElementUtils.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/OMElementUtils.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-44,9 +44,6", 
          "lines": [
            "         OMElement endpointElement\n", 
            "                 = fac.createOMElement(\"endpoint\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            " \n", 
            "-        // serialize the parameters\n", 
            "-        serializeProperties(failoverEndpoint, endpointElement);\n", 
            "-\n", 
            "         OMElement failoverElement\n", 
            "                 = fac.createOMElement(\"failover\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            "         endpointElement.addChild(failoverElement);\n"
          ]
        }, 
        {
          "locn": "-61,6 +58,9", 
          "lines": [
            "             failoverElement.addAttribute(\"dynamic\", \"false\", null);\n", 
            "         }\n", 
            " \n", 
            "+        // serialize the parameters\n", 
            "+        serializeProperties(failoverEndpoint, endpointElement);\n", 
            "+\n", 
            "         return endpointElement;\n", 
            "     }\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/FailoverEndpointSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/FailoverEndpointSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-54,6 +54,10", 
          "lines": [
            "         \n", 
            "         serializeCommonAttributes(endpoint,endpointElement);\n", 
            " \n", 
            "+        OMElement loadbalanceElement\n", 
            "+                = fac.createOMElement(\"loadbalance\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            "+        endpointElement.addChild(loadbalanceElement);\n", 
            "+\n", 
            "         Dispatcher dispatcher = loadbalanceEndpoint.getDispatcher();\n", 
            "         if (dispatcher != null) {\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-78,10 +82,6", 
          "lines": [
            "             endpointElement.addChild(sessionElement);\n", 
            "         }\n", 
            " \n", 
            "-        OMElement loadbalanceElement\n", 
            "-                = fac.createOMElement(\"loadbalance\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            "-        endpointElement.addChild(loadbalanceElement);\n", 
            "-\n", 
            "         loadbalanceElement.addAttribute(XMLConfigConstants.LOADBALANCE_ALGORITHM,\n", 
            "                 loadbalanceEndpoint.getAlgorithm().getClass().getName(),\n", 
            "                 null);\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-38,14 +38,14", 
          "lines": [
            " import org.apache.synapse.mediators.Value;\n", 
            " \n", 
            " /**\n", 
            "- * @author nuwan\n", 
            "  * <p>\n", 
            "  * Creates {@link RecipientListEndpoint} using an XML configuration.\n", 
            "- * <p/>\n", 
            "+ * </p>\n", 
            "+ * <p>\n", 
            "  * &lt;endpoint [name=\"name\"]&gt;\n", 
            "- * &lt;recipientlist&gt;\n", 
            "- * &lt;member hostName=\"host\" httpPort=\"port\" httpsPort=\"port\"&gt;+\n", 
            "- * &lt;/recipientlist&gt;\n", 
            "+ *   &lt;recipientlist&gt;\n", 
            "+ *     &lt;member hostName=\"host\" httpPort=\"port\" httpsPort=\"port\"&gt;+\n", 
            "+ *   &lt;/recipientlist&gt;\n", 
            "  * &lt;/endpoint&gt;\n", 
            "  * </p>\n", 
            "  */\n"
          ]
        }, 
        {
          "locn": "-84,11 +84,10", 
          "lines": [
            "             }\n", 
            "             \n", 
            " \t\t\t// set endpoints or members\n", 
            "-\t\t\tif (recipientListElement\n", 
            "-\t\t\t\t\t.getFirstChildWithName(XMLConfigConstants.ENDPOINT_ELT) != null) {\n", 
            "+\t\t\tif (recipientListElement.\n", 
            "+                    getFirstChildWithName(XMLConfigConstants.ENDPOINT_ELT) != null) {\n", 
            " \t\t\t\tif (recipientListElement.getChildrenWithName((MEMBER)).hasNext()) {\n", 
            "-\t\t\t\t\tString msg = \"Invalid Synapse configuration. \"\n", 
            "-\t\t\t\t\t\t\t+ \"child elements\";\n", 
            "+\t\t\t\t\tString msg = \"Invalid Synapse configuration. child elements\";\n", 
            " \t\t\t\t\tlog.error(msg);\n", 
            " \t\t\t\t\tthrow new SynapseException(msg);\n", 
            " \t\t\t\t}\n"
          ]
        }, 
        {
          "locn": "-95,8 +94,8", 
          "lines": [
            " \t\t\t\tList<Endpoint> endpoints = getEndpoints(recipientListElement,\n", 
            " \t\t\t\t\t\trecipientListEndpoint, properties);\n", 
            " \t\t\t\trecipientListEndpoint.setChildren(endpoints);\n", 
            "-\t\t\t}\n", 
            "-\t\t\telse if(recipientListElement.getFirstChildWithName(MEMBER) != null){\n", 
            "+\n", 
            "+\t\t\t} else if (recipientListElement.getFirstChildWithName(MEMBER) != null) {\n", 
            " \t\t\t\tif(recipientListElement.\n", 
            "                         getChildrenWithName((XMLConfigConstants.ENDPOINT_ELT)).hasNext()){\n", 
            "                     String msg =\n"
          ]
        }, 
        {
          "locn": "-109,19 +108,16", 
          "lines": [
            " \t\t\t\t\n", 
            "             \tList<Member> members = getMembers(recipientListElement);\n", 
            "             \trecipientListEndpoint.setMembers(members);\n", 
            "+\n", 
            "             } else if (recipientListElement.getFirstChildWithName(DYNAMIC_SET) != null) {\n", 
            "                 OMElement dynamicSetElement = recipientListElement.getFirstChildWithName(DYNAMIC_SET);\n", 
            "                 Value dynamicEndpointSet = new ValueFactory().createValue(\"value\", dynamicSetElement);\n", 
            "-                String cachedEpsStr = dynamicSetElement.getAttributeValue(new QName(\"cache\"));\n", 
            "-                int maxCache = -1;\n", 
            "-                try {\n", 
            "-                    maxCache = Integer.parseInt(cachedEpsStr);\n", 
            "-                } catch (NumberFormatException e) {\n", 
            "-\n", 
            "+                String maxCacheStr = dynamicSetElement.getAttributeValue(new QName(\"max-cache\"));\n", 
            "+                int maxCache = RecipientListEndpoint.DEFAULT_MAX_POOL ;\n", 
            "+                if (maxCacheStr != null) {\n", 
            "+                    maxCache = Integer.parseInt(maxCacheStr);\n", 
            "                 }\n", 
            "-                recipientListEndpoint = new RecipientListEndpoint(maxCache < 0 ?\n", 
            "-                                                                  RecipientListEndpoint.DEFAULT_MAX_POOL :\n", 
            "-                                                                  maxCache);\n", 
            "+                recipientListEndpoint = new RecipientListEndpoint(maxCache);\n", 
            "                 if (name != null) {\n", 
            "                     recipientListEndpoint.setName(name.getAttributeValue());\n", 
            "                 }\n"
          ]
        }, 
        {
          "locn": "-137,6 +133,9", 
          "lines": [
            "                 log.error(msg);\n", 
            "                 throw new SynapseException(msg);\n", 
            "             }\n", 
            "+\n", 
            "+            // process the parameters\n", 
            "+            processProperties(recipientListEndpoint, epConfig);\n", 
            " \t\t\t\n", 
            " \t\t\treturn recipientListEndpoint;\n", 
            " \t\t}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/RecipientListEndpointFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/RecipientListEndpointFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-95,7 +95,7", 
          "lines": [
            "     private OMElement getSerializedDescription(Endpoint endpoint) {\n", 
            " \n", 
            "         OMElement descriptionElem = fac.createOMElement(\n", 
            "-                new QName(SynapseConstants.SYNAPSE_NAMESPACE, \"description\"));\n", 
            "+                \"description\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            " \n", 
            "         if (endpoint.getDescription() != null) {\n", 
            "             descriptionElem.setText(endpoint.getDescription());\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-179,14 +179,6", 
          "lines": [
            "                     if (definition.getTimeoutDuration() == 0) {\n", 
            "                         definition.setTimeoutDuration(30000);\n", 
            "                     }\n", 
            "-                } else if (\"\".equalsIgnoreCase(actionString.trim())) {\n", 
            "-                    // if the timeout action is empty, then the action is set to DISCARD_AND_FAULT\n", 
            "-                    definition.setTimeoutAction(SynapseConstants.DISCARD_AND_FAULT);\n", 
            "-\n", 
            "-                    // set timeout duration to 30 seconds, if it is not set explicitly\n", 
            "-                    if (definition.getTimeoutDuration() == 0) {\n", 
            "-                        definition.setTimeoutDuration(30000);\n", 
            "-                    }\n", 
            "                 } else {\n", 
            "                     handleException(\"Invalid timeout action, action : \"\n", 
            "                             + actionString + \" is not supported\");\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointDefinitionFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointDefinitionFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-148,6 +148,10", 
          "lines": [
            " \n", 
            "     private boolean isWritable(File file) {\n", 
            "         if (file.isDirectory()) {\n", 
            "+            if (file.getName().startsWith(\".\") || file.isHidden()) {\n", 
            "+                return true;\n", 
            "+            }\n", 
            "+\n", 
            "             File[] children = file.listFiles();\n", 
            "             for (File child : children) {\n", 
            "                 if (!isWritable(child)) {\n"
          ]
        }, 
        {
          "locn": "-301,8 +305,8", 
          "lines": [
            "             }\n", 
            "         }\n", 
            " \n", 
            "-        for(MessageProcessor messageProcessor : messageProcessors) {\n", 
            "-            if(messageProcessor.getFileName() == null) {\n", 
            "+        for (MessageProcessor messageProcessor : messageProcessors) {\n", 
            "+            if (messageProcessor.getFileName() == null) {\n", 
            "                 MessageProcessorSerializer.serializeMessageProcessor(definitions,messageProcessor);\n", 
            "             }\n", 
            "         }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MultiXMLConfigurationSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MultiXMLConfigurationSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-196,6 +196,12", 
          "lines": [
            "             <scope>test</scope>\n", 
            "         </dependency>\n", 
            "         <dependency>\n", 
            "+            <groupId>org.apache.commons</groupId>\n", 
            "+            <artifactId>commons-vfs</artifactId>\n", 
            "+            <version>${commons.vfs.version}</version>\n", 
            "+            <scope>test</scope>\n", 
            "+        </dependency>\n", 
            "+        <dependency>\n", 
            "             <groupId>org.apache.synapse</groupId>\n", 
            "             <artifactId>synapse-vfs-transport</artifactId>\n", 
            "             <scope>test</scope>\n"
          ]
        }
      ], 
      "to": "java/modules/core/pom.xml", 
      "from": "java/modules/core/pom.xml"
    }, 
    {
      "chunks": [
        {
          "locn": "-18,6 +18,14", 
          "lines": [
            "  */\n", 
            " package org.apache.synapse.config.xml;\n", 
            " \n", 
            "+import org.apache.axiom.om.OMAttribute;\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.axiom.om.util.AXIOMUtil;\n", 
            "+import org.apache.axiom.om.xpath.AXIOMXPath;\n", 
            "+import org.jaxen.JaxenException;\n", 
            "+\n", 
            "+import javax.xml.stream.XMLStreamException;\n", 
            "+\n", 
            " /**\n", 
            "  *\n", 
            "  *\n"
          ]
        }, 
        {
          "locn": "-95,6 +103,23", 
          "lines": [
            "                 logMediatorSerializer));\n", 
            "     }\n", 
            " \n", 
            "+    public void testXPath() {\n", 
            "+        try {\n", 
            "+            OMElement element = AXIOMUtil.stringToOM(getXmlOfMediatorScenarioOneA(\"full\"));\n", 
            "+\n", 
            "+            AXIOMXPath xPath = new AXIOMXPath(\"//property/@name\");\n", 
            "+            //xPath.addNamespace(SynapseConstants.SYNAPSE_NAMESPACE, \"\");\n", 
            "+            Object o = xPath.selectSingleNode(element);\n", 
            "+            if (o instanceof OMAttribute) {\n", 
            "+                System.out.println(((OMAttribute) o).getAttributeValue());\n", 
            "+            }\n", 
            "+        } catch (XMLStreamException e) {\n", 
            "+            e.printStackTrace();\n", 
            "+        } catch (JaxenException e) {\n", 
            "+            e.printStackTrace();\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "     private String getXmlOfMediatorScenarioOne(String level) {\n", 
            "         return \"<log xmlns=\\\"http://ws.apache.org/ns/synapse\\\" level=\\\"\" +\n", 
            "                 level + \"\\\"><property name=\\\"Text\\\" value=\\\"Sending quote request\\\"/></log>\";\n"
          ]
        }, 
        {
          "locn": "-101,9 +126,15", 
          "lines": [
            " \n", 
            "     }\n", 
            " \n", 
            "-    private String getXmlOfMediatorScenarioTwo(String level, String seperator) {\n", 
            "+    private String getXmlOfMediatorScenarioOneA(String level) {\n", 
            "+        return \"<log level=\\\"\" +\n", 
            "+                level + \"\\\"><property name=\\\"Text\\\" value=\\\"Sending quote request\\\"/></log>\";\n", 
            "+\n", 
            "+    }\n", 
            "+\n", 
            "+    private String getXmlOfMediatorScenarioTwo(String level, String separator) {\n", 
            "         return \"<log xmlns=\\\"http://ws.apache.org/ns/synapse\\\" level=\\\"\" +\n", 
            "-                level + \"\\\" separator=\\\"\" + seperator +\n", 
            "+                level + \"\\\" separator=\\\"\" + separator +\n", 
            "                 \"\\\"><property name=\\\"Text\\\" value=\\\"Sending quote request\\\"/></log>\";\n", 
            " \n", 
            "     }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/test/java/org/apache/synapse/config/xml/LogMediatorSerializationTest.java", 
      "from": "java/modules/core/src/test/java/org/apache/synapse/config/xml/LogMediatorSerializationTest.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-90,8 +90,11", 
          "lines": [
            "                 getEndpointTemplate(template);\n", 
            " \n", 
            "         if (endpointTemplate == null) {\n", 
            "-            handleException(\"Template \" + template +\n", 
            "+            //if template is not already available we will warn the user\n", 
            "+            //thus template endpoint will get initialized at runtime\n", 
            "+            log.warn(\"Template \" + template +\n", 
            "                     \" cannot be found for the endpoint \" + getName());\n", 
            "+            return;\n", 
            "         }\n", 
            " \n", 
            "         reLoadAndInitEndpoint(synapseEnvironment);\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/TemplateEndpoint.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/TemplateEndpoint.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-74,10 +74,17", 
          "lines": [
            "             Map headerMap = getTransportHeaderMap(synCtx);\n", 
            " \n", 
            "             if (headerMap != null) {\n", 
            "+                Object hostObj = headerMap.get(\"Host\");\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"A request received with the Host Name : \" + hostObj);\n", 
            "+                }\n", 
            "                 Object cookieObj = headerMap.get(key);\n", 
            " \n", 
            "                 if (cookieObj instanceof String) {\n", 
            "                     String cookie = (String) cookieObj;\n", 
            "+                    if (log.isDebugEnabled()) {\n", 
            "+                        log.debug(\"Cookies String : \" + cookie);\n", 
            "+                    }\n", 
            "                     \n", 
            "                     // extract the first name value pair of the Set-Cookie header, which is considered\n", 
            "                     // as the session id which will be sent back from the client with the Cookie header\n"
          ]
        }, 
        {
          "locn": "-93,8 +100,11", 
          "lines": [
            "                         return null;\n", 
            "                     }\n", 
            " \n", 
            "-                    for(String sessionId : sessionIds){\n", 
            "-                        if(sessionId != null && sessionId.indexOf(\"JSESSIONID\") != -1){\n", 
            "+                    for (String sessionId : sessionIds){\n", 
            "+                        if(sessionId != null && sessionId.indexOf(\"JSESSIONID\") != -1) {\n", 
            "+                            if (log.isDebugEnabled()) {\n", 
            "+                                log.debug(\"Extracted SessionID : \" + sessionId);\n", 
            "+                            }\n", 
            "                             return sessionId.trim();\n", 
            "                         }\n", 
            "                     }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/AbstractDispatcher.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/AbstractDispatcher.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-19,9 +19,15", 
          "lines": [
            " \n", 
            " package org.apache.synapse.endpoints.dispatch;\n", 
            " \n", 
            "+import org.apache.http.protocol.HTTP;\n", 
            " import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.core.axis2.Axis2MessageContext;\n", 
            " \n", 
            "+import java.util.ArrayList;\n", 
            "+import java.util.List;\n", 
            "+import java.util.Map;\n", 
            " \n", 
            "+\n", 
            " /**\n", 
            "  * Dispatches sessions based on HTTP cookies. Session is initiated by the server in the first\n", 
            "  * response when it sends \"Set-Cookie\" HTTP header with the session ID. For all successive messages\n"
          ]
        }, 
        {
          "locn": "-33,6 +39,7", 
          "lines": [
            "     /*HTTP Headers  */\n", 
            "     private final static String COOKIE = \"Cookie\";\n", 
            "     private final static String SET_COOKIE = \"Set-Cookie\";\n", 
            "+    public static final String HOSTS = \"hosts\";\n", 
            " \n", 
            "     /**\n", 
            "      * Check if \"Cookie\" HTTP header is available. If so, check if that cookie is in the session\n"
          ]
        }, 
        {
          "locn": "-43,7 +50,52", 
          "lines": [
            "      * @return Endpoint Server endpoint for the given HTTP session.\n", 
            "      */\n", 
            "     public SessionInformation getSession(MessageContext synCtx) {\n", 
            "-        return SALSessions.getInstance().getSession(extractSessionID(synCtx, COOKIE));\n", 
            "+        String hostName = extractHost(synCtx);\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Extracted Host Name : \" + hostName);\n", 
            "+        }\n", 
            "+\n", 
            "+        // print TO\n", 
            "+        org.apache.axis2.context.MessageContext axis2MessageContext =\n", 
            "+                ((Axis2MessageContext) synCtx).getAxis2MessageContext();\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Endpoint Address : \" + axis2MessageContext.getTo().getAddress());\n", 
            "+        }\n", 
            "+\n", 
            "+        Map headerMap = getTransportHeaderMap(synCtx);\n", 
            "+        String contentType = (String)headerMap.get(\"Content-Type\");\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Content Type : \" + contentType);\n", 
            "+        }\n", 
            "+\n", 
            "+        if (hostName == null) {\n", 
            "+            return SALSessions.getInstance().getSession(extractSessionID(synCtx, COOKIE));\n", 
            "+        } else {\n", 
            "+            List<String> sessionList = extractSessionIDs(synCtx, COOKIE);\n", 
            "+            if (sessionList != null) {\n", 
            "+                for (String sessionID : sessionList) {\n", 
            "+                    SessionInformation sessionInfoObj = SALSessions.getInstance().getSession(sessionID);\n", 
            "+                    if (sessionInfoObj != null) {\n", 
            "+                        Map<String, String> subDomainNames =\n", 
            "+                                (Map<String, String>) sessionInfoObj.getMember().getProperties().get(HOSTS);\n", 
            "+                        if (log.isDebugEnabled()) {\n", 
            "+                            log.debug(\"Member Domain : \" + (subDomainNames != null ? subDomainNames.get(hostName) : null) +\n", 
            "+                                      \" : Session ID \" + sessionID);\n", 
            "+                        }\n", 
            "+                        if (subDomainNames != null && subDomainNames.get(hostName) != null) {\n", 
            "+                            if (log.isDebugEnabled()) {\n", 
            "+                                log.debug(\"Found a matching sessionInfo Object for the \" + hostName);\n", 
            "+                            }\n", 
            "+                            return sessionInfoObj;\n", 
            "+                        }\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+        if (log.isDebugEnabled()) {\n", 
            "+            log.debug(\"Did not find a session info obj.\");\n", 
            "+        }\n", 
            "+        return null;\n", 
            "     }\n", 
            " \n", 
            "     /**\n"
          ]
        }, 
        {
          "locn": "-86,4 +138,79", 
          "lines": [
            "     public void removeSessionID(MessageContext syCtx) {\n", 
            "         removeSessionID(syCtx, COOKIE);\n", 
            "     }\n", 
            "+\n", 
            "+    protected List<String> extractSessionIDs(MessageContext synCtx, String key) {\n", 
            "+        List<String> sessionList = new ArrayList<String>();\n", 
            "+        if (key != null) {\n", 
            "+            Map headerMap = getTransportHeaderMap(synCtx);\n", 
            "+            if (headerMap != null) {\n", 
            "+                Object hostObj = headerMap.get(\"Host\");\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"A request received with the Host Name : \" + hostObj);\n", 
            "+                }\n", 
            "+                Object cookieObj = headerMap.get(key);\n", 
            "+                if (cookieObj instanceof String) {\n", 
            "+                    String cookie = (String) cookieObj;\n", 
            "+                    if (log.isDebugEnabled()) {\n", 
            "+                        log.debug(\"Cookies String : \" + cookie);\n", 
            "+                    }\n", 
            "+                    // extract the first name value pair of the Set-Cookie header, which is considered\n", 
            "+                    // as the session id which will be sent back from the client with the Cookie header\n", 
            "+                    // for example;\n", 
            "+                    //      Set-Cookie: JSESSIONID=760764CB72E96A7221506823748CF2AE; Path=/\n", 
            "+                    // will result in the session id \"JSESSIONID=760764CB72E96A7221506823748CF2AE\"\n", 
            "+                    String[] sessionIds = cookie.split(\";\");\n", 
            "+                    if (sessionIds == null || sessionIds.length == 0) {\n", 
            "+                        if (log.isDebugEnabled()) {\n", 
            "+                            log.debug(\"Cannot find a session id for the cookie : \" + cookie);\n", 
            "+                        }\n", 
            "+                        return null;\n", 
            "+                    }\n", 
            "+                    for(String sessionId : sessionIds){\n", 
            "+                        if(sessionId != null && sessionId.contains(\"JSESSIONID\")) {\n", 
            "+                            if (log.isDebugEnabled()) {\n", 
            "+                                log.debug(\"Extracted SessionID : \" + sessionId);\n", 
            "+                            }\n", 
            "+                            sessionList.add(sessionId.trim());\n", 
            "+                        }\n", 
            "+                    }\n", 
            "+                } else {\n", 
            "+                    if (log.isDebugEnabled()) {\n", 
            "+                        log.debug(\"Couldn't find the \" + key + \" header to find the session\");\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            } else {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Couldn't find the TRANSPORT_HEADERS to find the session\");\n", 
            "+                }\n", 
            "+\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return sessionList;\n", 
            "+    }\n", 
            "+\n", 
            "+    private String extractHost(MessageContext synCtx) {\n", 
            "+        Map headerMap = getTransportHeaderMap(synCtx);\n", 
            "+        String hostName = null;\n", 
            "+        if (headerMap != null) {\n", 
            "+            Object hostObj = headerMap.get(HTTP.TARGET_HOST);\n", 
            "+            hostName = (String) hostObj;\n", 
            "+            if (hostName.contains(\":\")) {\n", 
            "+                hostName = hostName.substring(0, hostName.indexOf(\":\"));\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return hostName;\n", 
            "+    }\n", 
            "+\n", 
            "+    private Map getTransportHeaderMap(MessageContext synCtx) {\n", 
            "+\n", 
            "+        org.apache.axis2.context.MessageContext axis2MessageContext =\n", 
            "+                ((Axis2MessageContext) synCtx).getAxis2MessageContext();\n", 
            "+\n", 
            "+        Object o = axis2MessageContext.getProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);\n", 
            "+        if (o != null && o instanceof Map) {\n", 
            "+            return (Map) o;\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/HttpSessionDispatcher.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/HttpSessionDispatcher.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-223,7 +223,7", 
          "lines": [
            " \n", 
            "         if (sessionID == null || \"\".equals(sessionID)) {\n", 
            "             if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"Cannot find session ID .Returing null\");\n", 
            "+                log.debug(\"Cannot find session ID .Returning null\");\n", 
            "             }\n", 
            "             return null;\n", 
            "         }\n"
          ]
        }, 
        {
          "locn": "-342,7 +342,9", 
          "lines": [
            "                 }\n", 
            " \n", 
            "                 if (!toBeRemoved.isEmpty()) {\n", 
            "-                    log.info(\"Clearing expired sessions\");\n", 
            "+                    if (log.isDebugEnabled()) {\n", 
            "+                        log.debug(\"Clearing expired sessions\");\n", 
            "+                    }\n", 
            " \n", 
            "                     for (String key : toBeRemoved) {\n", 
            "                         Replicator.removeAndReplicateState(key, configCtx);\n"
          ]
        }, 
        {
          "locn": "-364,7 +366,9", 
          "lines": [
            "                 }\n", 
            " \n", 
            "                 if (!toBeRemoved.isEmpty()) {\n", 
            "-                    log.info(\"Clearing expired sessions\");\n", 
            "+                    if (log.isDebugEnabled()) {\n", 
            "+                        log.debug(\"Clearing expired sessions\");\n", 
            "+                    }\n", 
            "                     establishedSessions.keySet().removeAll(toBeRemoved);\n", 
            "                 }\n", 
            "             }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SALSessions.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SALSessions.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-61,6 +61,7", 
          "lines": [
            " \t/**\n", 
            " \t * Should this recipient list failover;\n", 
            " \t */\n", 
            "+    private boolean failover;\n", 
            "     private int currentPool;\n", 
            " \n", 
            "     private SynapseEnvironment env = null;\n"
          ]
        }, 
        {
          "locn": "-319,6 +320,14", 
          "lines": [
            "         return currentPool;\n", 
            "     }\n", 
            " \n", 
            "+    public boolean isFailover() {\n", 
            "+\t\treturn failover;\n", 
            "+\t}\n", 
            "+\n", 
            "+\tpublic void setFailover(boolean failover) {\n", 
            "+\t\tthis.failover = failover;\n", 
            "+\t}\n", 
            "+\n", 
            "     /**\n", 
            "      * create a simple LRU cached Endpoint pool for dynamic endpoints\n", 
            "      */\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/RecipientListEndpoint.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/RecipientListEndpoint.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,37", 
          "lines": [
            "+/*\n", 
            "+*  Copyright (c) 2005-2011, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n", 
            "+*\n", 
            "+*  WSO2 Inc. licenses this file to you under the Apache License,\n", 
            "+*  Version 2.0 (the \"License\"); you may not use this file except\n", 
            "+*  in compliance with the License.\n", 
            "+*  You may obtain a copy of the License at\n", 
            "+*\n", 
            "+*    http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+*\n", 
            "+* Unless required by applicable law or agreed to in writing,\n", 
            "+* software distributed under the License is distributed on an\n", 
            "+* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+* KIND, either express or implied.  See the License for the\n", 
            "+* specific language governing permissions and limitations\n", 
            "+* under the License.\n", 
            "+*/\n", 
            "+package org.apache.synapse.endpoints;\n", 
            "+\n", 
            "+import org.apache.axis2.addressing.EndpointReference;\n", 
            "+import org.apache.axis2.clustering.Member;\n", 
            "+import org.apache.axis2.clustering.management.GroupManagementAgent;\n", 
            "+import org.apache.synapse.FaultHandler;\n", 
            "+\n", 
            "+/**\n", 
            "+ * This FaultHandler will try to resend the message to another member if an error occurs\n", 
            "+ * while sending to some member. This is a failover mechanism\n", 
            "+ */\n", 
            "+public abstract class DynamicLoadbalanceFaultHandler extends FaultHandler {\n", 
            "+\n", 
            "+    public abstract void setCurrentMember(Member currentMember);\n", 
            "+\n", 
            "+    public abstract void setCurrentEp(Endpoint currentEp);\n", 
            "+\n", 
            "+    public abstract void setTo(EndpointReference to);\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/DynamicLoadbalanceFaultHandler.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/DynamicLoadbalanceFaultHandler.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-94,19 +94,8", 
          "lines": [
            "      * @param currentEPR The current position\n", 
            "      */\n", 
            "     public void setCurrentEndpointIndex(int currentEPR) {\n", 
            "-\n", 
            "-        if (isClusteringEnabled) {\n", 
            "-\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"Set EPR with key : \" + CURRENT_EPR_PROP_KEY + \" as : \" + currentEPR);\n", 
            "-            }\n", 
            "-            Replicator.setAndReplicateState(CURRENT_EPR_PROP_KEY, currentEPR, cfgCtx);\n", 
            "-        } else {\n", 
            "-            if (log.isDebugEnabled()) {\n", 
            "-                log.debug(\"Setting the current EPR as : \" + currentEPR);\n", 
            "-            }\n", 
            "-            this.currentEPR = currentEPR;\n", 
            "-        }\n", 
            "+        this.currentEPR = currentEPR;\n", 
            "+        cfgCtx.setNonReplicableProperty(CURRENT_EPR_PROP_KEY, currentEPR);\n", 
            "     }\n", 
            " \n", 
            "     /**\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/AlgorithmContext.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/AlgorithmContext.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-29,7 +29,7", 
          "lines": [
            "  * All load balance algorithms must implement this interface. Implementations of this interface can\n", 
            "  * be registered in LoadbalanceManagers.\n", 
            "  */\n", 
            "-public interface LoadbalanceAlgorithm {\n", 
            "+public interface LoadbalanceAlgorithm extends Cloneable {\n", 
            " \n", 
            "     /**\n", 
            "      * Set the application members\n"
          ]
        }, 
        {
          "locn": "-84,4 +84,6", 
          "lines": [
            "      * @return the name of the algorithm implemented\n", 
            "      */\n", 
            "     public String getName();\n", 
            "+\n", 
            "+    public LoadbalanceAlgorithm clone();\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/LoadbalanceAlgorithm.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/LoadbalanceAlgorithm.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-30,7 +30,7", 
          "lines": [
            "         algorithm.changeWeight(pos, weight);\n", 
            "     }\n", 
            " \n", 
            "-    public int[] getWeights() {\n", 
            "-        return algorithm.getWeights();\n", 
            "+    public int[] getCurrentWeights() {\n", 
            "+        return algorithm.getCurrentWeights();\n", 
            "     }\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/WeightedRoundRobinView.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/WeightedRoundRobinView.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-20,7 +20,8", 
          "lines": [
            " package org.apache.synapse.endpoints.algorithms;\n", 
            " \n", 
            " public interface WeightedRoundRobinViewMBean {\n", 
            "+\n", 
            "     void changeWeight(int pos, int weight);\n", 
            " \n", 
            "-    int[] getWeights();\n", 
            "+    int[] getCurrentWeights();\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/WeightedRoundRobinViewMBean.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/WeightedRoundRobinViewMBean.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-26,6 +26,8", 
          "lines": [
            " import org.apache.synapse.endpoints.Endpoint;\n", 
            " \n", 
            " import java.util.List;\n", 
            "+import java.util.concurrent.locks.Lock;\n", 
            "+import java.util.concurrent.locks.ReentrantLock;\n", 
            " \n", 
            " /**\n", 
            "  * This is the implementation of the round robin load balancing algorithm. It simply iterates\n"
          ]
        }, 
        {
          "locn": "-42,6 +44,8", 
          "lines": [
            " \n", 
            "     private List<Member> members;\n", 
            " \n", 
            "+    private final Lock lock = new ReentrantLock();\n", 
            "+\n", 
            "     public RoundRobin() {\n", 
            " \n", 
            "     }\n"
          ]
        }, 
        {
          "locn": "-100,27 +104,40", 
          "lines": [
            "         if (members.size() == 0) {\n", 
            "             return null;\n", 
            "         }\n", 
            "-        Member current;\n", 
            "-        synchronized (algorithmContext) {\n", 
            "+        Member current = null;\n", 
            "+        lock.lock();\n", 
            "+        try {\n", 
            "             int currentMemberIndex = algorithmContext.getCurrentEndpointIndex();\n", 
            "             if (currentMemberIndex >= members.size()) {\n", 
            "                 currentMemberIndex = 0;\n", 
            "             }\n", 
            "-            current = members.get(currentMemberIndex);\n", 
            "-            if (currentMemberIndex == members.size() - 1) {\n", 
            "-                currentMemberIndex = 0;\n", 
            "-            } else {\n", 
            "-                currentMemberIndex++;\n", 
            "-            }\n", 
            "+            int index = members.size();\n", 
            "+            do {\n", 
            "+                current = members.get(currentMemberIndex);\n", 
            "+                if (currentMemberIndex == members.size() - 1) {\n", 
            "+                    currentMemberIndex = 0;\n", 
            "+                } else {\n", 
            "+                    currentMemberIndex++;\n", 
            "+                }\n", 
            "+                index--;\n", 
            "+            } while (current.isSuspended() && index > 0);\n", 
            "             algorithmContext.setCurrentEndpointIndex(currentMemberIndex);\n", 
            "             if (log.isDebugEnabled()) {\n", 
            "                 log.debug(\"Members       : \" + members.size());\n", 
            "                 log.debug(\"Current member: \" + current);\n", 
            "             }\n", 
            "+\n", 
            "+        } finally {\n", 
            "+            lock.unlock();\n", 
            "         }\n", 
            "         return current;\n", 
            "     }\n", 
            " \n", 
            "+    @Override\n", 
            "+    public LoadbalanceAlgorithm clone() {\n", 
            "+        return new RoundRobin();\n", 
            "+    }\n", 
            "+\n", 
            "     public void reset(AlgorithmContext algorithmContext) {\n", 
            "         if (log.isDebugEnabled()) {\n", 
            "             log.debug(\"Resetting the Round Robin loadbalancing algorithm ...\");\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/RoundRobin.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/RoundRobin.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-159,6 +159,10", 
          "lines": [
            "         return WeightedRoundRobin.class.getName();\n", 
            "     }\n", 
            " \n", 
            "+    public LoadbalanceAlgorithm clone() {\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "     public void init(SynapseEnvironment se) {\n", 
            "         if (endpoints == null) {\n", 
            "             String msg = \"Endpoints are not set, cannot initialize the algorithm\";\n"
          ]
        }, 
        {
          "locn": "-346,7 +350,7", 
          "lines": [
            "         }\n", 
            "     }\n", 
            " \n", 
            "-    public int[] getWeights() {\n", 
            "+    public int[] getCurrentWeights() {\n", 
            "         int weights[] = new int[endpointStates.length];\n", 
            " \n", 
            "         for (int i = 0; i < weights.length; i++) {\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/WeightedRoundRobin.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/WeightedRoundRobin.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-237,6 +237,10", 
          "lines": [
            "         return WeightedRRLCAlgorithm.class.getName();\n", 
            "     }\n", 
            " \n", 
            "+    public LoadbalanceAlgorithm clone() {\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "     public int getEndpointCursor() {\n", 
            "         return endpointCursor;\n", 
            "     }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/WeightedRRLCAlgorithm.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/WeightedRRLCAlgorithm.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-23,11 +23,10", 
          "lines": [
            " import org.apache.axis2.context.ConfigurationContext;\n", 
            " import org.apache.commons.logging.Log;\n", 
            " import org.apache.commons.logging.LogFactory;\n", 
            "-import org.apache.synapse.FaultHandler;\n", 
            "+import org.apache.http.protocol.HTTP;\n", 
            " import org.apache.synapse.MessageContext;\n", 
            "+import org.apache.synapse.SynapseConstants;\n", 
            " import org.apache.synapse.SynapseException;\n", 
            "-import org.apache.synapse.SynapseConstants;\n", 
            "-import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            " import org.apache.synapse.core.LoadBalanceMembershipHandler;\n", 
            " import org.apache.synapse.core.SynapseEnvironment;\n", 
            " import org.apache.synapse.core.axis2.Axis2MessageContext;\n"
          ]
        }, 
        {
          "locn": "-34,15 +33,14", 
          "lines": [
            " import org.apache.synapse.core.axis2.Axis2SynapseEnvironment;\n", 
            " import org.apache.synapse.endpoints.algorithms.AlgorithmContext;\n", 
            " import org.apache.synapse.endpoints.dispatch.Dispatcher;\n", 
            "+import org.apache.synapse.endpoints.dispatch.HttpSessionDispatcher;\n", 
            " import org.apache.synapse.endpoints.dispatch.SALSessions;\n", 
            " import org.apache.synapse.endpoints.dispatch.SessionInformation;\n", 
            "+import org.apache.synapse.transport.nhttp.NhttpConstants;\n", 
            " \n", 
            " import java.net.MalformedURLException;\n", 
            " import java.net.URL;\n", 
            "-import java.util.List;\n", 
            "-import java.util.ArrayList;\n", 
            "-import java.util.Set;\n", 
            "-import java.util.UUID;\n", 
            "+import java.util.*;\n", 
            " \n", 
            " /**\n", 
            "  * Represents a dynamic load balance endpoint. The application membership is not static,\n"
          ]
        }, 
        {
          "locn": "-52,18 +50,20", 
          "lines": [
            " \n", 
            "     private static final Log log = LogFactory.getLog(DynamicLoadbalanceEndpoint.class);\n", 
            " \n", 
            "+    private static final String PORT_MAPPING_PREFIX = \"port.mapping.\";\n", 
            "+\n", 
            "     /**\n", 
            "      *  Flag to enable session affinity based load balancing.\n", 
            "      */\n", 
            "-    private boolean sessionAffinity = false;\n", 
            "+    protected boolean sessionAffinity = false;\n", 
            " \n", 
            "     /**\n", 
            "      * Dispatcher used for session affinity.\n", 
            "      */\n", 
            "-    private Dispatcher dispatcher = null;\n", 
            "+    protected Dispatcher dispatcher = null;\n", 
            " \n", 
            "     /* Sessions time out interval*/\n", 
            "-    private long sessionTimeout = -1;\n", 
            "+    protected long sessionTimeout = -1;\n", 
            " \n", 
            "     /**\n", 
            "      * The algorithm context , place holder for keep any runtime states related to the load balance\n"
          ]
        }, 
        {
          "locn": "-106,6 +106,9", 
          "lines": [
            "     public void send(MessageContext synCtx) {\n", 
            "         SessionInformation sessionInformation = null;\n", 
            "         Member currentMember = null;\n", 
            "+        //TODO Temp hack: ESB removes the session id from request in a random manner.\n", 
            "+        setCookieHeader(synCtx);\n", 
            "+\n", 
            "         ConfigurationContext configCtx =\n", 
            "                 ((Axis2MessageContext) synCtx).getAxis2MessageContext().getConfigurationContext();\n", 
            "         if (lbMembershipHandler.getConfigurationContext() == null) {\n"
          ]
        }, 
        {
          "locn": "-142,11 +145,13", 
          "lines": [
            "             }\n", 
            " \n", 
            "         }\n", 
            "-        \n", 
            "+\n", 
            "+        setupTransportHeaders(synCtx);\n", 
            "+        DynamicLoadbalanceFaultHandlerImpl faultHandler = new DynamicLoadbalanceFaultHandlerImpl();\n", 
            "         if (sessionInformation != null && currentMember != null) {\n", 
            "             //send message on current session\n", 
            "             sessionInformation.updateExpiryTime();\n", 
            "-            sendToApplicationMember(synCtx, currentMember, false);\n", 
            "+            sendToApplicationMember(synCtx, currentMember, faultHandler, false);\n", 
            "         } else {\n", 
            "             // prepare for a new session\n", 
            "             currentMember = lbMembershipHandler.getNextApplicationMember(algorithmContext);\n"
          ]
        }, 
        {
          "locn": "-155,16 +160,92", 
          "lines": [
            "                 log.error(msg);\n", 
            "                 throw new SynapseException(msg);\n", 
            "             }\n", 
            "-            sendToApplicationMember(synCtx, currentMember, true);\n", 
            "+            sendToApplicationMember(synCtx, currentMember, faultHandler, true);\n", 
            "         }\n", 
            "     }\n", 
            " \n", 
            "+    protected void setCookieHeader(MessageContext synCtx) {\n", 
            "+        String cookieHeader = extractSessionID(synCtx, \"Cookie\");\n", 
            "+        if (cookieHeader != null) {\n", 
            "+            synCtx.setProperty(\"LB_COOKIE_HEADER\", cookieHeader);\n", 
            "+        }\n", 
            "+    }\n", 
            "+\n", 
            "+    //TODO following methods are to extract the session ID temporary hack for Stratos 1.0.0 release\n", 
            "+    protected String extractSessionID(MessageContext synCtx, String key) {\n", 
            "+\n", 
            "+        if (key != null) {\n", 
            "+            Map headerMap = getTransportHeaderMap(synCtx);\n", 
            "+\n", 
            "+            if (headerMap != null) {\n", 
            "+                Object cookieObj = headerMap.get(key);\n", 
            "+\n", 
            "+                if (cookieObj instanceof String) {\n", 
            "+                    return (String) cookieObj;\n", 
            "+                } else {\n", 
            "+                    if (log.isDebugEnabled()) {\n", 
            "+                        log.debug(\"Couldn't find the \" + key + \" header to find the session\");\n", 
            "+                    }\n", 
            "+                }\n", 
            "+            } else {\n", 
            "+                if (log.isDebugEnabled()) {\n", 
            "+                    log.debug(\"Couldn't find the TRANSPORT_HEADERS to find the session\");\n", 
            "+                }\n", 
            "+\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    private Map getTransportHeaderMap(MessageContext synCtx) {\n", 
            "+\n", 
            "+        org.apache.axis2.context.MessageContext axis2MessageContext =\n", 
            "+                ((Axis2MessageContext) synCtx).getAxis2MessageContext();\n", 
            "+\n", 
            "+        Object o = axis2MessageContext.getProperty(\"TRANSPORT_HEADERS\");\n", 
            "+        if (o != null && o instanceof Map) {\n", 
            "+            return (Map) o;\n", 
            "+        }\n", 
            "+        return null;\n", 
            "+    }\n", 
            "+\n", 
            "+    /**\n", 
            "+     * Adds the X-Forwarded-For header to the outgoing message.\n", 
            "+     *\n", 
            "+     * @param synCtx Current message context\n", 
            "+     */\n", 
            "+\tprotected void setupTransportHeaders(MessageContext synCtx) {\n", 
            "+\t\tAxis2MessageContext axis2smc = (Axis2MessageContext) synCtx;\n", 
            "+        org.apache.axis2.context.MessageContext axis2MessageCtx =\n", 
            "+                axis2smc.getAxis2MessageContext();\n", 
            "+        Object headers = axis2MessageCtx.getProperty(\n", 
            "+                org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);\n", 
            "+        if (headers != null && headers instanceof Map ) {\n", 
            "+        \tMap headersMap = (Map) headers;\n", 
            "+        \tString xForwardFor = (String) headersMap.get(NhttpConstants.HEADER_X_FORWARDED_FOR);\n", 
            "+        \tString remoteHost = (String) axis2MessageCtx.getProperty(\n", 
            "+                    org.apache.axis2.context.MessageContext.REMOTE_ADDR);\n", 
            "+\n", 
            "+            if (xForwardFor != null && !\"\".equals(xForwardFor)) {\n", 
            "+                StringBuilder xForwardedForString = new StringBuilder();\n", 
            "+                xForwardedForString.append(xForwardFor);\n", 
            "+                if (remoteHost != null && !\"\".equals(remoteHost)) {\n", 
            "+                    xForwardedForString.append(\",\").append(remoteHost);\n", 
            "+                }\n", 
            "+                headersMap.put(NhttpConstants.HEADER_X_FORWARDED_FOR, xForwardedForString.toString());\n", 
            "+            } else {\n", 
            "+                headersMap.put(NhttpConstants.HEADER_X_FORWARDED_FOR,remoteHost);\n", 
            "+            }\n", 
            "+\n", 
            "+        }\n", 
            "+\t}\n", 
            "+\n", 
            "     public void setName(String name) {\n", 
            "         super.setName(name);\n", 
            " //        algorithmContext.setContextID(name);\n", 
            "     }\n", 
            " \n", 
            "-  public Dispatcher getDispatcher() {\n", 
            "+    public Dispatcher getDispatcher() {\n", 
            "         return dispatcher;\n", 
            "     }\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-188,8 +269,10", 
          "lines": [
            "         return sessionAffinity;\n", 
            "     }\n", 
            " \n", 
            "-    private void sendToApplicationMember(MessageContext synCtx,\n", 
            "-                                         Member currentMember, boolean newSession) {\n", 
            "+    protected void sendToApplicationMember(MessageContext synCtx,\n", 
            "+                                           Member currentMember,\n", 
            "+                                           DynamicLoadbalanceFaultHandler faultHandler,\n", 
            "+                                           boolean newSession) {\n", 
            "         //Rewriting the URL\n", 
            "         org.apache.axis2.context.MessageContext axis2MsgCtx =\n", 
            "                 ((Axis2MessageContext) synCtx).getAxis2MessageContext();\n"
          ]
        }, 
        {
          "locn": "-202,18 +285,19", 
          "lines": [
            " \n", 
            "         String transport = axis2MsgCtx.getTransportIn().getName();\n", 
            "         String address = synCtx.getTo().getAddress();\n", 
            "+        int incomingPort = extractPort(synCtx, transport);\n", 
            "         EndpointReference to = getEndpointReferenceAfterURLRewrite(currentMember,\n", 
            "-                transport, address);\n", 
            "+                transport, address, incomingPort);\n", 
            "         synCtx.setTo(to);\n", 
            " \n", 
            "-        DynamicLoadbalanceFaultHandler faultHandler = new DynamicLoadbalanceFaultHandler(to);\n", 
            "+        faultHandler.setTo(to);\n", 
            "         faultHandler.setCurrentMember(currentMember);\n", 
            "+        synCtx.pushFaultHandler(faultHandler);\n", 
            "         if (isFailover()) {\n", 
            "-            synCtx.pushFaultHandler(faultHandler);\n", 
            "             synCtx.getEnvelope().build();\n", 
            "         }\n", 
            " \n", 
            "-        Endpoint endpoint = getEndpoint(to, synCtx);\n", 
            "+        Endpoint endpoint = getEndpoint(to, currentMember, synCtx);\n", 
            "         faultHandler.setCurrentEp(endpoint);\n", 
            "         if (isSessionAffinityBasedLB() && newSession) {\n", 
            "             prepareEndPointSequence(synCtx, endpoint);\n"
          ]
        }, 
        {
          "locn": "-224,7 +308,25", 
          "lines": [
            "             synCtx.setProperty(SynapseConstants.PROP_SAL_ENDPOINT_FIRST_MESSAGE_IN_SESSION,\n", 
            "                     Boolean.TRUE);\n", 
            "         }\n", 
            "-        endpoint.send(synCtx);\n", 
            "+\n", 
            "+        Map<String, String> memberHosts;\n", 
            "+        if ((memberHosts = (Map<String, String>) currentMember.getProperties().get(\n", 
            "+                HttpSessionDispatcher.HOSTS)) == null) {\n", 
            "+            currentMember.getProperties().put(HttpSessionDispatcher.HOSTS,\n", 
            "+                    memberHosts = new HashMap<String, String>());\n", 
            "+        }\n", 
            "+        memberHosts.put(extractHost(synCtx), \"true\");\n", 
            "+\n", 
            "+        try {\n", 
            "+            endpoint.send(synCtx);\n", 
            "+        } catch (Exception e) {\n", 
            "+            if(e.getMessage().toLowerCase().contains(\"io reactor shutdown\")){\n", 
            "+                log.fatal(\"System cannot continue normal operation. Restarting\", e);\n", 
            "+                System.exit(121); // restart\n", 
            "+            } else {\n", 
            "+                throw new SynapseException(e);\n", 
            "+            }\n", 
            "+        }\n", 
            "     }\n", 
            " \n", 
            "     /*\n"
          ]
        }, 
        {
          "locn": "-259,10 +361,12", 
          "lines": [
            " \n", 
            "     private EndpointReference getEndpointReferenceAfterURLRewrite(Member currentMember,\n", 
            "                                                                   String transport,\n", 
            "-                                                                  String address) {\n", 
            "-        // URL rewrite\n", 
            "-        if (transport.equals(\"http\") || transport.equals(\"https\")) {\n", 
            "-            if (address.indexOf(\":\") != -1) {\n", 
            "+                                                                  String address,\n", 
            "+                                                                  int incomingPort) {\n", 
            "+\n", 
            "+        // URL Rewrite\n", 
            "+        if (\"http\".equals(transport) || \"https\".equals(transport)) {\n", 
            "+            if (address.startsWith(\"http://\") || address.startsWith(\"https://\")) {\n", 
            "                 try {\n", 
            "                     address = new URL(address).getPath();\n", 
            "                 } catch (MalformedURLException e) {\n"
          ]
        }, 
        {
          "locn": "-272,9 +376,19", 
          "lines": [
            "                 }\n", 
            "             }\n", 
            " \n", 
            "+            int port;\n", 
            "+            Properties memberProperties = currentMember.getProperties();\n", 
            "+            String mappedPort = memberProperties.getProperty(PORT_MAPPING_PREFIX + incomingPort);\n", 
            "+            if (mappedPort != null) {\n", 
            "+                port = Integer.parseInt(mappedPort);\n", 
            "+            } else if (\"http\".equals(transport)) {\n", 
            "+                port = currentMember.getHttpPort();\n", 
            "+            } else {\n", 
            "+                port = currentMember.getHttpsPort();\n", 
            "+            }\n", 
            "+\n", 
            "             return new EndpointReference(transport + \"://\" + currentMember.getHostName() +\n", 
            "-                    \":\" + (\"http\".equals(transport) ? currentMember.getHttpPort() :\n", 
            "-                    currentMember.getHttpsPort()) + address);\n", 
            "+                    \":\" + port + address);\n", 
            "         } else {\n", 
            "             String msg = \"Cannot load balance for non-HTTP/S transport \" + transport;\n", 
            "             log.error(msg);\n"
          ]
        }, 
        {
          "locn": "-285,14 +399,17", 
          "lines": [
            "     /**\n", 
            "      *\n", 
            "      * @param to get an endpoint to send the information\n", 
            "+     * @param member The member to which an EP has to be created\n", 
            "      * @param synCtx synapse context\n", 
            "      * @return the created endpoint\n", 
            "      */\n", 
            "-    private Endpoint getEndpoint(EndpointReference to, MessageContext synCtx) {\n", 
            "+    private Endpoint getEndpoint(EndpointReference to, Member member, MessageContext synCtx) {\n", 
            "         AddressEndpoint endpoint = new AddressEndpoint();\n", 
            "         endpoint.setEnableMBeanStats(false);\n", 
            "-        endpoint.setName(\"DYNAMIC_LOADBALANCE_EP_\" + UUID.randomUUID());\n", 
            "+        endpoint.setName(\"DLB:\" +  member.getHostName() +\n", 
            "+                \":\" + member.getPort() + \":\" + UUID.randomUUID());\n", 
            "         EndpointDefinition definition = new EndpointDefinition();\n", 
            "+        definition.setSuspendMaximumDuration(10000);\n", 
            "         definition.setReplicationDisabled(true);\n", 
            "         definition.setAddress(to.getAddress());\n", 
            "         endpoint.setDefinition(definition);\n"
          ]
        }, 
        {
          "locn": "-303,11 +420,51", 
          "lines": [
            "         return endpoint;\n", 
            "     }\n", 
            " \n", 
            "+    private String extractHost(MessageContext synCtx) {\n", 
            "+        org.apache.axis2.context.MessageContext msgCtx =\n", 
            "+                ((Axis2MessageContext) synCtx).getAxis2MessageContext();\n", 
            "+\n", 
            "+        Map headerMap = (Map) msgCtx.getProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);\n", 
            "+        String hostName = null;\n", 
            "+        if (headerMap != null) {\n", 
            "+            Object hostObj = headerMap.get(HTTP.TARGET_HOST);\n", 
            "+            hostName = (String) hostObj;\n", 
            "+            if (hostName.contains(\":\")) {\n", 
            "+                hostName = hostName.substring(0, hostName.indexOf(\":\"));\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return hostName;\n", 
            "+    }\n", 
            "+\n", 
            "+    private int extractPort(MessageContext synCtx, String transport) {\n", 
            "+        org.apache.axis2.context.MessageContext msgCtx =\n", 
            "+                ((Axis2MessageContext) synCtx).getAxis2MessageContext();\n", 
            "+\n", 
            "+        Map headerMap = (Map) msgCtx.getProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);\n", 
            "+        int port = -1;\n", 
            "+        if (headerMap != null) {\n", 
            "+            String hostHeader = (String) headerMap.get(HTTP.TARGET_HOST);\n", 
            "+            int index = hostHeader.indexOf(':');\n", 
            "+            if (index != -1) {\n", 
            "+                port = Integer.parseInt(hostHeader.trim().substring(index + 1));\n", 
            "+            } else {\n", 
            "+                if (\"http\".equals(transport)) {\n", 
            "+                    port = 80;\n", 
            "+                } else if (\"https\".equals(transport)) {\n", 
            "+                    port = 443;\n", 
            "+                }\n", 
            "+            }\n", 
            "+        }\n", 
            "+        return port;\n", 
            "+    }\n", 
            "+\n", 
            "+\n", 
            "+\n", 
            "     /**\n", 
            "      * This FaultHandler will try to resend the message to another member if an error occurs\n", 
            "      * while sending to some member. This is a failover mechanism\n", 
            "      */\n", 
            "-    private class DynamicLoadbalanceFaultHandler extends FaultHandler {\n", 
            "+    private class DynamicLoadbalanceFaultHandlerImpl extends DynamicLoadbalanceFaultHandler {\n", 
            " \n", 
            "         private EndpointReference to;\n", 
            "         private Member currentMember;\n"
          ]
        }, 
        {
          "locn": "-317,10 +474,13", 
          "lines": [
            "             this.currentMember = currentMember;\n", 
            "         }\n", 
            " \n", 
            "-        private DynamicLoadbalanceFaultHandler(EndpointReference to) {\n", 
            "+        public void setTo(EndpointReference to) {\n", 
            "             this.to = to;\n", 
            "         }\n", 
            " \n", 
            "+        private DynamicLoadbalanceFaultHandlerImpl() {\n", 
            "+        }\n", 
            "+\n", 
            "         public void onFault(MessageContext synCtx) {\n", 
            "             //cleanup endpoint if exists\n", 
            "             if(currentEp != null){\n"
          ]
        }, 
        {
          "locn": "-345,7 +505,7", 
          "lines": [
            "                     pros.remove(SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION);\n", 
            "                 }\n", 
            "             }\n", 
            "-            sendToApplicationMember(synCtx, currentMember, true);\n", 
            "+            sendToApplicationMember(synCtx, currentMember, this, true);\n", 
            "         }\n", 
            " \n", 
            "         public void setCurrentEp(Endpoint currentEp) {\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/DynamicLoadbalanceEndpoint.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/DynamicLoadbalanceEndpoint.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-33,7 +33,7", 
          "lines": [
            " \n", 
            " /**\n", 
            "  * This class represents a real endpoint referred by a key. An Indirect endpoint does not really\n", 
            "- * have a life, but merely acts as a virtual endpoint for the actual endpoint refferred.\n", 
            "+ * have a life, but merely acts as a virtual endpoint for the actual endpoint referred.\n", 
            "  */\n", 
            " public class IndirectEndpoint extends AbstractEndpoint {\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-90,7 +90,7", 
          "lines": [
            " \n", 
            "     @Override\n", 
            "     /**\n", 
            "-     * Since an Indirect never sends messages for real, it has no moetrics.. but those of its\n", 
            "+     * Since an Indirect never sends messages for real, it has no metrics.. but those of its\n", 
            "      * actual endpoint\n", 
            "      */\n", 
            "     public EndpointView getMetricsMBean() {\n"
          ]
        }, 
        {
          "locn": "-153,6 +153,14", 
          "lines": [
            "                 if (realEndpoint != null && !realEndpoint.isInitialized()) {\n", 
            "                     realEndpoint.init(synapseEnvironment);\n", 
            "                 }\n", 
            "+            } else {\n", 
            "+                Endpoint epr = synCfg.getEndpoint(key);\n", 
            "+                if (epr != realEndpoint) {\n", 
            "+                    realEndpoint = epr;\n", 
            "+                    if (realEndpoint != null && !realEndpoint.isInitialized()) {\n", 
            "+                        realEndpoint.init(synapseEnvironment);\n", 
            "+                    }\n", 
            "+                }\n", 
            "             }\n", 
            "         }\n", 
            "     }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/IndirectEndpoint.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/IndirectEndpoint.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-169,7 +169,7", 
          "lines": [
            "     public void setName(String endpointName) {\n", 
            "         this.endpointName = endpointName;\n", 
            "         if (enableMBeanStats) {\n", 
            "-            if(endpointName != null && !\"\".equals(endpointName.trim())){\n", 
            "+            if (endpointName == null || \"\".equals(endpointName.trim())) {\n", 
            "                 //we skip stat collection for endpoints with no defined name\n", 
            "                 log.warn(\"Endpoint Name not found. Skipped JMX statistics collection for this endpoint\");\n", 
            "                 return;\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/endpoints/AbstractEndpoint.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/endpoints/AbstractEndpoint.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-842,7 +842,7", 
          "lines": [
            "         String failSafeStr = synapseProps.getProperty(SynapseConstants.FAIL_SAFE_MODE_STATUS);\n", 
            "         if (failSafeStr != null) {\n", 
            "             String[] failSafeComponents = failSafeStr.split(\",\");\n", 
            "-            List<String> componentList = Arrays.<String>asList(failSafeComponents);\n", 
            "+            List<String> componentList = Arrays.asList(failSafeComponents);\n", 
            "             if (componentList.indexOf(SynapseConstants.FAIL_SAFE_MODE_ALL) >= 0\n", 
            "                     || componentList.indexOf(componentName) >= 0) {\n", 
            "                 return true;\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfigUtils.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfigUtils.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-156,8 +156,10", 
          "lines": [
            "     /**\n", 
            "      * The artifact deployment store to keep track of the items deployed\n", 
            "      */\n", 
            "-    SynapseArtifactDeploymentStore artifactDeploymentStore = new SynapseArtifactDeploymentStore();\n", 
            "+    private SynapseArtifactDeploymentStore artifactDeploymentStore = new SynapseArtifactDeploymentStore();\n", 
            " \n", 
            "+    private boolean allowHotUpdate = true;\n", 
            "+\n", 
            "     /**\n", 
            "      * Add a named sequence into the local registry. If a sequence already exists by the specified\n", 
            "      * key a runtime exception is thrown.\n"
          ]
        }, 
        {
          "locn": "-361,8 +363,8", 
          "lines": [
            " \n", 
            "     /**\n", 
            "      * Gets the mandatory sequence, from the direct reference. This is also available in the\n", 
            "-     * {@link SynapseConfiguration#getSequence} but this method improves the performance hence this\n", 
            "-     * will be required for all messages\n", 
            "+     * {@link SynapseConfiguration#getSequence(String)} but this method improves the\n", 
            "+     * performance hence this will be required for all messages\n", 
            "      *\n", 
            "      * @return mandatory sequence direct reference in the local configuration\n", 
            "      */\n"
          ]
        }, 
        {
          "locn": "-1516,7 +1518,7", 
          "lines": [
            "      * @param processor instance\n", 
            "      */\n", 
            "     public void addMessageProcessor(String name , MessageProcessor processor) {\n", 
            "-        if(!(messageProcessors.containsKey(processor))) {\n", 
            "+        if(!(messageProcessors.containsKey(name))) {\n", 
            "             messageProcessors.put(name , processor);\n", 
            "         } else {\n", 
            "             handleException(\"Duplicate Message Processor \" + name);\n"
          ]
        }, 
        {
          "locn": "-1582,12 +1584,12", 
          "lines": [
            " \n", 
            "     private void assertEntryNull(Entry entry, String key) {\n", 
            "         if (entry == null) {\n", 
            "-            handleException(\"Cannot locate an either local or remote enrty for key : \" + key);\n", 
            "+            handleException(\"Cannot locate an either local or remote entry for key : \" + key);\n", 
            "         }\n", 
            "     }\n", 
            " \n", 
            "     public void addEndpointTemplate(String name, Template template) {\n", 
            "-        assertAlreadyExists(name, SEQUENCE);\n", 
            "+        assertAlreadyExists(name, \"template\");\n", 
            "         localRegistry.put(name, template);\n", 
            "     }\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-1657,4 +1659,12", 
          "lines": [
            " \n", 
            "         return null;\n", 
            "     }\n", 
            "+\n", 
            "+    public boolean isAllowHotUpdate() {\n", 
            "+        return allowHotUpdate;\n", 
            "+    }\n", 
            "+\n", 
            "+    public void setAllowHotUpdate(boolean allowHotUpdate) {\n", 
            "+        this.allowHotUpdate = allowHotUpdate;\n", 
            "+    }\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,29", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.config.xml;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.synapse.config.Entry;\n", 
            "+\n", 
            "+public interface IEntryFactory {\n", 
            "+\n", 
            "+    public Entry createEntry(OMElement elem);\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/IEntryFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/IEntryFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-0,0 +1,29", 
          "lines": [
            "+/*\n", 
            "+ *  Licensed to the Apache Software Foundation (ASF) under one\n", 
            "+ *  or more contributor license agreements.  See the NOTICE file\n", 
            "+ *  distributed with this work for additional information\n", 
            "+ *  regarding copyright ownership.  The ASF licenses this file\n", 
            "+ *  to you under the Apache License, Version 2.0 (the\n", 
            "+ *  \"License\"); you may not use this file except in compliance\n", 
            "+ *  with the License.  You may obtain a copy of the License at\n", 
            "+ *\n", 
            "+ *   http://www.apache.org/licenses/LICENSE-2.0\n", 
            "+ *\n", 
            "+ *  Unless required by applicable law or agreed to in writing,\n", 
            "+ *  software distributed under the License is distributed on an\n", 
            "+ *   * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n", 
            "+ *  KIND, either express or implied.  See the License for the\n", 
            "+ *  specific language governing permissions and limitations\n", 
            "+ *  under the License.\n", 
            "+ */\n", 
            "+\n", 
            "+package org.apache.synapse.config.xml;\n", 
            "+\n", 
            "+import org.apache.axiom.om.OMElement;\n", 
            "+import org.apache.synapse.config.Entry;\n", 
            "+\n", 
            "+public interface IEntrySerializer {\n", 
            "+\n", 
            "+    public OMElement serializeEntry(Entry entry, OMElement parent);\n", 
            "+\n", 
            "+}\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/IEntrySerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/IEntrySerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-298,7 +298,6", 
          "lines": [
            "                         synapseConfig.getArtifactDeploymentStore().addArtifact(\n", 
            "                                 file.getAbsolutePath(), mediator.getName());\n", 
            "                     }\n", 
            "-                    return;\n", 
            " \n", 
            "                 } else {\n", 
            "                     element = document.getFirstChildWithName(\n"
          ]
        }, 
        {
          "locn": "-312,7 +311,6", 
          "lines": [
            "                             synapseConfig.getArtifactDeploymentStore().addArtifact(\n", 
            "                                     file.getAbsolutePath(), endpointTemplate.getName());\n", 
            "                         }\n", 
            "-                        return;\n", 
            "                     }\n", 
            "                 }\n", 
            "             }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MultiXMLConfigurationBuilder.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MultiXMLConfigurationBuilder.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-21,6 +21,7", 
          "lines": [
            " \n", 
            " import org.apache.synapse.SynapseConstants;\n", 
            " import org.apache.synapse.config.SynapseConfigUtils;\n", 
            "+import org.apache.synapse.config.SynapsePropertiesLoader;\n", 
            " import org.apache.synapse.config.XMLToObjectMapper;\n", 
            " import org.apache.synapse.config.Entry;\n", 
            " import org.apache.synapse.SynapseException;\n"
          ]
        }, 
        {
          "locn": "-47,6 +48,25", 
          "lines": [
            "             = new QName(SynapseConstants.SYNAPSE_NAMESPACE, \"description\");\n", 
            " \n", 
            "     public static Entry createEntry(OMElement elem, Properties properties) {\n", 
            "+        String customFactory = SynapsePropertiesLoader.getPropertyValue(\"synapse.entry.factory\", \"\");\n", 
            "+        if (customFactory != null && !\"\".equals(customFactory)) {\n", 
            "+            try {\n", 
            "+                Class c = Class.forName(customFactory);\n", 
            "+                Object o = c.newInstance();\n", 
            "+                if (o instanceof IEntryFactory) {\n", 
            "+                    return ((IEntryFactory)o).createEntry(elem);\n", 
            "+                }\n", 
            "+            } catch (ClassNotFoundException e) {\n", 
            "+                 handleException(\"Class specified by the synapse.entry.factory \" +\n", 
            "+                         \"synapse property not found: \" + customFactory, e);\n", 
            "+            } catch (InstantiationException e) {\n", 
            "+                handleException(\"Class specified by the synapse.entry.factory \" +\n", 
            "+                         \"synapse property cannot be instantiated: \" + customFactory, e);\n", 
            "+            } catch (IllegalAccessException e) {\n", 
            "+                handleException(\"Class specified by the synapse.entry.factory \" +\n", 
            "+                         \"synapse property cannot be accessed: \" + customFactory, e);\n", 
            "+            }\n", 
            "+        }\n", 
            " \n", 
            "         OMAttribute key = elem.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, \"key\"));\n", 
            "         if (key == null) {\n"
          ]
        }, 
        {
          "locn": "-95,6 +115,11", 
          "lines": [
            "         }\n", 
            "     }\n", 
            " \n", 
            "+    private static void handleException(String msg, Exception e) {\n", 
            "+        log.error(msg, e);\n", 
            "+        throw new SynapseException(msg, e);\n", 
            "+    }\n", 
            "+\n", 
            "     private static void handleException(String msg) {\n", 
            "         log.error(msg);\n", 
            "         throw new SynapseException(msg);\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/EntryFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/EntryFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-86,7 +86,7", 
          "lines": [
            "         }\n", 
            " \n", 
            "         if (itrMed.getTarget() != null && !itrMed.getTarget().isAsynchronous()) {\n", 
            "-            itrElem.addAttribute(\"sequential\", \"false\", nullNS);\n", 
            "+            itrElem.addAttribute(\"sequential\", \"true\", nullNS);\n", 
            "         }\n", 
            " \n", 
            "         itrElem.addChild(TargetSerializer.serializeTarget(itrMed.getTarget()));\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/IterateMediatorSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/IterateMediatorSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-24,8 +24,6", 
          "lines": [
            " import org.apache.synapse.Mediator;\n", 
            " import org.apache.synapse.mediators.store.MessageStoreMediator;\n", 
            " \n", 
            "-import javax.xml.namespace.QName;\n", 
            "-\n", 
            " /**\n", 
            "  * Serialize  an instance of a MessageStore mediator to the XML configuration .\n", 
            "  * <pre>\n"
          ]
        }, 
        {
          "locn": "-35,7 +33,6", 
          "lines": [
            "  */\n", 
            " public class MessageStoreMediatorSerializer extends AbstractMediatorSerializer {\n", 
            " \n", 
            "-    private static final QName STORE_Q    = new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, \"store\");\n", 
            "     private static final String  ATT_MESSAGE_STORE   = \"messageStore\";\n", 
            "     private static final String  ATT_SEQUENCE   = \"sequence\";\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-51,7 +48,7", 
          "lines": [
            " \n", 
            "         String messageStoreName = messageStoreMediator.getMessageStoreName();\n", 
            " \n", 
            "-        OMElement storeElem = fac.createOMElement(STORE_Q);\n", 
            "+        OMElement storeElem = fac.createOMElement(\"store\", synNS);\n", 
            " \n", 
            "         String name = messageStoreMediator.getName();\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MessageStoreMediatorSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MessageStoreMediatorSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-28,6 +28,7", 
          "lines": [
            " import org.apache.synapse.config.Entry;\n", 
            " import org.apache.synapse.SynapseException;\n", 
            " import org.apache.synapse.SynapseConstants;\n", 
            "+import org.apache.synapse.config.SynapsePropertiesLoader;\n", 
            " \n", 
            " import javax.xml.namespace.QName;\n", 
            " import javax.xml.stream.XMLStreamConstants;\n"
          ]
        }, 
        {
          "locn": "-53,6 +54,26", 
          "lines": [
            "      */\n", 
            "     public static OMElement serializeEntry(Entry entry, OMElement parent) {\n", 
            " \n", 
            "+        String customFactory = SynapsePropertiesLoader.getPropertyValue(\"synapse.entry.serializer\", \"\");\n", 
            "+        if (customFactory != null && !\"\".equals(customFactory)) {\n", 
            "+            try {\n", 
            "+                Class c = Class.forName(customFactory);\n", 
            "+                Object o = c.newInstance();\n", 
            "+                if (o instanceof IEntrySerializer) {\n", 
            "+                    return ((IEntrySerializer) o).serializeEntry(entry, parent);\n", 
            "+                }\n", 
            "+            } catch (ClassNotFoundException e) {\n", 
            "+                 handleException(\"Class specified by the synapse.entry.factory \" +\n", 
            "+                         \"synapse property not found: \" + customFactory, e);\n", 
            "+            } catch (InstantiationException e) {\n", 
            "+                handleException(\"Class specified by the synapse.entry.factory \" +\n", 
            "+                         \"synapse property cannot be instantiated: \" + customFactory, e);\n", 
            "+            } catch (IllegalAccessException e) {\n", 
            "+                handleException(\"Class specified by the synapse.entry.factory \" +\n", 
            "+                         \"synapse property cannot be accessed: \" + customFactory, e);\n", 
            "+            }\n", 
            "+        }\n", 
            "+\n", 
            "         OMElement entryElement = fac.createOMElement(\"localEntry\", synNS);\n", 
            "         \n", 
            "         if (entry.getDescription() != null) {\n"
          ]
        }, 
        {
          "locn": "-100,4 +121,9", 
          "lines": [
            "         log.error(msg);\n", 
            "         throw new SynapseException(msg);\n", 
            "     }\n", 
            "+\n", 
            "+    private static void handleException(String msg, Exception e) {\n", 
            "+        log.error(msg, e);\n", 
            "+        throw new SynapseException(msg, e);\n", 
            "+    }\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/EntrySerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/EntrySerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-90,7 +90,7", 
          "lines": [
            "             assert processor != null;\n", 
            "             processor.setMessageStoreName(storeAtt.getAttributeValue());\n", 
            "         } else {\n", 
            "-            handleException(\"Can't create message processor with out a message processor\");\n", 
            "+            handleException(\"Can't create message processor without a message store\");\n", 
            "         }\n", 
            " \n", 
            "         OMElement descriptionElem = elem.getFirstChildWithName(DESCRIPTION_Q);\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MessageProcessorFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/MessageProcessorFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-44,11 +44,6", 
          "lines": [
            "                 = fac.createOMElement(\"endpoint\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            "         \n", 
            "         WSDLEndpoint wsdlEndpoint = (WSDLEndpoint) endpoint;\n", 
            "-\n", 
            "-        // serialize the parameters\n", 
            "-        serializeProperties(wsdlEndpoint, endpointElement);\n", 
            "-\n", 
            "-        serializeCommonAttributes(endpoint,endpointElement);\n", 
            "         \n", 
            " \n", 
            "         OMElement wsdlElement = fac.createOMElement(\"wsdl\", SynapseConstants.SYNAPSE_OMNAMESPACE);\n"
          ]
        }, 
        {
          "locn": "-81,6 +76,10", 
          "lines": [
            "         serializeSpecificEndpointProperties(epDefinition, wsdlElement);\n", 
            "         endpointElement.addChild(wsdlElement);\n", 
            " \n", 
            "+        // serialize the parameters\n", 
            "+        serializeProperties(wsdlEndpoint, endpointElement);\n", 
            "+        serializeCommonAttributes(endpoint,endpointElement);\n", 
            "+\n", 
            "         return endpointElement;\n", 
            "     }\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/WSDLEndpointSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/WSDLEndpointSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-44,8 +44,8", 
          "lines": [
            "     public OMElement serializeEndpoint(Endpoint epr) {\n", 
            "         TemplateEndpoint endpoints = (TemplateEndpoint) epr;\n", 
            " \n", 
            "-        OMElement endpointElement = fac.createOMElement(\n", 
            "-                new QName(XMLConfigConstants.SYNAPSE_NAMESPACE, \"endpoint\"));\n", 
            "+        OMElement endpointElement = fac.createOMElement(\"endpoint\",\n", 
            "+                SynapseConstants.SYNAPSE_OMNAMESPACE);\n", 
            " \n", 
            "         if (endpoints.getName() != null) {\n", 
            "             endpointElement.addAttribute(\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/TemplateEndpointSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/TemplateEndpointSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-28,12 +28,9", 
          "lines": [
            " import org.apache.synapse.endpoints.RecipientListEndpoint;\n", 
            " \n", 
            " /**\n", 
            "- * @author nuwan\n", 
            "- * \n", 
            "- * erializes {@link RecipientListEndpoint} to an XML configuration.\n", 
            "+ * Serializes {@link RecipientListEndpoint} to an XML configuration.\n", 
            "  *\n", 
            "  * @see RecipientListEndpointFactory\n", 
            "- *\n", 
            "  */\n", 
            " public class RecipientListEndpointSerializer extends EndpointSerializer {\n", 
            " \n"
          ]
        }, 
        {
          "locn": "-80,9 +77,10", 
          "lines": [
            "         }else{\n", 
            "             OMElement dynamicEpEle = fac.createOMElement(\n", 
            "                     \"endpoints\", SynapseConstants.SYNAPSE_OMNAMESPACE, recipientListElement);\n", 
            "-            new ValueSerializer().serializeValue(recipientListEndpoint.getDynamicEnpointSet(), \"value\", dynamicEpEle);\n", 
            "-            dynamicEpEle.addAttribute(fac.createOMAttribute(\"cache\", null,\n", 
            "-                                                            String.valueOf(recipientListEndpoint.getCurrentPoolSize())));\n", 
            "+            new ValueSerializer().serializeValue(recipientListEndpoint.getDynamicEnpointSet(),\n", 
            "+                    \"value\", dynamicEpEle);\n", 
            "+            dynamicEpEle.addAttribute(fac.createOMAttribute(\"max-cache\", null,\n", 
            "+                    String.valueOf(recipientListEndpoint.getCurrentPoolSize())));\n", 
            "             recipientListElement.addChild(dynamicEpEle);\n", 
            "         }\n", 
            " \n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/RecipientListEndpointSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/RecipientListEndpointSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-46,9 +46,6", 
          "lines": [
            "         \n", 
            "         LoadbalanceEndpoint loadbalanceEndpoint = (LoadbalanceEndpoint) endpoint;\n", 
            " \n", 
            "-        // serialize the parameters\n", 
            "-        serializeProperties(loadbalanceEndpoint, endpointElement);\n", 
            "-\n", 
            "         serializeCommonAttributes(endpoint,endpointElement);\n", 
            " \n", 
            "         OMElement loadbalanceElement\n"
          ]
        }, 
        {
          "locn": "-83,6 +80,10", 
          "lines": [
            "                 loadbalanceElement.addChild(memberEle);\n", 
            "             }\n", 
            "         }\n", 
            "+\n", 
            "+        // serialize the parameters\n", 
            "+        serializeProperties(loadbalanceEndpoint, endpointElement);\n", 
            "+\n", 
            "         return endpointElement;\n", 
            "     }\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointSerializer.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointSerializer.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-120,6 +120,8", 
          "lines": [
            "             String failover = loadbalanceElement.getAttributeValue(new QName(\"failover\"));\n", 
            "             if (failover != null && failover.equalsIgnoreCase(\"false\")) {\n", 
            "                 loadbalanceEndpoint.setFailover(false);\n", 
            "+            } else {\n", 
            "+                loadbalanceEndpoint.setFailover(true);\n", 
            "             }\n", 
            " \n", 
            "             OMElement eventHandler =\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DynamicLoadbalanceEndpointFactory.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DynamicLoadbalanceEndpointFactory.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-218,7 +218,7", 
          "lines": [
            "             }\n", 
            "         }\n", 
            " \n", 
            "-        newMC.setServerSide(ori.isServerSide());\n", 
            "+        newMC.setServerSide(false);\n", 
            " \n", 
            "         return newMC;\n", 
            "     }\n"
          ]
        }
      ], 
      "to": "java/modules/core/src/main/java/org/apache/synapse/util/MessageHelper.java", 
      "from": "java/modules/core/src/main/java/org/apache/synapse/util/MessageHelper.java"
    }, 
    {
      "chunks": [
        {
          "locn": "-144,4 +144,6", 
          "lines": [
            "     public static final String FORCE_CONNECTION_CLOSE = \"FORCE_CONNECTION_CLOSE\";\n", 
            "     public static final String PORT_OFFSET = \"portOffset\";\n", 
            "     public static final String ENDPOINTS_CONFIGURATION = \"endpointsConfiguration\";\n", 
            "+\n", 
            "+    public static final String HEADER_X_FORWARDED_FOR = \"X-Forwarded-For\";\n", 
            " }\n"
          ]
        }
      ], 
      "to": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java", 
      "from": "java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java"
    }
  ], 
  "id": "1210456"
}